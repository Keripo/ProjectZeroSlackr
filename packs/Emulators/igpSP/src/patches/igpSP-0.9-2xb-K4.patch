diff -ur common.h common.h
--- common.h	2007-04-08 21:35:13.000000000 -0400
+++ common.h	2008-05-10 14:00:02.593750000 -0400
@@ -32,6 +32,7 @@
   #include <stdlib.h>
   #include <stdio.h>
   #include <string.h>
+  #include <strings.h>
   #include <math.h>
   #include <fcntl.h>
   #include <unistd.h>
@@ -102,7 +103,9 @@
   #include <time.h>
   #include <stdio.h>
 #else
+#ifndef IPOD_BUILD
   #include "SDL.h"
+#endif
 
 #ifdef ARM_ARCH
   #define function_cc
@@ -237,7 +240,9 @@
 #include <stdlib.h>
 #include <string.h>
 #include <stdarg.h>
+#ifndef IPOD_BUILD
 #include "SDL.h"
+#endif
 #include "cpu.h"
 #include "memory.h"
 #include "video.h"
diff -ur cpu.c cpu.c
--- cpu.c	2007-04-08 21:35:13.000000000 -0400
+++ cpu.c	2008-05-10 14:00:48.328125000 -0400
@@ -1143,10 +1143,10 @@
   address32(address_region, (address + offset) & 0x7FFF) = dest               \
 
 #define arm_block_memory_offset_down_a()                                      \
-  (base - (word_bit_count(reg_list) * 4) + 4)                                 \
+  (base - (word_bit_count(reg_list) << 2) + 4)                                 \
 
 #define arm_block_memory_offset_down_b()                                      \
-  (base - (word_bit_count(reg_list) * 4))                                     \
+  (base - (word_bit_count(reg_list) << 2))                                     \
 
 #define arm_block_memory_offset_no()                                          \
   (base)                                                                      \
@@ -1155,10 +1155,10 @@
   (base + 4)                                                                  \
 
 #define arm_block_memory_writeback_down()                                     \
-  reg[rn] = base - (word_bit_count(reg_list) * 4)                             \
+  reg[rn] = base - (word_bit_count(reg_list) << 2)                             \
 
 #define arm_block_memory_writeback_up()                                       \
-  reg[rn] = base + (word_bit_count(reg_list) * 4)                             \
+  reg[rn] = base + (word_bit_count(reg_list) << 2)                             \
 
 #define arm_block_memory_writeback_no()                                       \
 
@@ -1456,13 +1456,13 @@
 #define thumb_block_address_preadjust_no_op()                                 \
 
 #define thumb_block_address_preadjust_up()                                    \
-  address += bit_count[reg_list] * 4                                          \
+  address += bit_count[reg_list] << 2                                          \
 
 #define thumb_block_address_preadjust_down()                                  \
-  address -= bit_count[reg_list] * 4                                          \
+  address -= bit_count[reg_list] << 2                                          \
 
 #define thumb_block_address_preadjust_push_lr()                               \
-  address -= (bit_count[reg_list] + 1) * 4                                    \
+  address -= (bit_count[reg_list] + 1) << 2                                    \
 
 #define thumb_block_address_postadjust_no_op()                                \
 
@@ -4142,8 +4142,10 @@
   {
     u32 key = 0;
 
+#ifndef IPOD_BUILD
     SDL_LockMutex(sound_mutex);
     SDL_PauseAudio(1);
+#endif
 
     if(output_field >= num_output_fields)
     {
@@ -4277,8 +4279,10 @@
         quit();
     }
 
+#ifndef IPOD_BUILD
     SDL_PauseAudio(0);
     SDL_UnlockMutex(sound_mutex);
+#endif
   }
 
   last_instruction = reg[REG_PC];
diff -ur cpu_threaded.c cpu_threaded.c
--- cpu_threaded.c	2007-04-08 21:35:13.000000000 -0400
+++ cpu_threaded.c	2008-05-10 14:00:02.625000000 -0400
@@ -198,6 +198,10 @@
 
 #include "giz/arm_emit.h"
 
+#elif defined(IPOD_BUILD)
+
+#include "gp2x/arm_emit.h"
+
 #else
 
 #include "x86/x86_emit.h"
diff -ur font.h font.h
--- font.h	2007-04-08 21:35:13.000000000 -0400
+++ font.h	2008-05-10 14:00:02.625000000 -0400
@@ -20,8 +20,13 @@
 /* Generated by convbdf on Fri Aug 18 17:44:10 2006. */
 /* Slightly modified by Exophase. Big thanks to ajs for converting this! */
 
+#ifdef IPOD_BUILD
+#define FONT_WIDTH  6
+#define FONT_HEIGHT 11
+#else
 #define FONT_WIDTH  6
 #define FONT_HEIGHT 10
+#endif
 
 /* Font information:
    name: 6x10
diff -ur gui.c gui.c
--- gui.c	2007-04-08 21:35:13.000000000 -0400
+++ gui.c	2008-05-21 21:02:27.234375000 -0400
@@ -38,6 +38,12 @@
 #define FILE_LIST_POSITION 5
 #define DIR_LIST_POSITION 260
 
+#elif defined(IPOD_BUILD)
+
+#define FILE_LIST_ROWS 10
+#define FILE_LIST_POSITION 5
+#define DIR_LIST_POSITION 80
+
 #else
 
 #define FILE_LIST_ROWS 25
@@ -58,7 +64,7 @@
 
 #endif
 
-#ifdef GP2X_BUILD
+#if defined(GP2X_BUILD) || defined(IPOD_BUILD)
 
 #define COLOR_BG            color16(0, 0, 0)
 
@@ -74,6 +80,8 @@
 #define COLOR_FRAMESKIP_BAR color16(15, 31, 31)
 #define COLOR_HELP_TEXT     color16(16, 40, 24)
 
+extern u32 file_length(u8 *dummy, FILE *fp);
+
 int sort_function(const void *dest_str_ptr, const void *src_str_ptr)
 {
   char *dest_str = *((char **)dest_str_ptr);
@@ -640,7 +648,7 @@
 
 #endif
 
-#ifdef GP2X_BUILD
+#if defined(GP2X_BUILD) || defined(IPOD_BUILD)
 
 u32 gamepad_config_line_to_button[] =
  { 0, 2, 1, 3, 8, 9, 10, 11, 6, 7, 4, 5 };
@@ -699,7 +707,7 @@
     return 0;
 
   current_frameskip_type = auto_frameskip;
-  frameskip_value = 4;
+  frameskip_value = 6;
   random_skip = 0;
   clock_speed = 333;
 
@@ -1008,7 +1016,11 @@
 
   void menu_load()
   {
+#ifdef IPOD_BUILD
+    u8 *file_ext[] = { ".gba", ".bin", NULL };
+#else
     u8 *file_ext[] = { ".gba", ".bin", ".zip", NULL };
+#endif
     u8 load_filename[512];
     save_game_config_file();
     if(load_file(file_ext, load_filename) != -1)
@@ -1191,6 +1203,24 @@
   };
 
   // Marker for help information, don't go past this mark (except \n)------*
+#ifdef IPOD_BUILD
+menu_option_type graphics_sound_options[] =
+  {
+    string_selection_option(NULL, "Frameskip type", frameskip_options,
+     (u32 *)(&current_frameskip_type), 3, "", 0),
+    numeric_selection_option(NULL, "Frameskip value", &frameskip_value,
+	 100, "", 1),
+    string_selection_option(NULL, "Framskip variation",
+     frameskip_variation_options, &random_skip, 2, "", 2)
+#ifndef NOSOUND
+	 ,
+    string_selection_option(NULL, "Audio output", yes_no_options,
+     &global_enable_audio, 2, "", 3),
+    string_selection_option(NULL, "Audio buffer", audio_buffer_options,
+             &audio_buffer_size_number, 10, "", 4)
+#endif
+  };
+#else
   menu_option_type graphics_sound_options[] =
   {
     string_selection_option(NULL, "Display scaling", scale_options,
@@ -1242,9 +1272,25 @@
      10),
     submenu_option(NULL, "Back", "Return to the main menu.", 12)
   };
+#endif
 
   make_menu(graphics_sound, submenu_graphics_sound, NULL);
 
+#ifdef IPOD_BUILD
+// Only displays up to 8 menu items for some reason
+  menu_option_type cheats_misc_options[] =
+  {
+    cheat_option(0),
+    cheat_option(1),
+    cheat_option(2),
+    cheat_option(3),
+    cheat_option(4),
+    cheat_option(5),
+    cheat_option(6),
+    cheat_option(7),
+    cheat_option(8)
+  };
+#else
   menu_option_type cheats_misc_options[] =
   {
     cheat_option(0),
@@ -1270,9 +1316,26 @@
      "Use the latter with extreme care.", 12),
     submenu_option(NULL, "Back", "Return to the main menu.", 14)
   };
+#endif
 
   make_menu(cheats_misc, submenu_cheats_misc, NULL);
 
+#ifdef IPOD_BUILD
+  menu_option_type savestate_options[] =
+  {
+    numeric_selection_action_hide_option(menu_load_state, menu_change_state,
+     "Load savestate from current slot", &savestate_slot, 10, "", 0),
+    numeric_selection_action_hide_option(menu_save_state, menu_change_state,
+     "Save savestate to current slot", &savestate_slot, 10, "", 1),
+    numeric_selection_action_hide_option(menu_load_state_file,
+      menu_change_state,
+     "Load savestate from file", &savestate_slot, 10, "", 2),
+    numeric_selection_option(menu_change_state,
+     "Current savestate slot", &savestate_slot, 10, "", 3),
+	string_selection_option(NULL, "Update backup",
+     update_backup_options, &update_backup_flag, 2, "", 4)
+  };
+#else
   menu_option_type savestate_options[] =
   {
     numeric_selection_action_hide_option(menu_load_state, menu_change_state,
@@ -1293,6 +1356,7 @@
      "Change the current savestate slot.\n", 11),
     submenu_option(NULL, "Back", "Return to the main menu.", 13)
   };
+#endif
 
   make_menu(savestate, submenu_savestate, NULL);
 
@@ -1375,9 +1439,66 @@
 
 #endif
 
+#ifndef IPOD_BUILD
   make_menu(gamepad_config, submenu_gamepad, NULL);
   make_menu(analog_config, submenu_analog, NULL);
+#endif
+
+#ifdef IPOD_BUILD
+  extern int ipod_scale_type;
+  extern int ipod_cpu_speed;
+  extern int ipod_contrast;
+  extern int ipod_map_triggers;
+  extern int ipod_menu_scrolling;
+  extern void ipod_toggle_backlight();
+  u8 *on_off_options[] = { "On", "Off" };
+  u8 *off_on_options[] = { "Off", "On" };
+  u8 *scale_type_options[] = { "Unscaled", "Full-screen", "Scale to height", "Scale to width" };
+  u8 *cpu_speed_options[] = { "Normal", "Overclock", "Max Overclock" };
+
+  void submenu_ipod_tweaks() {}
+
+  menu_option_type ipod_tweaks_options[] =
+  {
+    string_selection_option(NULL, "Scale type",
+     scale_type_options, (u32 *)(&ipod_scale_type), 4, "", 0),
+    string_selection_option(NULL, "Alpha Blending",
+     on_off_options, &no_alpha, 2, "", 1),
+    string_selection_option(NULL, "CPU Speed",
+     cpu_speed_options, (u32 *)(&ipod_cpu_speed), 3, "", 2),
+    numeric_selection_option(NULL, "Contrast",
+     (u32 *)(&ipod_contrast), 120, "", 3),
+    action_option(ipod_toggle_backlight, NULL, "Toggle Backlight", "", 4),
+    string_selection_option(NULL, "Menu scrolling",
+     off_on_options, (u32 *)(&ipod_menu_scrolling), 2, "", 5),
+    string_selection_option(NULL, "Map L/R Triggers",
+     off_on_options, (u32 *)(&ipod_map_triggers), 2, "", 6)
+  };
+
+  make_menu(ipod_tweaks, submenu_ipod_tweaks, NULL);
 
+#endif
+
+#ifdef IPOD_BUILD
+  menu_option_type main_options[] =
+  {
+    submenu_option(&ipod_tweaks_menu, "iPod Tweaks and Options", "", 0),
+    numeric_selection_action_option(menu_load_state, NULL,
+     "Load state from slot", &savestate_slot, 10, "", 1),
+    numeric_selection_action_option(menu_save_state, NULL,
+     "Save state to slot", &savestate_slot, 10, "", 2),
+    submenu_option(&savestate_menu, "Savestate Options", "", 3),
+#ifndef NOSOUND
+    submenu_option(&graphics_sound_menu, "Frameskip and Sound", "", 4),
+#else
+    submenu_option(&graphics_sound_menu, "Frameskip Options", "", 4),
+#endif
+    submenu_option(&cheats_misc_menu, "Enable Cheats", "", 5),
+    action_option(menu_load, NULL, "Load new game", "", 6),
+    action_option(menu_restart, NULL, "Restart game", "", 7),
+    action_option(menu_quit, NULL, "Exit igpSP", "", 8)
+  };
+#else
   menu_option_type main_options[] =
   {
     submenu_option(&graphics_sound_menu, "Graphics and Sound options",
@@ -1415,13 +1536,16 @@
     action_option(menu_quit, NULL, "Exit gpSP",
      "Select to exit gpSP and return to the PSP XMB/loader.", 15)
   };
+#endif
 
   make_menu(main, submenu_main, NULL);
 
   void choose_menu(menu_type *new_menu)
   {
+#ifndef IPOD_BUILD
     if(new_menu == NULL)
       new_menu = &main_menu;
+#endif
 
     clear_screen(COLOR_BG);
 
@@ -1446,6 +1570,7 @@
 
   video_resolution_large();
 
+#ifndef IPOD_BUILD
 #ifndef GP2X_BUILD
   SDL_LockMutex(sound_mutex);
 #endif
@@ -1454,6 +1579,7 @@
 #ifndef GP2X_BUILD
   SDL_UnlockMutex(sound_mutex);
 #endif
+#endif
 
   if(gamepak_filename[0] == 0)
   {
@@ -1599,7 +1725,9 @@
     scePowerSetClockFrequency(clock_speed, clock_speed, clock_speed / 2);
   #endif
 
+#ifndef IPOD_BUILD
   SDL_PauseAudio(0);
+#endif
 
   return return_value;
 }
diff -ur input.c input.c
--- input.c	2007-04-08 21:35:13.000000000 -0400
+++ input.c	2008-05-21 20:08:25.390625000 -0400
@@ -629,6 +629,58 @@
 #endif
 
 
+#ifdef IPOD_BUILD
+
+#include "ipod/ipod_common.h"
+
+// Doesn't do anything but needed for config file
+u32 gamepad_config_map[16] =
+{
+  BUTTON_ID_MENU,
+  BUTTON_ID_A,
+  BUTTON_ID_B,
+  BUTTON_ID_START,
+  BUTTON_ID_L,
+  BUTTON_ID_R,
+  BUTTON_ID_DOWN,
+  BUTTON_ID_LEFT,
+  BUTTON_ID_UP,
+  BUTTON_ID_RIGHT,
+  BUTTON_ID_SELECT,
+  BUTTON_ID_START,
+  BUTTON_ID_UP,
+  BUTTON_ID_DOWN,
+  BUTTON_ID_LEFT,
+  BUTTON_ID_RIGHT
+};
+
+void enter_menu()
+{
+  u32 ret_val;
+  u16 *screen_copy;
+  screen_copy = copy_screen();
+  ret_val = menu(screen_copy);
+  free(screen_copy);
+}
+
+u32 update_input()
+{
+  u32 key;
+  key = ipod_update_ingame_input();
+  trigger_key(key);
+  io_registers[REG_P1] = (~key) & 0x3FF;
+  return 0;
+}
+
+void init_input() {};
+
+gui_action_type get_gui_input()
+{
+  return ipod_update_menu_input();
+}
+
+#endif
+
 
 #ifdef PC_BUILD
 
diff -ur main.c main.c
--- main.c	2007-04-08 21:35:13.000000000 -0400
+++ main.c	2008-05-22 17:08:36.750000000 -0400
@@ -50,6 +50,15 @@
 u32 gp2x_fps_debug = 0;
 
 void gp2x_quit(void);
+
+#elif defined(IPOD_BUILD)
+
+#include "ipod/ipod_common.h"
+
+u32 frameskip_value = 6;
+u64 frame_count_initial_timestamp = 0;
+u64 last_frame_interval_timestamp;
+
 #else
 
 u32 frameskip_value = 4;
@@ -97,6 +106,8 @@
   if(timer[timer_number].status == TIMER_PRESCALE)                            \
     check_count(timer[timer_number].count);                                   \
 
+#ifndef NOSOUND
+
 #define update_timer(timer_number)                                            \
   if(timer[timer_number].status != TIMER_INACTIVE)                            \
   {                                                                           \
@@ -134,7 +145,43 @@
     }                                                                         \
   }                                                                           \
 
+#else
+
+#define update_timer(timer_number)                                            \
+  if(timer[timer_number].status != TIMER_INACTIVE)                            \
+  {                                                                           \
+    if(timer[timer_number].status != TIMER_CASCADE)                           \
+    {                                                                         \
+      timer[timer_number].count -= execute_cycles;                            \
+      io_registers[REG_TM##timer_number##D] =                                 \
+       -(timer[timer_number].count >> timer[timer_number].prescale);          \
+    }                                                                         \
+                                                                              \
+    if(timer[timer_number].count <= 0)                                        \
+    {                                                                         \
+      if(timer[timer_number].irq == TIMER_TRIGGER_IRQ)                        \
+        irq_raised |= IRQ_TIMER##timer_number;                                \
+                                                                              \
+      if((timer_number != 3) &&                                               \
+       (timer[timer_number + 1].status == TIMER_CASCADE))                     \
+      {                                                                       \
+        timer[timer_number + 1].count--;                                      \
+        io_registers[REG_TM0D + (timer_number + 1) * 2] =                     \
+         -(timer[timer_number + 1].count);                                    \
+      }                                                                       \
+                                                                              \
+      timer[timer_number].count +=                                            \
+       (timer[timer_number].reload << timer[timer_number].prescale);          \
+    }                                                                         \
+  }                                                                           \
+
+#endif
+
+#ifdef IPOD_BUILD
+u8 *file_ext[] = { ".gba", ".bin", NULL };
+#else
 u8 *file_ext[] = { ".gba", ".bin", ".zip", NULL };
+#endif
 
 #ifdef ARM_ARCH
 void ChangeWorkingDirectory(char *exe)
@@ -159,7 +206,9 @@
   for(i = 0; i < 4; i++)
   {
     dma[i].start_type = DMA_INACTIVE;
+#ifndef NOSOUND
     dma[i].direct_sound_channel = DMA_NO_DIRECT_SOUND;
+#endif
     timer[i].status = TIMER_INACTIVE;
     timer[i].reload = 0x10000;
     timer[i].stop_cpu_ticks = 0;
@@ -221,6 +270,13 @@
   delay_us(2500000);
 #endif
 
+#ifdef IPOD_BUILD
+  ipod_init_hw();
+  ipod_init_input();
+  ipod_init_cop();
+  // ipod_init_video() is called by init_video()
+#endif
+
   init_video();
 
 #ifdef GP2X_BUILD
@@ -288,7 +344,9 @@
   }
 
   init_main();
+#ifndef NOSOUND
   init_sound();
+#endif
 
   init_input();
 
@@ -342,7 +400,7 @@
   execute_arm_translate(execute_cycles);
 #else
 
-#ifdef GP2X_BUILD
+#if defined(GP2X_BUILD) || defined(IPOD_BUILD)
   get_ticks_us(&frame_count_initial_timestamp);
 #endif
 
@@ -351,7 +409,9 @@
    current_savestate_filename);
   load_state(current_savestate_filename); */
 
+#ifndef IPOD_BUILD
   debug_on();
+#endif
 
   if(argc > 2)
   {
@@ -404,7 +464,9 @@
   u64 new_ticks;
   u8 current_savestate_filename[512];
 
+#ifndef BENCHMARK
   return;
+#else
 
   if(event_number)
   {
@@ -475,14 +537,14 @@
        benchmark_ticks[6];
       benchmark_ticks[7] = benchmark_ticks[0] - benchmark_ticks[1];
 
-      printf("Benchmark results (%d frames): \n", event_cycles_trigger);
+      fprintf(stderr, "Benchmark results (%d frames): \n", event_cycles_trigger);
       for(i = 0; i < 8; i++)
       {
-        printf("   %s: %d ms (%f ms per frame)\n",
+        fprintf(stderr, "   %s: %d ms (%f ms per frame)\n",
          print_strings[i], (u32)benchmark_ticks[i] / 1000,
          (float)(benchmark_ticks[i] / (1000.0 * event_cycles_trigger)));
         if(i == 4)
-          printf("\n");
+          fprintf(stderr, "\n");
       }
       quit();
     }
@@ -492,6 +554,7 @@
 
   get_ticks_us(benchmark_ticks + event_number);
   event_number++;
+#endif
 }
 
 u32 update_gba()
@@ -504,12 +567,14 @@
 
     reg[CHANGED_PC_STATUS] = 0;
 
+#ifndef NOSOUND
     if(gbc_sound_update)
     {
       gbc_update_count++;
       update_gbc_sound(cpu_ticks);
       gbc_sound_update = 0;
     }
+#endif
 
     update_timer(0);
     update_timer(1);
@@ -607,7 +672,9 @@
           if(update_input())
             continue;
 
+#ifndef NOSOUND
           update_gbc_sound(cpu_ticks);
+#endif
           synchronize();
 
           update_screen();
@@ -750,7 +817,7 @@
 
 #endif
 
-#ifdef GP2X_BUILD
+#if defined(GP2X_BUILD) || defined(IPOD_BUILD)
 
 u32 real_frame_count = 0;
 u32 virtual_frame_count = 0;
@@ -769,12 +836,14 @@
   static u32 fps = 60;
   static u32 frames_drawn = 60;
 
+#ifdef GP2X_BUILD
   if(gp2x_fps_debug)
   {
     char print_buffer[128];
     sprintf(print_buffer, "%d (%d)", fps, frames_drawn);
     print_string(print_buffer, 0xFFFF, 0x000, 0, 0);
   }
+#endif
 
   get_ticks_us(&new_ticks);
   time_delta = new_ticks - last_screen_timestamp;
@@ -930,7 +999,9 @@
   if(!update_backup_flag)
     update_backup_force();
 
+#ifndef NOSOUND
   sound_exit();
+#endif
 
 #ifdef REGISTER_USAGE_ANALYZE
   print_register_usage();
@@ -939,7 +1010,15 @@
 #ifdef PSP_BUILD
   sceKernelExitGame();
 #else
+
+#ifdef IPOD_BUILD
+  ipod_exit_video();
+  ipod_exit_cop();
+  ipod_exit_input();
+  ipod_exit_hw();
+#else
   SDL_Quit();
+#endif
 
 #ifdef GP2X_BUILD
   gp2x_quit();
@@ -954,7 +1033,9 @@
   init_main();
   init_memory();
   init_cpu();
+#ifndef NOSOUND
   reset_sound();
+#endif
 }
 
 #ifdef PSP_BUILD
diff -ur main.h main.h
--- main.h	2007-04-08 21:35:13.000000000 -0400
+++ main.h	2008-05-10 18:16:59.515625000 -0400
@@ -131,6 +131,14 @@
 
 #endif
 
+#ifdef IPOD_BUILD
+
+extern u32 no_alpha;
+
+#endif
+
+#ifndef NOSOUND
+
 #define count_timer(timer_number)                                             \
   timer[timer_number].reload = 0x10000 - value;                               \
   if(timer_number < 2)                                                        \
@@ -195,6 +203,49 @@
   }                                                                           \
   address16(io_registers, 0x102 + (timer_number * 4)) = value;                \
 
+#else
+
+#define count_timer(timer_number)                                             \
+  timer[timer_number].reload = 0x10000 - value;                               \
+
+#define trigger_timer(timer_number)                                           \
+  if(value & 0x80)                                                            \
+  {                                                                           \
+    if(timer[timer_number].status == TIMER_INACTIVE)                          \
+    {                                                                         \
+      u32 prescale = prescale_table[value & 0x03];                            \
+      u32 timer_reload = timer[timer_number].reload;                          \
+                                                                              \
+      if((value >> 2) & 0x01)                                                 \
+        timer[timer_number].status = TIMER_CASCADE;                           \
+      else                                                                    \
+        timer[timer_number].status = TIMER_PRESCALE;                          \
+                                                                              \
+      timer[timer_number].prescale = prescale;                                \
+      timer[timer_number].irq = (value >> 6) & 0x01;                          \
+                                                                              \
+      address16(io_registers, 0x100 + (timer_number * 4)) =                   \
+       -timer_reload;                                                         \
+                                                                              \
+      timer_reload <<= prescale;                                              \
+      timer[timer_number].count = timer_reload;                               \
+                                                                              \
+      if(timer_reload < execute_cycles)                                       \
+        execute_cycles = timer_reload;                                        \
+    }                                                                         \
+  }                                                                           \
+  else                                                                        \
+  {                                                                           \
+    if(timer[timer_number].status != TIMER_INACTIVE)                          \
+    {                                                                         \
+      timer[timer_number].status = TIMER_INACTIVE;                            \
+      timer[timer_number].stop_cpu_ticks = cpu_ticks;                         \
+    }                                                                         \
+  }                                                                           \
+  address16(io_registers, 0x102 + (timer_number * 4)) = value;                \
+
+#endif
+
 void change_ext(u8 *src, u8 *buffer, u8 *extension);
 
 #endif
diff -ur memory.c memory.c
--- memory.c	2007-04-08 21:35:13.000000000 -0400
+++ memory.c	2008-05-10 21:18:21.906250000 -0400
@@ -19,7 +19,15 @@
 
 #include "common.h"
 
+#ifdef PSP_BUILD
+extern u32 file_length(u8 *filename, s32 dummy)
+#else
+extern u32 file_length(u8 *dummy, FILE *fp);
+#endif
+
+#ifndef IPOD_BUILD
 u32 load_file_zip(u8 *filename);
+#endif
 
 // This table is configured for sequential access on system defaults
 
@@ -489,6 +497,8 @@
       break;                                                                  \
   }                                                                           \
 
+#ifndef NOSOUND
+
 #define trigger_dma(dma_number)                                               \
   if(value & 0x8000)                                                          \
   {                                                                           \
@@ -558,6 +568,73 @@
     address16(io_registers, (dma_number * 12) + 0xBA) = value;                \
   }                                                                           \
 
+#else
+
+#define trigger_dma(dma_number)                                               \
+  if(value & 0x8000)                                                          \
+  {                                                                           \
+    if(dma[dma_number].start_type == DMA_INACTIVE)                            \
+    {                                                                         \
+      u32 start_type = (value >> 12) & 0x03;                                  \
+      u32 dest_address = address32(io_registers, (dma_number * 12) + 0xB4) &  \
+       0xFFFFFFF;                                                             \
+                                                                              \
+      dma[dma_number].dma_channel = dma_number;                               \
+      dma[dma_number].source_address =                                        \
+       address32(io_registers, (dma_number * 12) + 0xB0) & 0xFFFFFFF;         \
+      dma[dma_number].dest_address = dest_address;                            \
+      dma[dma_number].source_direction = (value >>  7) & 0x03;                \
+      dma[dma_number].repeat_type = (value >> 9) & 0x01;                      \
+      dma[dma_number].start_type = start_type;                                \
+      dma[dma_number].irq = (value >> 14) & 0x01;                             \
+                                                                              \
+      /* If it is sound FIFO DMA make sure the settings are a certain way */  \
+      if((dma_number >= 1) && (dma_number <= 2) &&                            \
+       (start_type == DMA_START_SPECIAL))                                     \
+      {                                                                       \
+        dma[dma_number].length_type = DMA_32BIT;                              \
+        dma[dma_number].length = 4;                                           \
+        dma[dma_number].dest_direction = DMA_FIXED;                           \
+      }                                                                       \
+      else                                                                    \
+      {                                                                       \
+        u32 length =                                                          \
+         address16(io_registers, (dma_number * 12) + 0xB8);                   \
+                                                                              \
+        if((dma_number == 3) && ((dest_address >> 24) == 0x0D) &&             \
+         ((length & 0x1F) == 17))                                             \
+        {                                                                     \
+          eeprom_size = EEPROM_8_KBYTE;                                       \
+        }                                                                     \
+                                                                              \
+        if(dma_number < 3)                                                    \
+          length &= 0x3FFF;                                                   \
+                                                                              \
+        if(length == 0)                                                       \
+        {                                                                     \
+          if(dma_number == 3)                                                 \
+            length = 0x10000;                                                 \
+          else                                                                \
+            length = 0x04000;                                                 \
+        }                                                                     \
+                                                                              \
+        dma[dma_number].length = length;                                      \
+        dma[dma_number].length_type = (value >> 10) & 0x01;                   \
+        dma[dma_number].dest_direction = (value >> 5) & 0x03;                 \
+      }                                                                       \
+                                                                              \
+      address16(io_registers, (dma_number * 12) + 0xBA) = value;              \
+      if(start_type == DMA_START_IMMEDIATELY)                                 \
+        return dma_transfer(dma + dma_number);                                \
+    }                                                                         \
+  }                                                                           \
+  else                                                                        \
+  {                                                                           \
+    dma[dma_number].start_type = DMA_INACTIVE;                                \
+    address16(io_registers, (dma_number * 12) + 0xBA) = value;                \
+  }                                                                           \
+
+#endif
 
 #define access_register8_high(address)                                        \
   value = (value << 8) | (address8(io_registers, address))                    \
@@ -2158,10 +2235,14 @@
   s32 file_size;
   u8 cheats_filename[256];
 
+#ifdef IPOD_BUILD
+  file_size = load_gamepak_raw(name);
+#else
   if(!strcmp(dot_position, ".zip"))
     file_size = load_file_zip(name);
   else
     file_size = load_gamepak_raw(name);
+#endif
 
   // A dumb April fool's joke was here once :o
 
@@ -3182,11 +3263,13 @@
        convert_palette(current_color);
     }
 
+#ifndef NOSOUND
     // Oops, these contain raw pointers
     for(i = 0; i < 4; i++)
     {
       gbc_sound_channel[i].sample_data = square_pattern_duty[2];
     }
+#endif
     current_debug_state = STEP;
     instruction_count = 0;
 
diff -ur sound.c sound.c
--- sound.c	2007-04-08 21:35:13.000000000 -0400
+++ sound.c	2008-05-10 21:22:46.515625000 -0400
@@ -17,11 +17,18 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-
 #include "common.h"
+#ifdef IPOD_BUILD
+#include <sys/ioctl.h>
+#include <sys/soundcard.h>
+#define SOUND_DEVICE "/dev/dsp"
+void sound_callback(int length);
+#else
 #include <SDL.h>
+#endif
 u32 global_enable_audio = 1;
 
+u32 sound_fd;
 direct_sound_struct direct_sound_channel[2];
 gbc_sound_struct gbc_sound_channel[4];
 
@@ -31,9 +38,11 @@
 u32 sound_frequency = 44100;
 #endif
 
+#ifndef IPOD_BUILD
 SDL_AudioSpec sound_settings;
 SDL_mutex *sound_mutex;
 SDL_cond *sound_cv;
+#endif
 
 #ifndef PSP_BUILD
 u32 audio_buffer_size_number = 7;
@@ -433,11 +442,13 @@
 
 void synchronize_sound()
 {
+#ifndef IPOD_BUILD
   SDL_LockMutex(sound_mutex);
 
   gbc_sound_synchronize();
 
   SDL_UnlockMutex(sound_mutex);
+#endif
 }
 
 void update_gbc_sound(u32 cpu_ticks)
@@ -466,17 +477,21 @@
     gbc_sound_partial_ticks &= 0xFFFF;
   }
 
+#ifndef IPOD_BUILD
   SDL_LockMutex(sound_mutex);
+#endif
   if(synchronize_flag)
   {
     if(((gbc_sound_buffer_index - sound_buffer_base) % BUFFER_SIZE) >
      (audio_buffer_size * 3 / 2))
     {
+#ifndef IPOD_BUILD
       while(((gbc_sound_buffer_index - sound_buffer_base) % BUFFER_SIZE) >
        (audio_buffer_size * 3 / 2))
       {
         SDL_CondWait(sound_cv, sound_mutex);
       }
+#endif
 
 #ifdef PSP_BUILD
       if(current_frameskip_type == auto_frameskip)
@@ -579,15 +594,42 @@
 
   address16(io_registers, 0x84) = sound_status;
 
+#ifndef IPOD_BUILD
   SDL_CondSignal(sound_cv);
 
   SDL_UnlockMutex(sound_mutex);
+#endif
 
   gbc_sound_last_cpu_ticks = cpu_ticks;
+#ifndef IPOD_BUILD
   gbc_sound_buffer_index =
    (gbc_sound_buffer_index + (buffer_ticks * 2)) % BUFFER_SIZE;
+#else
+  gbc_sound_buffer_index =
+   (gbc_sound_buffer_index + (buffer_ticks << 1)) % BUFFER_SIZE;
+  if (((gbc_sound_buffer_index - sound_buffer_base) % BUFFER_SIZE) > (audio_buffer_size>>2))
+    sound_callback(audio_buffer_size>>2);
+#endif
 }
 
+#ifdef IPOD_BUILD
+
+#define sound_copy_normal()                                                   \
+  current_sample = source[i]                                                  \
+
+#define sound_copy(source_offset, length, render_type)                        \
+  _length = (length) / 2;                                                     \
+  source = (s16 *)(sound_buffer + source_offset);                             \
+  write(sound_fd, source,_length);					                          \
+  memset(source,0,_length);
+
+#define sound_copy_null(source_offset, length)                                \
+  _length = (length) / 2;                                                     \
+  source = (s16 *)(sound_buffer + source_offset);                             \
+  memset(source,0,_length);
+  
+#else
+
 #define sound_copy_normal()                                                   \
   current_sample = source[i]                                                  \
 
@@ -615,16 +657,25 @@
     source[i] = 0;                                                            \
   }                                                                           \
 
+#endif
+  
 
+#ifdef IPOD_BUILD
+void sound_callback(int length)
+#else
 void sound_callback(void *userdata, Uint8 *stream, int length)
+#endif
 {
   u32 sample_length = length / 2;
   u32 _length;
   u32 i;
+#ifndef IPOD_BUILD
   s16 *stream_base = (s16 *)stream;
+#endif
   s16 *source;
   s32 current_sample;
 
+#ifndef IPOD_BUILD
   SDL_LockMutex(sound_mutex);
 
   while(((gbc_sound_buffer_index - sound_buffer_base) % BUFFER_SIZE) <
@@ -632,6 +683,7 @@
   {
     SDL_CondWait(sound_cv, sound_mutex);
   }
+#endif
 
   if(global_enable_audio)
   {
@@ -666,9 +718,11 @@
     }
   }
 
+#ifndef IPOD_BUILD
   SDL_CondSignal(sound_cv);
 
   SDL_UnlockMutex(sound_mutex);
+#endif
 }
 
 // Special thanks to blarrg for the LSFR frequency used in Meridian, as posted
@@ -747,14 +801,18 @@
 {
   gbc_sound_buffer_index =
    (sound_buffer_base + audio_buffer_size) % BUFFER_SIZE;
+#ifndef IPOD_BUILD
   SDL_PauseAudio(1);
   SDL_CondSignal(sound_cv);
+#endif
 }
 
 void init_sound()
 {
 #ifdef PSP_BUILD
   audio_buffer_size = (audio_buffer_size_number * 1024) + 3072;
+#elif defined(IPOD_BUILD)
+  audio_buffer_size = 16384;
 #elif defined(TAVI_BUILD) || defined(ARM_ARCH)
   audio_buffer_size = 16 << audio_buffer_size_number;
 //  audio_buffer_size = 16384;
@@ -762,6 +820,43 @@
   audio_buffer_size = 16384;
 #endif
 
+#ifdef IPOD_BUILD
+    u32 mixer;
+    mixer = open("/dev/mixer", O_RDWR); 
+    u32 volume = 100; 
+    u32 vol = volume << 8 | volume;
+    int ret = ioctl(mixer, SOUND_MIXER_WRITE_PCM, &vol);
+    sound_fd = open(SOUND_DEVICE, O_WRONLY);
+    if (sound_fd < 0) {
+      perror("failed");
+      sound_fd = 0;
+      return;
+    } else {
+      printf("done.\n");
+    }
+    u32 tmp = 2;
+    u32 result = ioctl(sound_fd, SNDCTL_DSP_CHANNELS, &tmp);
+    if (result < 0) {
+      perror("failed");
+      close(sound_fd);
+      sound_fd = 0;
+      return;
+    } else {
+      printf("done.\n");
+    }
+    printf("setting sound rate to %dHz...", sound_frequency);
+    result = ioctl(sound_fd, SNDCTL_DSP_SPEED, &sound_frequency);
+    if (result < 0) {
+      perror("failed");
+      close(sound_fd);
+      sound_fd = 0;
+      return;
+    } else {
+      printf("got %dHz...done.\n", sound_frequency);
+    }
+#endif
+
+#ifndef IPOD_BUILD
   SDL_AudioSpec desired_spec =
   {
     sound_frequency,
@@ -774,6 +869,7 @@
     sound_callback,
     NULL
   };
+#endif
 
   gbc_sound_tick_step =
    float_to_fp16_16(256.0 / sound_frequency);
@@ -783,11 +879,13 @@
 
   reset_sound();
 
+#ifndef IPOD_BUILD
   SDL_OpenAudio(&desired_spec, &sound_settings);
   sound_frequency = sound_settings.freq;
   sound_mutex = SDL_CreateMutex();
   sound_cv = SDL_CreateCond();
   SDL_PauseAudio(0);
+#endif
 }
 
 #define sound_savestate_builder(type)                                       \
@@ -809,4 +907,3 @@
 
 sound_savestate_builder(read);
 sound_savestate_builder(write_mem);
-
diff -ur sound.h sound.h
--- sound.h	2007-04-08 21:35:13.000000000 -0400
+++ sound.h	2008-05-10 14:00:02.671875000 -0400
@@ -117,8 +117,10 @@
 extern u32 enable_low_pass_filter;
 extern u32 audio_buffer_size_number;
 
+#ifndef IPOD_BUILD
 extern SDL_mutex *sound_mutex;
 extern SDL_cond *sound_cv;
+#endif
 
 void sound_timer_queue8(u32 channel, u8 value);
 void sound_timer_queue16(u32 channel, u16 value);
diff -ur video.c video.c
--- video.c	2007-04-08 21:35:13.000000000 -0400
+++ video.c	2008-05-21 20:00:59.656250000 -0400
@@ -91,6 +91,24 @@
 #include "SDL_gp2x.h"
 SDL_Surface *hw_screen;
 #endif
+
+#ifdef IPOD_BUILD
+#include "ipod/ipod_common.h"
+#include "hotdog.h"
+
+extern uint32 IPOD_WIDTH, IPOD_HEIGHT;
+u16 *screen;
+uint32 WIDTH, HEIGHT;
+const u32 video_scale = 0;
+
+#define get_screen_pixels()                                                   \
+  ((u16 *)screen)                                                             \
+
+#define get_screen_pitch()                                                    \
+  (240)                                                                       \
+
+#else
+
 SDL_Surface *screen;
 const u32 video_scale = 1;
 
@@ -102,6 +120,8 @@
 
 #endif
 
+#endif
+
 void render_scanline_conditional_tile(u32 start, u32 end, u16 *scanline,
  u32 enable_flags, u32 dispcnt, u32 bldcnt, tile_layer_render_struct
  *layer_renderers);
@@ -657,7 +677,7 @@
 #define get_tile_4bpp()                                                       \
   current_tile = *map_ptr;                                                    \
   current_palette = (current_tile >> 12) << 4;                                \
-  tile_ptr = tile_base + ((current_tile & 0x3FF) * 32);                       \
+  tile_ptr = tile_base + ((current_tile & 0x3FF) << 5);                       \
 
 
 // Helper macro for drawing clipped 4bpp tiles.
@@ -860,7 +880,7 @@
   u32 pixel_run = 256 - (horizontal_offset % 256);                            \
   u32 current_tile;                                                           \
                                                                               \
-  map_base += ((vertical_offset % 256) / 8) * 32;                             \
+  map_base += ((vertical_offset % 256) / 8) << 5;                             \
   partial_tile_offset = (horizontal_offset % 8);                              \
                                                                               \
   if(pixel_run >= end)                                                        \
@@ -1022,12 +1042,12 @@
                                                                               \
   if((map_size & 0x02) && (vertical_offset >= 256))                           \
   {                                                                           \
-    map_base += ((map_width / 8) * 32) +                                      \
-     (((vertical_offset - 256) / 8) * 32);                                    \
+    map_base += ((map_width / 8) << 5) +                                      \
+     (((vertical_offset - 256) / 8) << 5);                                    \
   }                                                                           \
   else                                                                        \
   {                                                                           \
-    map_base += (((vertical_offset % 256) / 8) * 32);                         \
+    map_base += (((vertical_offset % 256) / 8) << 5);                         \
   }                                                                           \
                                                                               \
   if(map_size & 0x01)                                                         \
@@ -1568,7 +1588,7 @@
 // Get the current row offset into an obj in 1D map space
 
 #define obj_tile_offset_1D(color_depth, flip_op)                              \
-  tile_ptr = tile_base + ((obj_attribute_2 & 0x3FF) * 32)                     \
+  tile_ptr = tile_base + ((obj_attribute_2 & 0x3FF) << 5)                     \
    + ((vertical_offset / 8) * (obj_width / 8) * tile_size_##color_depth)      \
    + ((vertical_offset % 8) * tile_width_##color_depth)                       \
    obj_tile_offset_##flip_op(color_depth)                                     \
@@ -1576,7 +1596,7 @@
 // Get the current row offset into an obj in 2D map space
 
 #define obj_tile_offset_2D(color_depth, flip_op)                              \
-  tile_ptr = tile_base + ((obj_attribute_2 & 0x3FF) * 32)                     \
+  tile_ptr = tile_base + ((obj_attribute_2 & 0x3FF) << 5)                     \
    + ((vertical_offset / 8) * 1024)                                           \
    + ((vertical_offset % 8) * tile_width_##color_depth)                       \
    obj_tile_offset_##flip_op(color_depth)                                     \
@@ -1681,14 +1701,14 @@
 }                                                                             \
 
 #define obj_scale_offset_1D(color_depth)                                      \
-  tile_ptr = tile_base + ((obj_attribute_2 & 0x3FF) * 32)                     \
+  tile_ptr = tile_base + ((obj_attribute_2 & 0x3FF) << 5)                     \
    + ((vertical_offset / 8) * (max_x / 8) * tile_size_##color_depth)          \
    + ((vertical_offset % 8) * tile_width_##color_depth)                       \
 
 // Get the current row offset into an obj in 2D map space
 
 #define obj_scale_offset_2D(color_depth)                                      \
-  tile_ptr = tile_base + ((obj_attribute_2 & 0x3FF) * 32)                     \
+  tile_ptr = tile_base + ((obj_attribute_2 & 0x3FF) << 5)                     \
    + ((vertical_offset / 8) * 1024)                                           \
    + ((vertical_offset % 8) * tile_width_##color_depth)                       \
 
@@ -1776,7 +1796,7 @@
 
 #define obj_render_rotate(combine_op, color_depth, alpha_op, map_space)       \
 {                                                                             \
-  tile_ptr = tile_base + ((obj_attribute_2 & 0x3FF) * 32);                    \
+  tile_ptr = tile_base + ((obj_attribute_2 & 0x3FF) << 5);                    \
   obj_rotate_offset_##map_space(color_depth);                                 \
                                                                               \
   source_x += (y_delta * dmx) - (middle_x * dx);                              \
@@ -1834,8 +1854,8 @@
   u32 obj_pitch = tile_width_##color_depth;                                   \
   u32 obj_tile_pitch;                                                         \
                                                                               \
-  middle_x = (obj_width / 2);                                                 \
-  middle_y = (obj_height / 2);                                                \
+  middle_x = (obj_width >> 1);                                                 \
+  middle_y = (obj_height >> 1);                                                \
                                                                               \
   source_x = (middle_x << 8);                                                 \
   source_y = (middle_y << 8);                                                 \
@@ -3356,6 +3376,12 @@
     current_scanline_ptr += pitch;                                            \
   }                                                                           \
 
+#ifdef IPOD_BUILD
+void flip_screen()
+{
+  ipod_cop_update_screen();
+}
+#else
 void flip_screen()
 {
   if((video_scale != 1) && (current_scale != unscaled))
@@ -3414,6 +3440,7 @@
   SDL_Flip(screen);
 #endif
 }
+#endif
 
 #endif
 
@@ -3516,6 +3543,12 @@
 
 void init_video()
 {
+#ifdef IPOD_BUILD
+  WIDTH = 240;
+  HEIGHT = 160;
+  screen = malloc(WIDTH * HEIGHT * 2);
+  ipod_init_video();
+#else
   SDL_Init(SDL_INIT_VIDEO | SDL_INIT_JOYSTICK | SDL_INIT_NOPARACHUTE);
 
 #ifdef GP2X_BUILD
@@ -3532,6 +3565,7 @@
   screen = SDL_SetVideoMode(240 * video_scale, 160 * video_scale, 16, 0);
 #endif
   SDL_ShowCursor(0);
+#endif
 }
 
 #endif
@@ -3657,6 +3691,9 @@
   SDL_ShowCursor(0);
 
   gp2x_load_mmuhack();
+#elif defined(IPOD_BUILD)
+  resolution_width = IPOD_WIDTH;
+  resolution_height = IPOD_HEIGHT;
 #else
   screen = SDL_SetVideoMode(480, 272, 16, 0);
   resolution_width = 480;
@@ -3666,6 +3703,11 @@
 
 void video_resolution_small()
 {
+#ifdef IPOD_BUILD
+  current_scale = unscaled;
+  resolution_width = IPOD_WIDTH;
+  resolution_height = IPOD_HEIGHT;
+#else
   current_scale = screen_scale;
 
 #ifdef GP2X_BUILD
@@ -3688,6 +3730,7 @@
 #endif
   resolution_width = small_resolution_width;
   resolution_height = small_resolution_height;
+#endif
 }
 
 void set_gba_resolution(video_scale_type scale)
@@ -3709,6 +3752,9 @@
 
 void clear_screen(u16 color)
 {
+#ifdef IPOD_BUILD
+  ipod_clear_screen(color);
+#else
   u16 *dest_ptr = get_screen_pixels();
   u32 line_skip = get_screen_pitch() - screen->w;
   u32 x, y;
@@ -3721,19 +3767,27 @@
     }
     dest_ptr += line_skip;
   }
+#endif
 }
 
 #endif
 
 u16 *copy_screen()
 {
+#ifdef IPOD_BUILD
+  u16 *copy;
+  ipod_cop_operation(copy = malloc(240 * 160 * 2));
+  ipod_cop_operation(memcpy(copy, get_screen_pixels(), 240 * 160 * 2));
+#else
   u16 *copy = malloc(240 * 160 * 2);
   memcpy(copy, get_screen_pixels(), 240 * 160 * 2);
+#endif  
   return copy;
 }
 
 void blit_to_screen(u16 *src, u32 w, u32 h, u32 dest_x, u32 dest_y)
 {
+#ifndef IPOD_BUILD
   u32 pitch = get_screen_pitch();
   u16 *dest_ptr = get_screen_pixels() + dest_x + (dest_y * pitch);
 
@@ -3749,6 +3803,7 @@
     }
     dest_ptr += line_skip;
   }
+#endif
 }
 
 void print_string_ext(const char *str, u16 fg_color, u16 bg_color,
