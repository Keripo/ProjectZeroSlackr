diff -ur common.h common.h
--- common.h	2007-04-08 21:35:13.000000000 -0400
+++ common.h	2008-05-10 14:00:02.593750000 -0400
@@ -32,6 +32,7 @@
   #include <stdlib.h>
   #include <stdio.h>
   #include <string.h>
+  #include <strings.h>
   #include <math.h>
   #include <fcntl.h>
   #include <unistd.h>
@@ -102,7 +103,9 @@
   #include <time.h>
   #include <stdio.h>
 #else
+#ifndef IPOD_BUILD
   #include "SDL.h"
+#endif
 
 #ifdef ARM_ARCH
   #define function_cc
@@ -237,7 +240,9 @@
 #include <stdlib.h>
 #include <string.h>
 #include <stdarg.h>
+#ifndef IPOD_BUILD
 #include "SDL.h"
+#endif
 #include "cpu.h"
 #include "memory.h"
 #include "video.h"
diff -ur cpu.c cpu.c
--- cpu.c	2007-04-08 21:35:13.000000000 -0400
+++ cpu.c	2008-05-10 14:00:48.328125000 -0400
@@ -1143,10 +1143,10 @@
   address32(address_region, (address + offset) & 0x7FFF) = dest               \
 
 #define arm_block_memory_offset_down_a()                                      \
-  (base - (word_bit_count(reg_list) * 4) + 4)                                 \
+  (base - (word_bit_count(reg_list) << 2) + 4)                                 \
 
 #define arm_block_memory_offset_down_b()                                      \
-  (base - (word_bit_count(reg_list) * 4))                                     \
+  (base - (word_bit_count(reg_list) << 2))                                     \
 
 #define arm_block_memory_offset_no()                                          \
   (base)                                                                      \
@@ -1155,10 +1155,10 @@
   (base + 4)                                                                  \
 
 #define arm_block_memory_writeback_down()                                     \
-  reg[rn] = base - (word_bit_count(reg_list) * 4)                             \
+  reg[rn] = base - (word_bit_count(reg_list) << 2)                             \
 
 #define arm_block_memory_writeback_up()                                       \
-  reg[rn] = base + (word_bit_count(reg_list) * 4)                             \
+  reg[rn] = base + (word_bit_count(reg_list) << 2)                             \
 
 #define arm_block_memory_writeback_no()                                       \
 
@@ -1456,13 +1456,13 @@
 #define thumb_block_address_preadjust_no_op()                                 \
 
 #define thumb_block_address_preadjust_up()                                    \
-  address += bit_count[reg_list] * 4                                          \
+  address += bit_count[reg_list] << 2                                          \
 
 #define thumb_block_address_preadjust_down()                                  \
-  address -= bit_count[reg_list] * 4                                          \
+  address -= bit_count[reg_list] << 2                                          \
 
 #define thumb_block_address_preadjust_push_lr()                               \
-  address -= (bit_count[reg_list] + 1) * 4                                    \
+  address -= (bit_count[reg_list] + 1) << 2                                    \
 
 #define thumb_block_address_postadjust_no_op()                                \
 
@@ -4142,8 +4142,10 @@
   {
     u32 key = 0;
 
+#ifndef IPOD_BUILD
     SDL_LockMutex(sound_mutex);
     SDL_PauseAudio(1);
+#endif
 
     if(output_field >= num_output_fields)
     {
@@ -4277,8 +4279,10 @@
         quit();
     }
 
+#ifndef IPOD_BUILD
     SDL_PauseAudio(0);
     SDL_UnlockMutex(sound_mutex);
+#endif
   }
 
   last_instruction = reg[REG_PC];
diff -ur cpu_threaded.c cpu_threaded.c
--- cpu_threaded.c	2007-04-08 21:35:13.000000000 -0400
+++ cpu_threaded.c	2008-05-10 14:00:02.625000000 -0400
@@ -198,6 +198,10 @@
 
 #include "giz/arm_emit.h"
 
+#elif defined(IPOD_BUILD)
+
+#include "gp2x/arm_emit.h"
+
 #else
 
 #include "x86/x86_emit.h"
diff -ur font.h font.h
--- font.h	2007-04-08 21:35:13.000000000 -0400
+++ font.h	2008-05-10 14:00:02.625000000 -0400
@@ -20,8 +20,13 @@
 /* Generated by convbdf on Fri Aug 18 17:44:10 2006. */
 /* Slightly modified by Exophase. Big thanks to ajs for converting this! */
 
+#ifdef IPOD_BUILD
+#define FONT_WIDTH  6
+#define FONT_HEIGHT 11
+#else
 #define FONT_WIDTH  6
 #define FONT_HEIGHT 10
+#endif
 
 /* Font information:
    name: 6x10
diff -ur gui.c gui.c
--- gui.c	2007-04-08 21:35:13.000000000 -0400
+++ gui.c	2008-05-10 18:18:28.234375000 -0400
@@ -38,6 +38,12 @@
 #define FILE_LIST_POSITION 5
 #define DIR_LIST_POSITION 260
 
+#elif defined(IPOD_BUILD)
+
+#define FILE_LIST_ROWS 10
+#define FILE_LIST_POSITION 5
+#define DIR_LIST_POSITION 80
+
 #else
 
 #define FILE_LIST_ROWS 25
@@ -58,7 +64,7 @@
 
 #endif
 
-#ifdef GP2X_BUILD
+#if defined(GP2X_BUILD) || defined(IPOD_BUILD)
 
 #define COLOR_BG            color16(0, 0, 0)
 
@@ -74,6 +80,8 @@
 #define COLOR_FRAMESKIP_BAR color16(15, 31, 31)
 #define COLOR_HELP_TEXT     color16(16, 40, 24)
 
+extern u32 file_length(u8 *dummy, FILE *fp);
+
 int sort_function(const void *dest_str_ptr, const void *src_str_ptr)
 {
   char *dest_str = *((char **)dest_str_ptr);
@@ -640,7 +648,7 @@
 
 #endif
 
-#ifdef GP2X_BUILD
+#if defined(GP2X_BUILD) || defined(IPOD_BUILD)
 
 u32 gamepad_config_line_to_button[] =
  { 0, 2, 1, 3, 8, 9, 10, 11, 6, 7, 4, 5 };
@@ -699,7 +707,7 @@
     return 0;
 
   current_frameskip_type = auto_frameskip;
-  frameskip_value = 4;
+  frameskip_value = 6;
   random_skip = 0;
   clock_speed = 333;
 
@@ -1008,7 +1016,11 @@
 
   void menu_load()
   {
+#ifdef IPOD_BUILD
+    u8 *file_ext[] = { ".gba", ".bin", NULL };
+#else
     u8 *file_ext[] = { ".gba", ".bin", ".zip", NULL };
+#endif
     u8 load_filename[512];
     save_game_config_file();
     if(load_file(file_ext, load_filename) != -1)
@@ -1191,6 +1203,27 @@
   };
 
   // Marker for help information, don't go past this mark (except \n)------*
+#ifdef IPOD_BUILD
+u8 *alpha_blending_options[] = { "On", "Off" };
+menu_option_type graphics_sound_options[] =
+  {
+    string_selection_option(NULL, "Alpha Blending",
+     alpha_blending_options, &no_alpha, 2, "", 0),
+    string_selection_option(NULL, "Frameskip type", frameskip_options,
+     (u32 *)(&current_frameskip_type), 3, "", 1),
+    numeric_selection_option(NULL, "Frameskip value", &frameskip_value,
+	 100, "", 2),
+    string_selection_option(NULL, "Framskip variation",
+     frameskip_variation_options, &random_skip, 2, "", 3)
+#ifndef NOSOUND
+	 ,
+    string_selection_option(NULL, "Audio output", yes_no_options,
+     &global_enable_audio, 2, "", 4),
+    string_selection_option(NULL, "Audio buffer", audio_buffer_options,
+             &audio_buffer_size_number, 10, "", 5)
+#endif
+  };
+#else
   menu_option_type graphics_sound_options[] =
   {
     string_selection_option(NULL, "Display scaling", scale_options,
@@ -1242,9 +1275,25 @@
      10),
     submenu_option(NULL, "Back", "Return to the main menu.", 12)
   };
+#endif
 
   make_menu(graphics_sound, submenu_graphics_sound, NULL);
 
+#ifdef IPOD_BUILD
+// Only displays up to 8 menu items for some reason
+  menu_option_type cheats_misc_options[] =
+  {
+    cheat_option(0),
+    cheat_option(1),
+    cheat_option(2),
+    cheat_option(3),
+    cheat_option(4),
+    cheat_option(5),
+    cheat_option(6),
+    cheat_option(7),
+    cheat_option(8)
+  };
+#else
   menu_option_type cheats_misc_options[] =
   {
     cheat_option(0),
@@ -1270,9 +1319,26 @@
      "Use the latter with extreme care.", 12),
     submenu_option(NULL, "Back", "Return to the main menu.", 14)
   };
+#endif
 
   make_menu(cheats_misc, submenu_cheats_misc, NULL);
 
+#ifdef IPOD_BUILD
+  menu_option_type savestate_options[] =
+  {
+    numeric_selection_action_hide_option(menu_load_state, menu_change_state,
+     "Load savestate from current slot", &savestate_slot, 10, "", 0),
+    numeric_selection_action_hide_option(menu_save_state, menu_change_state,
+     "Save savestate to current slot", &savestate_slot, 10, "", 1),
+    numeric_selection_action_hide_option(menu_load_state_file,
+      menu_change_state,
+     "Load savestate from file", &savestate_slot, 10, "", 2),
+    numeric_selection_option(menu_change_state,
+     "Current savestate slot", &savestate_slot, 10, "", 3),
+	string_selection_option(NULL, "Update backup",
+     update_backup_options, &update_backup_flag, 2, "", 4)
+  };
+#else
   menu_option_type savestate_options[] =
   {
     numeric_selection_action_hide_option(menu_load_state, menu_change_state,
@@ -1293,6 +1359,7 @@
      "Change the current savestate slot.\n", 11),
     submenu_option(NULL, "Back", "Return to the main menu.", 13)
   };
+#endif
 
   make_menu(savestate, submenu_savestate, NULL);
 
@@ -1375,9 +1442,27 @@
 
 #endif
 
+#ifndef IPOD_BUILD
   make_menu(gamepad_config, submenu_gamepad, NULL);
   make_menu(analog_config, submenu_analog, NULL);
+#endif
 
+#ifdef IPOD_BUILD
+  menu_option_type main_options[] =
+  {
+    submenu_option(&graphics_sound_menu, "Graphics and Sound", "", 0),
+    numeric_selection_action_option(menu_load_state, NULL,
+     "Load state from slot", &savestate_slot, 10, "", 1),
+    numeric_selection_action_option(menu_save_state, NULL,
+     "Save state to slot", &savestate_slot, 10, "", 2),
+    submenu_option(&savestate_menu, "Savestate options", "", 3),
+    submenu_option(&cheats_misc_menu, "Enable Cheats", "", 4),
+    action_option(menu_load, NULL, "Load new game", "", 5),
+    action_option(menu_restart, NULL, "Restart game", "", 6),
+    action_option(menu_exit, NULL, "Return to game", "", 7),
+    action_option(menu_quit, NULL, "Exit igpSP", "", 8)
+  };
+#else
   menu_option_type main_options[] =
   {
     submenu_option(&graphics_sound_menu, "Graphics and Sound options",
@@ -1415,13 +1500,16 @@
     action_option(menu_quit, NULL, "Exit gpSP",
      "Select to exit gpSP and return to the PSP XMB/loader.", 15)
   };
+#endif
 
   make_menu(main, submenu_main, NULL);
 
   void choose_menu(menu_type *new_menu)
   {
+#ifndef IPOD_BUILD
     if(new_menu == NULL)
       new_menu = &main_menu;
+#endif
 
     clear_screen(COLOR_BG);
 
@@ -1446,6 +1534,7 @@
 
   video_resolution_large();
 
+#ifndef IPOD_BUILD
 #ifndef GP2X_BUILD
   SDL_LockMutex(sound_mutex);
 #endif
@@ -1454,6 +1543,7 @@
 #ifndef GP2X_BUILD
   SDL_UnlockMutex(sound_mutex);
 #endif
+#endif
 
   if(gamepak_filename[0] == 0)
   {
@@ -1599,7 +1689,9 @@
     scePowerSetClockFrequency(clock_speed, clock_speed, clock_speed / 2);
   #endif
 
+#ifndef IPOD_BUILD
   SDL_PauseAudio(0);
+#endif
 
   return return_value;
 }
diff -ur input.c input.c
--- input.c	2007-04-08 21:35:13.000000000 -0400
+++ input.c	2008-05-10 14:02:26.437500000 -0400
@@ -629,6 +629,258 @@
 #endif
 
 
+#ifdef IPOD_BUILD
+
+#include "ipod/cop.h"
+#include <sys/ioctl.h>
+#include <fcntl.h>
+#include <termios.h>
+#include <linux/kd.h>
+
+static int consoleFd = -1;
+static struct termios old;
+
+#define KEYCODE(a) (a & 0x7f)
+
+#define KH_KEY_MENU    50
+#define KH_KEY_REWIND  17
+#define KH_KEY_PLAY    32
+#define KH_KEY_FORWARD 33
+
+#define KH_KEY_ACTION  28
+#define KH_KEY_HOLD    35
+
+#define KH_WHEEL_L     38
+#define KH_WHEEL_R     19
+
+ 
+u32 gamepad_config_map[16] =
+{
+  BUTTON_ID_MENU,
+  BUTTON_ID_A,
+  BUTTON_ID_B,
+  BUTTON_ID_START,
+  BUTTON_ID_L,
+  BUTTON_ID_R,
+  BUTTON_ID_DOWN,
+  BUTTON_ID_LEFT,
+  BUTTON_ID_UP,
+  BUTTON_ID_RIGHT,
+  BUTTON_ID_SELECT,
+  BUTTON_ID_START,
+  BUTTON_ID_UP,
+  BUTTON_ID_DOWN,
+  BUTTON_ID_LEFT,
+  BUTTON_ID_RIGHT
+};
+
+int inputstarted = 1;
+u32 mappedbuttons = 0;
+
+int START_INPUT(void)
+{
+  struct termios new;
+  if ((consoleFd = open("/dev/console",O_RDONLY | O_NONBLOCK)) < 0)
+    fprintf(stderr, "Could not open /dev/console");
+  
+  if (tcgetattr(consoleFd, &old) < 0)
+    fprintf(stderr, "Could not save old termios");
+  
+  new = old;
+  new.c_lflag    &= ~(ICANON | ECHO  | ISIG);
+  new.c_iflag    &= ~(ISTRIP | IGNCR | ICRNL | INLCR | IXOFF | IXON | BRKINT);
+  new.c_cc[VMIN]  = 0;
+  new.c_cc[VTIME] = 0;
+  
+  if (tcsetattr(consoleFd, TCSAFLUSH, &new) < 0)
+    exit(0);
+  
+  if (ioctl(consoleFd, KDSKBMODE, K_MEDIUMRAW) < 0)
+    exit(0);
+  
+  return 0;
+}
+
+void STOP_INPUT(void)
+{
+  if (tcsetattr(consoleFd, TCSAFLUSH, &old) < 0)
+    fprintf(stderr, "Could not reset old termios");
+  
+  if (consoleFd > 2)
+    if (close(consoleFd) < 0)
+      fprintf(stderr, "Could not close console");
+}
+
+int GET_KEY(void)
+{
+  int c = 0;
+  
+  if (read(consoleFd, &c, 1) != 1)
+    c = -1;
+  
+  return c;
+}
+
+u32 update_input()
+{
+  if (inputstarted) { START_INPUT();  inputstarted=0; }
+  u32 mapped_buttons = BUTTON_NONE;
+  u32 k,in,st,key;
+  unsigned char touch,button;
+  in = inl(0x7000C140);
+  st = (in & 0xff000000) >> 24;
+  if(st == 0xc0) // touched
+  {
+    touch = (in & 0x007F0000 ) >> 16;
+    touch += 6;
+    touch /= 12;
+    if(touch > 7)
+	  touch = 0;
+    k = touch;
+    switch(k)
+    {
+    case 0:
+      mapped_buttons |= BUTTON_UP;
+      break;
+    case 1:
+      mapped_buttons |= BUTTON_A;
+      break;
+    case 2:
+      mapped_buttons |= BUTTON_RIGHT;
+      break;
+    case 3:
+      mapped_buttons |= BUTTON_START;
+      break;
+    case 4:
+      mapped_buttons |= BUTTON_DOWN;
+      break;
+    case 5:
+      mapped_buttons |= BUTTON_SELECT;
+      break;
+    case 6:
+      mapped_buttons |= BUTTON_LEFT;
+      break;
+    case 7:
+      mapped_buttons |= BUTTON_B;
+      break;
+    }
+  }
+  k = GET_KEY();
+  while (k != -1)
+  {
+    int up = k & 0x80;
+    int lk;
+    k = KEYCODE(k);
+    if (up == 0) { 
+      u16 *screen_copy;
+      switch (k)
+      {
+      case KH_KEY_MENU: 
+        mappedbuttons |= BUTTON_UP;
+        mappedbuttons |= BUTTON_B;
+        break;
+      case KH_KEY_REWIND:
+        mappedbuttons |= BUTTON_L;
+        break;
+      case KH_KEY_ACTION:
+        mappedbuttons |= BUTTON_A;
+        break;
+      case KH_KEY_FORWARD:
+        mappedbuttons |= BUTTON_R;
+        break;
+      case KH_KEY_PLAY:
+        mappedbuttons |= BUTTON_DOWN;
+        mappedbuttons |= BUTTON_B;
+        break;
+      case KH_KEY_HOLD:
+        screen_copy = copy_screen();
+        u32 ret_val = menu(screen_copy);
+        free(screen_copy);
+        break;
+      }  
+    }
+    else
+    {
+      switch (k)
+      {
+      case KH_KEY_MENU: 
+        mappedbuttons &=~BUTTON_UP;
+        mappedbuttons &=~BUTTON_B;
+        break;
+      case KH_KEY_REWIND:
+        mappedbuttons &=~BUTTON_L;
+        break;
+      case KH_KEY_ACTION:
+        mappedbuttons &=~BUTTON_A;
+        break;
+      case KH_KEY_FORWARD:
+        mappedbuttons &=~BUTTON_R;
+        break;
+      case KH_KEY_PLAY:
+        mappedbuttons &=~BUTTON_DOWN;
+        mappedbuttons &=~BUTTON_B;
+        break;
+      case KH_KEY_HOLD:
+        break;
+      }
+    }
+    k = GET_KEY();
+  }
+  key = mapped_buttons;
+  key |= mappedbuttons;
+  trigger_key(key);
+  io_registers[REG_P1] = (~key) & 0x3FF;
+  return 0;
+};
+
+void init_input() {
+
+};
+
+gui_action_type get_gui_input()
+{
+  if (inputstarted)
+  {
+    START_INPUT();
+    inputstarted = 0;
+  }
+  gui_action_type gui_action = CURSOR_NONE;
+  int k = GET_KEY();
+  if (k != -1)
+  {
+    int up = k & 0x80;
+    int lk;
+    k = KEYCODE(k);
+    if (up == 0) { 
+      switch (k)
+      {
+      case KH_KEY_MENU: 
+        gui_action = CURSOR_UP;
+        break;
+      case KH_KEY_REWIND:
+        gui_action = CURSOR_LEFT;
+        break;
+      case KH_KEY_ACTION:
+        gui_action = CURSOR_SELECT;
+        break;
+      case KH_KEY_FORWARD:
+        gui_action = CURSOR_RIGHT;
+        break;
+      case KH_KEY_PLAY:
+        gui_action = CURSOR_DOWN;
+        break;
+      case KH_KEY_HOLD:
+        gui_action = CURSOR_EXIT;
+        break;
+      }
+    }
+    k = GET_KEY(); 
+  }
+  return gui_action;
+}
+
+#endif
+
 
 #ifdef PC_BUILD
 
Only in gpsp_src_ipod: ipod
diff -ur main.c main.c
--- main.c	2007-04-08 21:35:13.000000000 -0400
+++ main.c	2008-05-10 18:24:51.093750000 -0400
@@ -50,6 +50,17 @@
 u32 gp2x_fps_debug = 0;
 
 void gp2x_quit(void);
+
+#elif defined(IPOD_BUILD)
+
+#include "ipod/cop.h"
+
+extern void HD_LCD_Quit();
+
+u32 frameskip_value = 6;
+u64 frame_count_initial_timestamp = 0;
+u64 last_frame_interval_timestamp;
+
 #else
 
 u32 frameskip_value = 4;
@@ -97,6 +108,8 @@
   if(timer[timer_number].status == TIMER_PRESCALE)                            \
     check_count(timer[timer_number].count);                                   \
 
+#ifndef NOSOUND
+
 #define update_timer(timer_number)                                            \
   if(timer[timer_number].status != TIMER_INACTIVE)                            \
   {                                                                           \
@@ -134,7 +147,43 @@
     }                                                                         \
   }                                                                           \
 
+#else
+
+#define update_timer(timer_number)                                            \
+  if(timer[timer_number].status != TIMER_INACTIVE)                            \
+  {                                                                           \
+    if(timer[timer_number].status != TIMER_CASCADE)                           \
+    {                                                                         \
+      timer[timer_number].count -= execute_cycles;                            \
+      io_registers[REG_TM##timer_number##D] =                                 \
+       -(timer[timer_number].count >> timer[timer_number].prescale);          \
+    }                                                                         \
+                                                                              \
+    if(timer[timer_number].count <= 0)                                        \
+    {                                                                         \
+      if(timer[timer_number].irq == TIMER_TRIGGER_IRQ)                        \
+        irq_raised |= IRQ_TIMER##timer_number;                                \
+                                                                              \
+      if((timer_number != 3) &&                                               \
+       (timer[timer_number + 1].status == TIMER_CASCADE))                     \
+      {                                                                       \
+        timer[timer_number + 1].count--;                                      \
+        io_registers[REG_TM0D + (timer_number + 1) * 2] =                     \
+         -(timer[timer_number + 1].count);                                    \
+      }                                                                       \
+                                                                              \
+      timer[timer_number].count +=                                            \
+       (timer[timer_number].reload << timer[timer_number].prescale);          \
+    }                                                                         \
+  }                                                                           \
+
+#endif
+
+#ifdef IPOD_BUILD
+u8 *file_ext[] = { ".gba", ".bin", NULL };
+#else
 u8 *file_ext[] = { ".gba", ".bin", ".zip", NULL };
+#endif
 
 #ifdef ARM_ARCH
 void ChangeWorkingDirectory(char *exe)
@@ -159,7 +208,9 @@
   for(i = 0; i < 4; i++)
   {
     dma[i].start_type = DMA_INACTIVE;
+#ifndef NOSOUND
     dma[i].direct_sound_channel = DMA_NO_DIRECT_SOUND;
+#endif
     timer[i].status = TIMER_INACTIVE;
     timer[i].reload = 0x10000;
     timer[i].stop_cpu_ticks = 0;
@@ -288,7 +339,9 @@
   }
 
   init_main();
+#ifndef NOSOUND
   init_sound();
+#endif
 
   init_input();
 
@@ -342,7 +395,7 @@
   execute_arm_translate(execute_cycles);
 #else
 
-#ifdef GP2X_BUILD
+#if defined(GP2X_BUILD) || defined(IPOD_BUILD)
   get_ticks_us(&frame_count_initial_timestamp);
 #endif
 
@@ -351,7 +404,9 @@
    current_savestate_filename);
   load_state(current_savestate_filename); */
 
+#ifndef IPOD_BUILD
   debug_on();
+#endif
 
   if(argc > 2)
   {
@@ -404,7 +459,9 @@
   u64 new_ticks;
   u8 current_savestate_filename[512];
 
+#ifndef BENCHMARK
   return;
+#else
 
   if(event_number)
   {
@@ -475,14 +532,14 @@
        benchmark_ticks[6];
       benchmark_ticks[7] = benchmark_ticks[0] - benchmark_ticks[1];
 
-      printf("Benchmark results (%d frames): \n", event_cycles_trigger);
+      fprintf(stderr, "Benchmark results (%d frames): \n", event_cycles_trigger);
       for(i = 0; i < 8; i++)
       {
-        printf("   %s: %d ms (%f ms per frame)\n",
+        fprintf(stderr, "   %s: %d ms (%f ms per frame)\n",
          print_strings[i], (u32)benchmark_ticks[i] / 1000,
          (float)(benchmark_ticks[i] / (1000.0 * event_cycles_trigger)));
         if(i == 4)
-          printf("\n");
+          fprintf(stderr, "\n");
       }
       quit();
     }
@@ -492,6 +549,7 @@
 
   get_ticks_us(benchmark_ticks + event_number);
   event_number++;
+#endif
 }
 
 u32 update_gba()
@@ -504,12 +562,14 @@
 
     reg[CHANGED_PC_STATUS] = 0;
 
+#ifndef NOSOUND
     if(gbc_sound_update)
     {
       gbc_update_count++;
       update_gbc_sound(cpu_ticks);
       gbc_sound_update = 0;
     }
+#endif
 
     update_timer(0);
     update_timer(1);
@@ -607,7 +667,9 @@
           if(update_input())
             continue;
 
+#ifndef NOSOUND
           update_gbc_sound(cpu_ticks);
+#endif
           synchronize();
 
           update_screen();
@@ -750,7 +812,7 @@
 
 #endif
 
-#ifdef GP2X_BUILD
+#if defined(GP2X_BUILD) || defined(IPOD_BUILD)
 
 u32 real_frame_count = 0;
 u32 virtual_frame_count = 0;
@@ -769,12 +831,14 @@
   static u32 fps = 60;
   static u32 frames_drawn = 60;
 
+#ifdef GP2X_BUILD
   if(gp2x_fps_debug)
   {
     char print_buffer[128];
     sprintf(print_buffer, "%d (%d)", fps, frames_drawn);
     print_string(print_buffer, 0xFFFF, 0x000, 0, 0);
   }
+#endif
 
   get_ticks_us(&new_ticks);
   time_delta = new_ticks - last_screen_timestamp;
@@ -930,7 +994,9 @@
   if(!update_backup_flag)
     update_backup_force();
 
+#ifndef NOSOUND
   sound_exit();
+#endif
 
 #ifdef REGISTER_USAGE_ANALYZE
   print_register_usage();
@@ -939,7 +1005,12 @@
 #ifdef PSP_BUILD
   sceKernelExitGame();
 #else
+
+#ifdef IPOD_BUILD
+  HD_LCD_Quit(); 
+#else
   SDL_Quit();
+#endif
 
 #ifdef GP2X_BUILD
   gp2x_quit();
@@ -954,7 +1025,9 @@
   init_main();
   init_memory();
   init_cpu();
+#ifndef NOSOUND
   reset_sound();
+#endif
 }
 
 #ifdef PSP_BUILD
diff -ur main.h main.h
--- main.h	2007-04-08 21:35:13.000000000 -0400
+++ main.h	2008-05-10 18:16:59.515625000 -0400
@@ -131,6 +131,14 @@
 
 #endif
 
+#ifdef IPOD_BUILD
+
+extern u32 no_alpha;
+
+#endif
+
+#ifndef NOSOUND
+
 #define count_timer(timer_number)                                             \
   timer[timer_number].reload = 0x10000 - value;                               \
   if(timer_number < 2)                                                        \
@@ -195,6 +203,49 @@
   }                                                                           \
   address16(io_registers, 0x102 + (timer_number * 4)) = value;                \
 
+#else
+
+#define count_timer(timer_number)                                             \
+  timer[timer_number].reload = 0x10000 - value;                               \
+
+#define trigger_timer(timer_number)                                           \
+  if(value & 0x80)                                                            \
+  {                                                                           \
+    if(timer[timer_number].status == TIMER_INACTIVE)                          \
+    {                                                                         \
+      u32 prescale = prescale_table[value & 0x03];                            \
+      u32 timer_reload = timer[timer_number].reload;                          \
+                                                                              \
+      if((value >> 2) & 0x01)                                                 \
+        timer[timer_number].status = TIMER_CASCADE;                           \
+      else                                                                    \
+        timer[timer_number].status = TIMER_PRESCALE;                          \
+                                                                              \
+      timer[timer_number].prescale = prescale;                                \
+      timer[timer_number].irq = (value >> 6) & 0x01;                          \
+                                                                              \
+      address16(io_registers, 0x100 + (timer_number * 4)) =                   \
+       -timer_reload;                                                         \
+                                                                              \
+      timer_reload <<= prescale;                                              \
+      timer[timer_number].count = timer_reload;                               \
+                                                                              \
+      if(timer_reload < execute_cycles)                                       \
+        execute_cycles = timer_reload;                                        \
+    }                                                                         \
+  }                                                                           \
+  else                                                                        \
+  {                                                                           \
+    if(timer[timer_number].status != TIMER_INACTIVE)                          \
+    {                                                                         \
+      timer[timer_number].status = TIMER_INACTIVE;                            \
+      timer[timer_number].stop_cpu_ticks = cpu_ticks;                         \
+    }                                                                         \
+  }                                                                           \
+  address16(io_registers, 0x102 + (timer_number * 4)) = value;                \
+
+#endif
+
 void change_ext(u8 *src, u8 *buffer, u8 *extension);
 
 #endif
diff -ur memory.c memory.c
--- memory.c	2007-04-08 21:35:13.000000000 -0400
+++ memory.c	2008-05-10 21:18:21.906250000 -0400
@@ -19,7 +19,15 @@
 
 #include "common.h"
 
+#ifdef PSP_BUILD
+extern u32 file_length(u8 *filename, s32 dummy)
+#else
+extern u32 file_length(u8 *dummy, FILE *fp);
+#endif
+
+#ifndef IPOD_BUILD
 u32 load_file_zip(u8 *filename);
+#endif
 
 // This table is configured for sequential access on system defaults
 
@@ -489,6 +497,8 @@
       break;                                                                  \
   }                                                                           \
 
+#ifndef NOSOUND
+
 #define trigger_dma(dma_number)                                               \
   if(value & 0x8000)                                                          \
   {                                                                           \
@@ -558,6 +568,73 @@
     address16(io_registers, (dma_number * 12) + 0xBA) = value;                \
   }                                                                           \
 
+#else
+
+#define trigger_dma(dma_number)                                               \
+  if(value & 0x8000)                                                          \
+  {                                                                           \
+    if(dma[dma_number].start_type == DMA_INACTIVE)                            \
+    {                                                                         \
+      u32 start_type = (value >> 12) & 0x03;                                  \
+      u32 dest_address = address32(io_registers, (dma_number * 12) + 0xB4) &  \
+       0xFFFFFFF;                                                             \
+                                                                              \
+      dma[dma_number].dma_channel = dma_number;                               \
+      dma[dma_number].source_address =                                        \
+       address32(io_registers, (dma_number * 12) + 0xB0) & 0xFFFFFFF;         \
+      dma[dma_number].dest_address = dest_address;                            \
+      dma[dma_number].source_direction = (value >>  7) & 0x03;                \
+      dma[dma_number].repeat_type = (value >> 9) & 0x01;                      \
+      dma[dma_number].start_type = start_type;                                \
+      dma[dma_number].irq = (value >> 14) & 0x01;                             \
+                                                                              \
+      /* If it is sound FIFO DMA make sure the settings are a certain way */  \
+      if((dma_number >= 1) && (dma_number <= 2) &&                            \
+       (start_type == DMA_START_SPECIAL))                                     \
+      {                                                                       \
+        dma[dma_number].length_type = DMA_32BIT;                              \
+        dma[dma_number].length = 4;                                           \
+        dma[dma_number].dest_direction = DMA_FIXED;                           \
+      }                                                                       \
+      else                                                                    \
+      {                                                                       \
+        u32 length =                                                          \
+         address16(io_registers, (dma_number * 12) + 0xB8);                   \
+                                                                              \
+        if((dma_number == 3) && ((dest_address >> 24) == 0x0D) &&             \
+         ((length & 0x1F) == 17))                                             \
+        {                                                                     \
+          eeprom_size = EEPROM_8_KBYTE;                                       \
+        }                                                                     \
+                                                                              \
+        if(dma_number < 3)                                                    \
+          length &= 0x3FFF;                                                   \
+                                                                              \
+        if(length == 0)                                                       \
+        {                                                                     \
+          if(dma_number == 3)                                                 \
+            length = 0x10000;                                                 \
+          else                                                                \
+            length = 0x04000;                                                 \
+        }                                                                     \
+                                                                              \
+        dma[dma_number].length = length;                                      \
+        dma[dma_number].length_type = (value >> 10) & 0x01;                   \
+        dma[dma_number].dest_direction = (value >> 5) & 0x03;                 \
+      }                                                                       \
+                                                                              \
+      address16(io_registers, (dma_number * 12) + 0xBA) = value;              \
+      if(start_type == DMA_START_IMMEDIATELY)                                 \
+        return dma_transfer(dma + dma_number);                                \
+    }                                                                         \
+  }                                                                           \
+  else                                                                        \
+  {                                                                           \
+    dma[dma_number].start_type = DMA_INACTIVE;                                \
+    address16(io_registers, (dma_number * 12) + 0xBA) = value;                \
+  }                                                                           \
+
+#endif
 
 #define access_register8_high(address)                                        \
   value = (value << 8) | (address8(io_registers, address))                    \
@@ -2158,10 +2235,14 @@
   s32 file_size;
   u8 cheats_filename[256];
 
+#ifdef IPOD_BUILD
+  file_size = load_gamepak_raw(name);
+#else
   if(!strcmp(dot_position, ".zip"))
     file_size = load_file_zip(name);
   else
     file_size = load_gamepak_raw(name);
+#endif
 
   // A dumb April fool's joke was here once :o
 
@@ -3182,11 +3263,13 @@
        convert_palette(current_color);
     }
 
+#ifndef NOSOUND
     // Oops, these contain raw pointers
     for(i = 0; i < 4; i++)
     {
       gbc_sound_channel[i].sample_data = square_pattern_duty[2];
     }
+#endif
     current_debug_state = STEP;
     instruction_count = 0;
 
diff -ur sound.c sound.c
--- sound.c	2007-04-08 21:35:13.000000000 -0400
+++ sound.c	2008-05-10 21:22:46.515625000 -0400
@@ -17,11 +17,18 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-
 #include "common.h"
+#ifdef IPOD_BUILD
+#include <sys/ioctl.h>
+#include <sys/soundcard.h>
+#define SOUND_DEVICE "/dev/dsp"
+void sound_callback(int length);
+#else
 #include <SDL.h>
+#endif
 u32 global_enable_audio = 1;
 
+u32 sound_fd;
 direct_sound_struct direct_sound_channel[2];
 gbc_sound_struct gbc_sound_channel[4];
 
@@ -31,9 +38,11 @@
 u32 sound_frequency = 44100;
 #endif
 
+#ifndef IPOD_BUILD
 SDL_AudioSpec sound_settings;
 SDL_mutex *sound_mutex;
 SDL_cond *sound_cv;
+#endif
 
 #ifndef PSP_BUILD
 u32 audio_buffer_size_number = 7;
@@ -433,11 +442,13 @@
 
 void synchronize_sound()
 {
+#ifndef IPOD_BUILD
   SDL_LockMutex(sound_mutex);
 
   gbc_sound_synchronize();
 
   SDL_UnlockMutex(sound_mutex);
+#endif
 }
 
 void update_gbc_sound(u32 cpu_ticks)
@@ -466,17 +477,21 @@
     gbc_sound_partial_ticks &= 0xFFFF;
   }
 
+#ifndef IPOD_BUILD
   SDL_LockMutex(sound_mutex);
+#endif
   if(synchronize_flag)
   {
     if(((gbc_sound_buffer_index - sound_buffer_base) % BUFFER_SIZE) >
      (audio_buffer_size * 3 / 2))
     {
+#ifndef IPOD_BUILD
       while(((gbc_sound_buffer_index - sound_buffer_base) % BUFFER_SIZE) >
        (audio_buffer_size * 3 / 2))
       {
         SDL_CondWait(sound_cv, sound_mutex);
       }
+#endif
 
 #ifdef PSP_BUILD
       if(current_frameskip_type == auto_frameskip)
@@ -579,15 +594,42 @@
 
   address16(io_registers, 0x84) = sound_status;
 
+#ifndef IPOD_BUILD
   SDL_CondSignal(sound_cv);
 
   SDL_UnlockMutex(sound_mutex);
+#endif
 
   gbc_sound_last_cpu_ticks = cpu_ticks;
+#ifndef IPOD_BUILD
   gbc_sound_buffer_index =
    (gbc_sound_buffer_index + (buffer_ticks * 2)) % BUFFER_SIZE;
+#else
+  gbc_sound_buffer_index =
+   (gbc_sound_buffer_index + (buffer_ticks << 1)) % BUFFER_SIZE;
+  if (((gbc_sound_buffer_index - sound_buffer_base) % BUFFER_SIZE) > (audio_buffer_size>>2))
+    sound_callback(audio_buffer_size>>2);
+#endif
 }
 
+#ifdef IPOD_BUILD
+
+#define sound_copy_normal()                                                   \
+  current_sample = source[i]                                                  \
+
+#define sound_copy(source_offset, length, render_type)                        \
+  _length = (length) / 2;                                                     \
+  source = (s16 *)(sound_buffer + source_offset);                             \
+  write(sound_fd, source,_length);					                          \
+  memset(source,0,_length);
+
+#define sound_copy_null(source_offset, length)                                \
+  _length = (length) / 2;                                                     \
+  source = (s16 *)(sound_buffer + source_offset);                             \
+  memset(source,0,_length);
+  
+#else
+
 #define sound_copy_normal()                                                   \
   current_sample = source[i]                                                  \
 
@@ -615,16 +657,25 @@
     source[i] = 0;                                                            \
   }                                                                           \
 
+#endif
+  
 
+#ifdef IPOD_BUILD
+void sound_callback(int length)
+#else
 void sound_callback(void *userdata, Uint8 *stream, int length)
+#endif
 {
   u32 sample_length = length / 2;
   u32 _length;
   u32 i;
+#ifndef IPOD_BUILD
   s16 *stream_base = (s16 *)stream;
+#endif
   s16 *source;
   s32 current_sample;
 
+#ifndef IPOD_BUILD
   SDL_LockMutex(sound_mutex);
 
   while(((gbc_sound_buffer_index - sound_buffer_base) % BUFFER_SIZE) <
@@ -632,6 +683,7 @@
   {
     SDL_CondWait(sound_cv, sound_mutex);
   }
+#endif
 
   if(global_enable_audio)
   {
@@ -666,9 +718,11 @@
     }
   }
 
+#ifndef IPOD_BUILD
   SDL_CondSignal(sound_cv);
 
   SDL_UnlockMutex(sound_mutex);
+#endif
 }
 
 // Special thanks to blarrg for the LSFR frequency used in Meridian, as posted
@@ -747,14 +801,18 @@
 {
   gbc_sound_buffer_index =
    (sound_buffer_base + audio_buffer_size) % BUFFER_SIZE;
+#ifndef IPOD_BUILD
   SDL_PauseAudio(1);
   SDL_CondSignal(sound_cv);
+#endif
 }
 
 void init_sound()
 {
 #ifdef PSP_BUILD
   audio_buffer_size = (audio_buffer_size_number * 1024) + 3072;
+#elif defined(IPOD_BUILD)
+  audio_buffer_size = 16384;
 #elif defined(TAVI_BUILD) || defined(ARM_ARCH)
   audio_buffer_size = 16 << audio_buffer_size_number;
 //  audio_buffer_size = 16384;
@@ -762,6 +820,43 @@
   audio_buffer_size = 16384;
 #endif
 
+#ifdef IPOD_BUILD
+    u32 mixer;
+    mixer = open("/dev/mixer", O_RDWR); 
+    u32 volume = 100; 
+    u32 vol = volume << 8 | volume;
+    int ret = ioctl(mixer, SOUND_MIXER_WRITE_PCM, &vol);
+    sound_fd = open(SOUND_DEVICE, O_WRONLY);
+    if (sound_fd < 0) {
+      perror("failed");
+      sound_fd = 0;
+      return;
+    } else {
+      printf("done.\n");
+    }
+    u32 tmp = 2;
+    u32 result = ioctl(sound_fd, SNDCTL_DSP_CHANNELS, &tmp);
+    if (result < 0) {
+      perror("failed");
+      close(sound_fd);
+      sound_fd = 0;
+      return;
+    } else {
+      printf("done.\n");
+    }
+    printf("setting sound rate to %dHz...", sound_frequency);
+    result = ioctl(sound_fd, SNDCTL_DSP_SPEED, &sound_frequency);
+    if (result < 0) {
+      perror("failed");
+      close(sound_fd);
+      sound_fd = 0;
+      return;
+    } else {
+      printf("got %dHz...done.\n", sound_frequency);
+    }
+#endif
+
+#ifndef IPOD_BUILD
   SDL_AudioSpec desired_spec =
   {
     sound_frequency,
@@ -774,6 +869,7 @@
     sound_callback,
     NULL
   };
+#endif
 
   gbc_sound_tick_step =
    float_to_fp16_16(256.0 / sound_frequency);
@@ -783,11 +879,13 @@
 
   reset_sound();
 
+#ifndef IPOD_BUILD
   SDL_OpenAudio(&desired_spec, &sound_settings);
   sound_frequency = sound_settings.freq;
   sound_mutex = SDL_CreateMutex();
   sound_cv = SDL_CreateCond();
   SDL_PauseAudio(0);
+#endif
 }
 
 #define sound_savestate_builder(type)                                       \
@@ -809,4 +907,3 @@
 
 sound_savestate_builder(read);
 sound_savestate_builder(write_mem);
-
diff -ur sound.h sound.h
--- sound.h	2007-04-08 21:35:13.000000000 -0400
+++ sound.h	2008-05-10 14:00:02.671875000 -0400
@@ -117,8 +117,10 @@
 extern u32 enable_low_pass_filter;
 extern u32 audio_buffer_size_number;
 
+#ifndef IPOD_BUILD
 extern SDL_mutex *sound_mutex;
 extern SDL_cond *sound_cv;
+#endif
 
 void sound_timer_queue8(u32 channel, u8 value);
 void sound_timer_queue16(u32 channel, u16 value);
diff -ur video.c video.c
--- video.c	2007-04-08 21:35:13.000000000 -0400
+++ video.c	2008-05-10 17:36:43.468750000 -0400
@@ -91,6 +91,31 @@
 #include "SDL_gp2x.h"
 SDL_Surface *hw_screen;
 #endif
+
+#ifdef IPOD_BUILD
+#include "ipod/cop.h"
+
+extern void HD_LCD_Init();
+extern void HD_LCD_GetInfo (int *hw_ver, int *lcd_width, int *lcd_height, int *lcd_type);
+extern void HD_LCD_Update (void *fb, int x, int y, int w, int h);
+
+// *screen is the GBA screen while
+// *iscreen is what gets blit'd to the iPod
+// scalex and scaley are used for scaling
+u16 *screen, *iscreen;
+u32 screenx, screeny;
+int scalex[320];
+int scaley[240];
+const u32 video_scale = 0;
+
+#define get_screen_pixels()                                                   \
+  ((u16 *)screen)                                                             \
+
+#define get_screen_pitch()                                                    \
+  (240)                                                                       \
+
+#else
+
 SDL_Surface *screen;
 const u32 video_scale = 1;
 
@@ -102,6 +127,8 @@
 
 #endif
 
+#endif
+
 void render_scanline_conditional_tile(u32 start, u32 end, u16 *scanline,
  u32 enable_flags, u32 dispcnt, u32 bldcnt, tile_layer_render_struct
  *layer_renderers);
@@ -657,7 +684,7 @@
 #define get_tile_4bpp()                                                       \
   current_tile = *map_ptr;                                                    \
   current_palette = (current_tile >> 12) << 4;                                \
-  tile_ptr = tile_base + ((current_tile & 0x3FF) * 32);                       \
+  tile_ptr = tile_base + ((current_tile & 0x3FF) << 5);                       \
 
 
 // Helper macro for drawing clipped 4bpp tiles.
@@ -860,7 +887,7 @@
   u32 pixel_run = 256 - (horizontal_offset % 256);                            \
   u32 current_tile;                                                           \
                                                                               \
-  map_base += ((vertical_offset % 256) / 8) * 32;                             \
+  map_base += ((vertical_offset % 256) / 8) << 5;                             \
   partial_tile_offset = (horizontal_offset % 8);                              \
                                                                               \
   if(pixel_run >= end)                                                        \
@@ -1022,12 +1049,12 @@
                                                                               \
   if((map_size & 0x02) && (vertical_offset >= 256))                           \
   {                                                                           \
-    map_base += ((map_width / 8) * 32) +                                      \
-     (((vertical_offset - 256) / 8) * 32);                                    \
+    map_base += ((map_width / 8) << 5) +                                      \
+     (((vertical_offset - 256) / 8) << 5);                                    \
   }                                                                           \
   else                                                                        \
   {                                                                           \
-    map_base += (((vertical_offset % 256) / 8) * 32);                         \
+    map_base += (((vertical_offset % 256) / 8) << 5);                         \
   }                                                                           \
                                                                               \
   if(map_size & 0x01)                                                         \
@@ -1568,7 +1595,7 @@
 // Get the current row offset into an obj in 1D map space
 
 #define obj_tile_offset_1D(color_depth, flip_op)                              \
-  tile_ptr = tile_base + ((obj_attribute_2 & 0x3FF) * 32)                     \
+  tile_ptr = tile_base + ((obj_attribute_2 & 0x3FF) << 5)                     \
    + ((vertical_offset / 8) * (obj_width / 8) * tile_size_##color_depth)      \
    + ((vertical_offset % 8) * tile_width_##color_depth)                       \
    obj_tile_offset_##flip_op(color_depth)                                     \
@@ -1576,7 +1603,7 @@
 // Get the current row offset into an obj in 2D map space
 
 #define obj_tile_offset_2D(color_depth, flip_op)                              \
-  tile_ptr = tile_base + ((obj_attribute_2 & 0x3FF) * 32)                     \
+  tile_ptr = tile_base + ((obj_attribute_2 & 0x3FF) << 5)                     \
    + ((vertical_offset / 8) * 1024)                                           \
    + ((vertical_offset % 8) * tile_width_##color_depth)                       \
    obj_tile_offset_##flip_op(color_depth)                                     \
@@ -1681,14 +1708,14 @@
 }                                                                             \
 
 #define obj_scale_offset_1D(color_depth)                                      \
-  tile_ptr = tile_base + ((obj_attribute_2 & 0x3FF) * 32)                     \
+  tile_ptr = tile_base + ((obj_attribute_2 & 0x3FF) << 5)                     \
    + ((vertical_offset / 8) * (max_x / 8) * tile_size_##color_depth)          \
    + ((vertical_offset % 8) * tile_width_##color_depth)                       \
 
 // Get the current row offset into an obj in 2D map space
 
 #define obj_scale_offset_2D(color_depth)                                      \
-  tile_ptr = tile_base + ((obj_attribute_2 & 0x3FF) * 32)                     \
+  tile_ptr = tile_base + ((obj_attribute_2 & 0x3FF) << 5)                     \
    + ((vertical_offset / 8) * 1024)                                           \
    + ((vertical_offset % 8) * tile_width_##color_depth)                       \
 
@@ -1776,7 +1803,7 @@
 
 #define obj_render_rotate(combine_op, color_depth, alpha_op, map_space)       \
 {                                                                             \
-  tile_ptr = tile_base + ((obj_attribute_2 & 0x3FF) * 32);                    \
+  tile_ptr = tile_base + ((obj_attribute_2 & 0x3FF) << 5);                    \
   obj_rotate_offset_##map_space(color_depth);                                 \
                                                                               \
   source_x += (y_delta * dmx) - (middle_x * dx);                              \
@@ -1834,8 +1861,8 @@
   u32 obj_pitch = tile_width_##color_depth;                                   \
   u32 obj_tile_pitch;                                                         \
                                                                               \
-  middle_x = (obj_width / 2);                                                 \
-  middle_y = (obj_height / 2);                                                \
+  middle_x = (obj_width >> 1);                                                 \
+  middle_y = (obj_height >> 1);                                                \
                                                                               \
   source_x = (middle_x << 8);                                                 \
   source_y = (middle_y << 8);                                                 \
@@ -3356,6 +3383,30 @@
     current_scanline_ptr += pitch;                                            \
   }                                                                           \
 
+#ifdef IPOD_BUILD
+void flip_screen()
+{
+  outl(inl(COP_STATUS) | COP_LINE_REQ, COP_STATUS);
+}
+void flip_screen_()
+{
+  u16 *bufp;
+  u32 p;
+  int i, j;
+  cop_operation(bufp = iscreen);
+  cop_operation(p = 0);
+  for (j = 0; j < screeny; cop_operation(j++))
+  {
+    for (i = 0; i < screenx; cop_operation(i++))
+    {
+      cop_operation(p = scaley[j] + scalex[i]);
+      cop_operation(*bufp = screen[p]);
+      cop_operation(bufp++);
+    }
+  }
+  HD_LCD_Update (iscreen, 0, 0, screenx, screeny);
+}
+#else
 void flip_screen()
 {
   if((video_scale != 1) && (current_scale != unscaled))
@@ -3414,6 +3465,7 @@
   SDL_Flip(screen);
 #endif
 }
+#endif
 
 #endif
 
@@ -3516,6 +3568,23 @@
 
 void init_video()
 {
+#ifdef IPOD_BUILD
+  
+  HD_LCD_Init();  
+  HD_LCD_GetInfo (0, &screenx, &screeny, 0);
+  screen = malloc(240*160*2);
+  iscreen = malloc(screenx*screeny*2);
+  outl(screen, 0x40015100);
+  
+  cop_begin();
+  
+  int k;
+  for (k = 0; k < screenx; cop_operation(k++))
+    cop_operation(scalex[k] = k * 240 / screenx);
+  for (k = 0; k < screeny; cop_operation(k++))
+    cop_operation(scaley[k] = (k * 160 / screeny) * 240);
+  
+#else
   SDL_Init(SDL_INIT_VIDEO | SDL_INIT_JOYSTICK | SDL_INIT_NOPARACHUTE);
 
 #ifdef GP2X_BUILD
@@ -3532,6 +3601,7 @@
   screen = SDL_SetVideoMode(240 * video_scale, 160 * video_scale, 16, 0);
 #endif
   SDL_ShowCursor(0);
+#endif
 }
 
 #endif
@@ -3657,6 +3727,9 @@
   SDL_ShowCursor(0);
 
   gp2x_load_mmuhack();
+#elif defined(IPOD_BUILD)
+  resolution_width = screenx;
+  resolution_height = screeny;
 #else
   screen = SDL_SetVideoMode(480, 272, 16, 0);
   resolution_width = 480;
@@ -3666,6 +3739,11 @@
 
 void video_resolution_small()
 {
+#ifdef IPOD_BUILD
+  current_scale = unscaled;
+  resolution_width = screenx;
+  resolution_height = screeny;
+#else
   current_scale = screen_scale;
 
 #ifdef GP2X_BUILD
@@ -3688,6 +3766,7 @@
 #endif
   resolution_width = small_resolution_width;
   resolution_height = small_resolution_height;
+#endif
 }
 
 void set_gba_resolution(video_scale_type scale)
@@ -3709,6 +3788,21 @@
 
 void clear_screen(u16 color)
 {
+#ifdef IPOD_BUILD
+  u16 *dest_ptr;
+  cop_operation(dest_ptr = screen);
+  int x, y;
+
+  for(y = 0; y < 160; cop_operation(y++))
+  {
+    for(x = 0; x < 240; cop_operation(x++))
+    {
+      cop_operation(*dest_ptr = color);
+      cop_operation(dest_ptr++);
+    }
+	cop_operation(dest_ptr++);
+  }
+#else
   u16 *dest_ptr = get_screen_pixels();
   u32 line_skip = get_screen_pitch() - screen->w;
   u32 x, y;
@@ -3721,19 +3815,27 @@
     }
     dest_ptr += line_skip;
   }
+#endif
 }
 
 #endif
 
 u16 *copy_screen()
 {
+#ifdef IPOD_BUILD
+  u16 *copy;
+  cop_operation(copy = malloc(240 * 160 * 2));
+  cop_operation(memcpy(copy, get_screen_pixels(), 240 * 160 * 2));
+#else
   u16 *copy = malloc(240 * 160 * 2);
   memcpy(copy, get_screen_pixels(), 240 * 160 * 2);
+#endif  
   return copy;
 }
 
 void blit_to_screen(u16 *src, u32 w, u32 h, u32 dest_x, u32 dest_y)
 {
+#ifndef IPOD_BUILD
   u32 pitch = get_screen_pitch();
   u16 *dest_ptr = get_screen_pixels() + dest_x + (dest_y * pitch);
 
@@ -3749,6 +3851,7 @@
     }
     dest_ptr += line_skip;
   }
+#endif
 }
 
 void print_string_ext(const char *str, u16 fg_color, u16 bg_color,
