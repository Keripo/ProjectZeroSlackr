diff -urN arch/armnommu/Makefile arch/armnommu/Makefile
--- arch/armnommu/Makefile	2008-10-10 03:49:22.000000000 -0400
+++ arch/armnommu/Makefile	2008-10-10 03:43:42.000000000 -0400
@@ -251,7 +251,7 @@
 
 ifeq ($(CONFIG_ARCH_IPOD),y)
 MACHINE		 = ipod
-TEXTADDR	 = 0x28008000
+TEXTADDR	 = 0x00008000
 endif
 
 export	LDFLAGS LIBGCC MACHINE PROCESSOR TEXTADDR GZFLAGS
diff -urN arch/armnommu/config.in arch/armnommu/config.in
--- arch/armnommu/config.in	2008-10-10 03:49:22.000000000 -0400
+++ arch/armnommu/config.in	2008-10-10 03:43:42.000000000 -0400
@@ -484,7 +484,7 @@
    define_bool CONFIG_CPU_ARM7TDMI y
    define_bool CONFIG_CPU_32 y
    define_bool CONFIG_CPU_26 n
-   define_hex DRAM_BASE 0x28000000
+   define_hex DRAM_BASE 0x00000000
    define_hex DRAM_SIZE 0x02000000
    define_hex FLASH_MEM_BASE 0x10000000
    define_hex FLASH_SIZE 0x00100000
@@ -699,6 +699,7 @@
    tristate "iPod Audio" CONFIG_AUDIO_IPOD
    tristate "iPod Keypad support" CONFIG_KB_IPOD
    dep_tristate "iPod Remote support" CONFIG_REMOTE_IPOD $CONFIG_INPUT_KEYBDEV
+   dep_tristate "iPod IDE support" CONFIG_IDE_IPOD $CONFIG_BLK_DEV_IDE
    endmenu
 fi
 
@@ -741,8 +742,9 @@
 	  8192KB	CONFIG_UNCACHED_8192" 1024KB
        fi
      fi
+   else
+     bool 'Allow allocating large blocks (> 1MB) of memory' CONFIG_NO_MMU_LARGE_ALLOCS
    fi
-   dep_bool '  Allow allocating large blocks (> 1MB) of memory' CONFIG_NO_MMU_LARGE_ALLOCS $CONFIG_CONTIGUOUS_PAGE_ALLOC
 fi
 
 endmenu
diff -urN arch/armnommu/def-configs/ipod arch/armnommu/def-configs/ipod
--- arch/armnommu/def-configs/ipod	2008-10-10 03:49:22.000000000 -0400
+++ arch/armnommu/def-configs/ipod	2008-10-10 03:43:42.000000000 -0400
@@ -43,7 +43,7 @@
 CONFIG_CPU_ARM7TDMI=y
 CONFIG_CPU_32=y
 # CONFIG_CPU_26 is not set
-DRAM_BASE=0x28000000
+DRAM_BASE=0x00000000
 DRAM_SIZE=0x02000000
 FLASH_MEM_BASE=0x10000000
 FLASH_SIZE=0x00100000
@@ -67,7 +67,7 @@
 # CONFIG_PM is not set
 # CONFIG_ARTHUR is not set
 CONFIG_CMDLINE_BOOL=y
-CONFIG_CMDLINE="root=/dev/hda3 rw"
+CONFIG_CMDLINE="root=/dev/ram0 init=/bin/init rw"
 # CONFIG_ALIGNMENT_TRAP is not set
 # CONFIG_PCI is not set
 # CONFIG_RAM_ATTACHED_ROMFS is not set
@@ -219,43 +219,9 @@
 #
 # ATA/IDE/MFM/RLL support
 #
-CONFIG_IDE=y
-
-#
-# IDE, ATA and ATAPI Block devices
-#
-CONFIG_BLK_DEV_IDE=y
-
-#
-# Please see Documentation/ide.txt for help/info on IDE drives
-#
-# CONFIG_BLK_DEV_HD_IDE is not set
+# CONFIG_IDE is not set
+# CONFIG_BLK_DEV_IDE_MODES is not set
 # CONFIG_BLK_DEV_HD is not set
-CONFIG_BLK_DEV_IDEDISK=y
-# CONFIG_IDEDISK_MULTI_MODE is not set
-# CONFIG_IDEDISK_STROKE is not set
-# CONFIG_BLK_DEV_IDECS is not set
-# CONFIG_BLK_DEV_IDECD is not set
-# CONFIG_BLK_DEV_IDETAPE is not set
-# CONFIG_BLK_DEV_IDEFLOPPY is not set
-# CONFIG_BLK_DEV_IDESCSI is not set
-# CONFIG_IDE_TASK_IOCTL is not set
-
-#
-# IDE chipset support/bugfixes
-#
-# CONFIG_BLK_DEV_CMD640 is not set
-# CONFIG_BLK_DEV_CMD640_ENHANCED is not set
-# CONFIG_BLK_DEV_ISAPNP is not set
-# CONFIG_BLK_DEV_UCLINUX_IDE is not set
-# CONFIG_IDE_CHIPSETS is not set
-# CONFIG_IDEDMA_AUTO is not set
-# CONFIG_DMA_NONPCI is not set
-CONFIG_BLK_DEV_IDE_MODES=y
-# CONFIG_BLK_DEV_ATARAID is not set
-# CONFIG_BLK_DEV_ATARAID_PDC is not set
-# CONFIG_BLK_DEV_ATARAID_HPT is not set
-# CONFIG_BLK_DEV_ATARAID_SII is not set
 
 #
 # SCSI support
@@ -351,7 +317,7 @@
 CONFIG_FBCON_CFB2=y
 # CONFIG_FBCON_CFB4 is not set
 # CONFIG_FBCON_CFB8 is not set
-# CONFIG_FBCON_CFB16 is not set
+CONFIG_FBCON_CFB16=y
 # CONFIG_FBCON_CFB24 is not set
 # CONFIG_FBCON_CFB32 is not set
 # CONFIG_FBCON_AFB is not set
@@ -396,10 +362,11 @@
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
-# CONFIG_BLK_DEV_LOOP is not set
+CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_NBD is not set
-# CONFIG_BLK_DEV_RAM is not set
-# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=2048
+CONFIG_BLK_DEV_INITRD=y
 # CONFIG_BLK_DEV_RAMDISK_DATA is not set
 # CONFIG_BLK_DEV_BLKMEM is not set
 # CONFIG_BLK_STATS is not set
@@ -418,7 +385,7 @@
 # CONFIG_ADFS_FS_RW is not set
 # CONFIG_AFFS_FS is not set
 # CONFIG_HFS_FS is not set
-CONFIG_HFSPLUS_FS=y
+# CONFIG_HFSPLUS_FS is not set
 # CONFIG_BEFS_FS is not set
 # CONFIG_BEFS_DEBUG is not set
 # CONFIG_BFS_FS is not set
@@ -466,16 +433,15 @@
 #
 # CONFIG_CODA_FS is not set
 # CONFIG_INTERMEZZO_FS is not set
-CONFIG_NFS_FS=y
-CONFIG_NFS_V3=y
+# CONFIG_NFS_FS is not set
+# CONFIG_NFS_V3 is not set
 # CONFIG_NFS_DIRECTIO is not set
 # CONFIG_ROOT_NFS is not set
 # CONFIG_NFSD is not set
 # CONFIG_NFSD_V3 is not set
 # CONFIG_NFSD_TCP is not set
-CONFIG_SUNRPC=y
-CONFIG_LOCKD=y
-CONFIG_LOCKD_V4=y
+# CONFIG_SUNRPC is not set
+# CONFIG_LOCKD is not set
 # CONFIG_SMB_FS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_NCPFS_PACKET_SIGNING is not set
@@ -496,7 +462,7 @@
 # CONFIG_OSF_PARTITION is not set
 # CONFIG_AMIGA_PARTITION is not set
 # CONFIG_ATARI_PARTITION is not set
-CONFIG_MAC_PARTITION=y
+# CONFIG_MAC_PARTITION is not set
 CONFIG_MSDOS_PARTITION=y
 # CONFIG_BSD_DISKLABEL is not set
 # CONFIG_MINIX_SUBPARTITION is not set
@@ -665,34 +631,6 @@
 # CONFIG_USB_GADGET is not set
 
 #
-# IEEE 1394 (FireWire) support (EXPERIMENTAL)
-#
-CONFIG_IEEE1394=y
-
-#
-# Device Drivers
-#
-
-#
-#   Texas Instruments PCILynx requires I2C bit-banging
-#
-# CONFIG_IEEE1394_OHCI1394 is not set
-CONFIG_IEEE1394_IPOD=m
-
-#
-# Protocol Drivers
-#
-# CONFIG_IEEE1394_VIDEO1394 is not set
-CONFIG_IEEE1394_SBP2=m
-CONFIG_IEEE1394_SBP2_PHYS_DMA=y
-CONFIG_IEEE1394_ETH1394=m
-# CONFIG_IEEE1394_DV1394 is not set
-# CONFIG_IEEE1394_RAWIO is not set
-# CONFIG_IEEE1394_CMP is not set
-# CONFIG_IEEE1394_VERBOSEDEBUG is not set
-# CONFIG_IEEE1394_OUI_DB is not set
-
-#
 # I2O device support
 #
 # CONFIG_I2O is not set
@@ -706,7 +644,8 @@
 #
 CONFIG_AUDIO_IPOD=y
 CONFIG_KB_IPOD=y
-CONFIG_REMOTE_IPOD=y
+# CONFIG_REMOTE_IPOD is not set
+# CONFIG_IDE_IPOD is not set
 
 #
 # Kernel hacking
@@ -718,8 +657,8 @@
 # CONFIG_DEBUG_INFO is not set
 # CONFIG_MAGIC_SYSRQ is not set
 # CONFIG_DEBUG_LL is not set
-CONFIG_CONTIGUOUS_PAGE_ALLOC=y
-CONFIG_MEM_MAP=y
+# CONFIG_CONTIGUOUS_PAGE_ALLOC is not set
+# CONFIG_MEM_MAP is not set
 CONFIG_NO_MMU_LARGE_ALLOCS=y
 
 #
diff -urN arch/armnommu/kernel/entry-armv.S arch/armnommu/kernel/entry-armv.S
--- arch/armnommu/kernel/entry-armv.S	2008-10-10 03:49:22.000000000 -0400
+++ arch/armnommu/kernel/entry-armv.S	2008-10-10 03:43:42.000000000 -0400
@@ -978,21 +978,9 @@
 #elif defined(CONFIG_ARCH_IPOD)
 
 #include <asm/arch/irqs.h>
-
-#define IDE_INT0_MASK	(1 << IDE_INT0_IRQ)
-#define SER0_MASK	(1 << SER0_IRQ)
-#define I2S_MASK	(1 << I2S_IRQ)
-#define SER1_MASK	(1 << SER1_IRQ)
-#define TIMER1_MASK	(1 << TIMER1_IRQ)
-#define GPIO_MASK	(1 << GPIO_IRQ)
-#define DMA_OUT_MASK	(1 << DMA_OUT_IRQ)
+#include <asm/arch/hardware.h>
 
 		.macro	disable_fiq
-.ifdef NOTDEF
-		mrs	r13, spsr
-		orr	r13, r13, #F_BIT
-		msr	spsr_c, r13
-.endif
 		ldr	pc, cop_fiq_loc
 
 cop_fiq_loc:	.word	cop_fiq
@@ -1000,53 +988,82 @@
 		.endm
 
 		.macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+		mov     r0, #PP_CPU_TYPE
+		ldr     r0, [r0]
+		cmp     r0, #0
+		bne	1002f		/* branch if PP5020 */
 
+		/* PP5002 code */
 		ldr 	\base, =(0xcf001000)
 		ldr	\irqstat, [\base]
 
-#if 1
-		tst	\irqstat, #DMA_OUT_MASK
-		movne	\irqnr, #DMA_OUT_IRQ
+		tst	\irqstat, #PP5002_DMA_OUT_MASK
+		movne	\irqnr, #PP5002_DMA_OUT_IRQ
 		bne	1001f
 
-		tst	\irqstat, #GPIO_MASK
-		movne	\irqnr, #GPIO_IRQ
+		tst	\irqstat, #PP5002_GPIO_MASK
+		movne	\irqnr, #PP5002_GPIO_IRQ
 		bne	1001f
 
-		tst	\irqstat, #IDE_INT0_MASK
-		movne	\irqnr, #IDE_INT0_IRQ
+		tst	\irqstat, #PP5002_IDE_MASK
+		movne	\irqnr, #PP5002_IDE_IRQ
 		bne	1001f
 
-		tst	\irqstat, #SER1_MASK
-		movne	\irqnr, #SER1_IRQ
+		tst	\irqstat, #PP5002_SER1_MASK
+		movne	\irqnr, #PP5002_SER1_IRQ
 		bne	1001f
 
-		tst	\irqstat, #I2S_MASK
-		movne	\irqnr, #I2S_IRQ
+		tst	\irqstat, #PP5002_I2S_MASK
+		movne	\irqnr, #PP5002_I2S_IRQ
 		bne	1001f
 
-		tst	\irqstat, #SER0_MASK
-		movne	\irqnr, #SER0_IRQ
+		tst	\irqstat, #PP5002_SER0_MASK
+		movne	\irqnr, #PP5002_SER0_IRQ
 		bne	1001f
 
-		tst	\irqstat, #TIMER1_MASK
-		movne	\irqnr, #TIMER1_IRQ
+		tst	\irqstat, #PP5002_TIMER1_MASK
+		movne	\irqnr, #PP5002_TIMER1_IRQ
 		bne	1001f
 
-1001:
+		b	1001f
 
-#else
-		mov     \irqnr, #0
-1001:
-		tst     \irqstat, #1
-		bne     1002f
-		add     \irqnr, \irqnr, #1
-		mov     \irqstat, \irqstat, lsr #1
-		cmp     \irqnr, #32
-		bcc     1001b
-1002:		/* EQ will be set if we reach 32 */
+1002:
+		/* PP5020 code */
+		ldr 	\base, =(0x64004000)
+		ldr	\irqstat, [\base]
 
-#endif
+		tst	\irqstat, #PP5020_TIMER1_MASK
+		movne	\irqnr, #PP5020_TIMER1_IRQ
+		bne	1001f
+
+		tst	\irqstat, #PP5020_IDE_MASK
+		movne	\irqnr, #PP5020_IDE_IRQ
+		bne	1001f
+
+		ldr 	\base, =(0x64004100)
+		ldr	\irqstat, [\base]
+
+		tst	\irqstat, #PP5020_GPIO0_MASK
+		movne	\irqnr, #PP5020_GPIO0_IRQ
+		bne	1001f
+
+		tst	\irqstat, #PP5020_GPIO1_MASK
+		movne	\irqnr, #PP5020_GPIO1_IRQ
+		bne	1001f
+
+		tst	\irqstat, #PP5020_SER0_MASK
+		movne	\irqnr, #PP5020_SER0_IRQ
+		bne	1001f
+
+		tst	\irqstat, #PP5020_SER1_MASK
+		movne	\irqnr, #PP5020_SER1_IRQ
+		bne	1001f
+
+		tst	\irqstat, #PP5020_I2C_MASK
+		movne	\irqnr, #PP5020_I2C_IRQ
+		bne	1001f
+
+1001:
 		.endm
 
 		.macro irq_prio_table
diff -urN arch/armnommu/kernel/head-arm-ipod.S arch/armnommu/kernel/head-arm-ipod.S
--- arch/armnommu/kernel/head-arm-ipod.S	2008-10-10 03:49:22.000000000 -0400
+++ arch/armnommu/kernel/head-arm-ipod.S	2008-10-10 03:43:42.000000000 -0400
@@ -5,11 +5,7 @@
 #include <asm/assembler.h>
 #include <asm/mach-types.h>
 #include <asm/mach/arch.h>
-
-	.equ	C_PROCESSOR_ID, 0xc4000000
-	.equ	C_CPU_SLEEP, 0xca
-	.equ	C_CPU_ID, 0x55
-	.equ	C_CFG_COPROC, 0xcf004058
+#include <asm/arch/hardware.h>
 
 /*
  * Reset condition :
@@ -24,56 +20,18 @@
 	mov     r0, #0xd3
 	msr     CPSR_c, r0
 
-.ifdef NOTDEF
-	ldr	r1, L_0xcf00502c
-	mov	r0, #0
-	str	r0, [r1]
-
-	ldr	r1, L_0xcf004024
-	mov	r0, #0
-	str	r0, [r1]
-
-	ldr	r1, L_0xcf005000
-	ldr	r0, L_0xb9f
-	str	r0, [r1]
-
-	ldr	r1, L_0xcf005004
-	mov	r0, #0x35
-	str	r0, [r1]
-.endif
-
-	/* clear and mask all interrupts */
-	ldr	r1, L_0xcf00101c
-	mov	r0, #-1
-	str	r0, [r1]
-
-	ldr	r1, L_0xcf001028
-	mov	r0, #-1
-	str	r0, [r1]
-
-	ldr	r1, L_0xcf001038
-	mov	r0, #-1
-	str	r0, [r1]
-
-	/* clear timers */
-	ldr	r1, L_0xcf001100
-	mov	r0, #0
-	str	r0, [r1]
-
-	ldr	r1, L_0xcf001104
-	ldr	r1, [r1]
-
-	ldr	r1, L_0xcf001108
-	mov	r0, #0
-	str	r0, [r1]
-
-	ldr	r1, L_0xcf00110c
-	ldr	r1, [r1]
-
 	/* setup memory mapping */
-	ldr	r1, C_0x40010000
-	ldr	r2, L_install_reloc_start
-	ldr	r3, L_install_reloc_end
+	ldr	r1, =0x40010000
+	ldr	r2, =install_reloc_start
+	ldr	r3, =install_reloc_end
+
+	/*
+	 * this code is compiled for 0x0 but running at 0x28000000
+	 * or 0x10000000 so we need to adjust
+	 */
+	and	r5, pc, #0xff000000	/* adjust for execute address */
+	orr	r2, r2, r5
+	orr	r3, r3, r5
 
 	/* copy the code to 0x40010000 */
 1:
@@ -82,11 +40,14 @@
 	cmp	r2, r3
 	ble	1b
 
-	ldr	r3, C_0x28003f84
-	ldr	r2, C_0xf000f014
-	mov	r1, #0x3b00
-	ldr	r0, C_0xf000f010
-	ldr	r4, C_0x40010000
+	ldr	r3, =0x3f84
+	orr	r3, r3, r5		/* adjust for execute address */
+/*	ldr	r2, =0xf000f014*/
+	ldr	r2, =0xf000f004
+	mov	r1, #0x3a00
+/*	ldr	r0, =0xf000f010*/
+	ldr	r0, =0xf000f000
+	ldr	r4, =0x40010000
 	mov	pc, r4
 
 install_reloc_start:
@@ -100,18 +61,42 @@
 install_reloc_end:
 
 post_reloc_start:
+	cmp	r5, #0x28000000
+	mov	r0, #PP_CPU_TYPE
+	moveq	r1, #0x0	/* we are a PP5002 */
+	movne	r1, #0x1	/* we are a PP5020 */
+	str	r1, [r0]
+	bne	pp5020
+
+pp5002:
+	/* check if we are cpu or co-processor */
+	ldr	r0, =PP5002_PROC_ID
+	ldr	r0, [r0]
+	and	r0, r0, #0xff
+	cmp	r0, #0x55
+	beq	cpu_startup
+
+	/* we are the co-processor, go to sleep until cpu wakes us up */
+	ldr	r0, =PP5002_COP_CTRL
+	mov	r1, #0xca
+	str	r1, [r0]
+	b	cop_startup
+
+pp5020:
 	/* check if we are cpu or co-processor */
-	mov	r0, #C_PROCESSOR_ID
+	ldr	r0, =PP5020_PROC_ID
 	ldr	r0, [r0]
 	and	r0, r0, #0xff
-	cmp	r0, #C_CPU_ID
+	cmp	r0, #0x55
 	beq	cpu_startup
 
 	/* we are the co-processor, go to sleep until cpu wakes us up */
-	ldr	r0, L_CFG_COPROC
-	mov	r1, #C_CPU_SLEEP
+	ldr	r0, =PP5020_COP_CTRL
+	mov	r1, #0x80000000
 	str	r1, [r0]
+	b	cop_startup
 
+cop_startup:
 	/* set stack pointer for FIQ mode */
 	mov	r0, #0xd1
 	msr	CPSR_c, r0
@@ -122,54 +107,15 @@
 	msr	CPSR_c, r0
 	ldr	sp, svc_sp
 
-.ifdef NOTDEF
-	/* copy our FIQ code to 0x4000000 */
-	mov	r1, #0x40000000
-	ldr	r2, L_cop_start
-	ldr	r3, L_cop_end
-
-	/* copy the code to 0x40000000 */
-1:
-	ldr	r4, [r2], #4
-	str	r4, [r1], #4
-	cmp	r2, r3
-	ble	1b
-.endif
-
-.ifdef NOTDEF
-	/* install our FIQ handler */
-	mov	r1, #0x1c
-	ldr	r2, cop_fiq_vec
-	ldr	r2, [r2]
-	str	r2, [r1]
-.endif
-
 	bl	ipod_init_cache
 
 	/* jump to our idle loop */
 	b	cop_idle
 
-cop_fiq_vec:
-	mov	pc, #0x40000000
-
 svc_sp:		.word cop_svc_stack
 fiq_sp:		.word cop_fiq_stack
 
-L_cop_start:	.word cop_fiq
-L_cop_end:	.word cop_end
-
-L_0xcf00502c:	.word 0xcf00502c
-L_0xcf004024:	.word 0xcf004024
-L_0xcf005000:	.word 0xcf005000
-L_0xb9f:	.word 0xb9f
-L_0xcf005004:	.word 0xcf005004
-L_0xcf00101c:	.word 0xcf00101c
-L_0xcf001028:	.word 0xcf001028
-L_0xcf001038:	.word 0xcf001038
-L_0xcf001100:	.word 0xcf001100
-L_0xcf001104:	.word 0xcf001104
-L_0xcf001108:	.word 0xcf001108
-L_0xcf00110c:	.word 0xcf00110c
+	.ltorg	/* dump literal pool to avoid section problems */
 
 cpu_startup:
 	/* get important "magic" values */
@@ -183,9 +129,9 @@
 	strcc	r4, [r5], #4
 	bcc	1b
 
+	bl	ipod_set_sys_info
 	bl	ipod_init_cache
 	bl	ipod_set_cpu_speed
-	bl	ipod_set_sys_info
 
 	/* put initial values into stack?? */
 	mov	r5, sp
@@ -219,17 +165,6 @@
 L_ARMID:	.long 0x41007700
 
 
-C_0x40010000:	.word 0x40010000
-
-L_install_reloc_start:	.word install_reloc_start
-L_install_reloc_end:	.word install_reloc_end
-
-C_0x28003f84:	.word 0x28003f84
-C_0xf000f014:	.word 0xf000f014
-C_0xf000f010:	.word 0xf000f010
-
-L_CFG_COPROC:	.word C_CFG_COPROC
-
 	.align 8
 LC0:	.long	SYMBOL_NAME(__bss_start)
 	.long	SYMBOL_NAME(processor_id)
@@ -237,15 +172,3 @@
 	.long	SYMBOL_NAME(__machine_arch_type)
 	.long	SYMBOL_NAME(init_task_union)+8192
 
-#ifdef CONFIG_BLK_DEV_RAM
-	.global __ramdisk_data
-	.global __ramdisk_data_end
-
-	.align 12
-__ramdisk_data:
-	.incbin "../../../initrd"
-__ramdisk_data_end:
-	.align
-
-#endif
-
diff -urN arch/armnommu/kernel/setup.c arch/armnommu/kernel/setup.c
--- arch/armnommu/kernel/setup.c	2008-10-10 03:30:21.000000000 -0400
+++ arch/armnommu/kernel/setup.c	2008-10-12 02:02:41.000000000 -0400
@@ -38,7 +38,7 @@
 #endif
 
 #ifndef CONFIG_CMDLINE
-#define CONFIG_CMDLINE "root=/dev/rom0"
+#define CONFIG_CMDLINE "root=/dev/rom0 initrd=/initrd"
 #endif
   
 #ifdef CONFIG_ARCH_NETARM
@@ -94,7 +94,7 @@
 static struct meminfo meminfo __initdata = { 0, };
 static struct proc_info_item proc_info;
 static const char *machine_name;
-static char command_line[COMMAND_LINE_SIZE] = "root=/dev/rom0";
+static char command_line[COMMAND_LINE_SIZE] = "root=/dev/rom0 initrd=/initrd";
 
 static char default_command_line[COMMAND_LINE_SIZE] __initdata = CONFIG_CMDLINE;
 static union { char c[4]; unsigned long l; } endian_test __initdata = { { 'l', '?', '?', 'b' } };
@@ -464,14 +464,19 @@
 	struct tag_header hdr2;
 	struct tag_mem32  mem;
 	struct tag_header hdr3;
+	struct tag_ramdisk ird;
+	struct tag_header hdr4;
 } init_tags __initdata = {
 	{ tag_size(tag_core), ATAG_CORE },
 	{ 1, PAGE_SIZE, 0xff },
 	{ tag_size(tag_mem32), ATAG_MEM },
 	{ MEM_SIZE, PHYS_OFFSET },
+	{ tag_size(tag_initrd), ATAG_INITRD },
+	{ 0x0A00000 , 2097152 },
 	{ 0, ATAG_NONE }
 };
 
+
 void __init setup_arch(char **cmdline_p)
 {
 	struct tag *tags = (struct tag *)&init_tags;
diff -urN arch/armnommu/mach-ipod/Makefile arch/armnommu/mach-ipod/Makefile
--- arch/armnommu/mach-ipod/Makefile	2008-10-10 03:49:22.000000000 -0400
+++ arch/armnommu/mach-ipod/Makefile	2008-10-12 02:03:50.000000000 -0400
@@ -11,7 +11,8 @@
 
 # Object file lists.
 
-obj-y += arch.o cop.o dma.o hardware.o irq.o time.o
+obj-y += arch.o cop.o dma.o hardware.o irq.o time.o sd.o battery.o rtc.o
+
 
 obj-$(CONFIG_AUDIO_IPOD)	+= audio.o
 obj-$(CONFIG_FB_IPOD)		+= fb.o
@@ -19,6 +20,6 @@
 obj-$(CONFIG_KB_IPOD)		+= keyboard.o
 obj-$(CONFIG_REMOTE_IPOD)	+= ipodremote.o
 
-export-objs		:= audio.o fb.o tsb43aa82.o keyboard.o ipodremote.o hardware.o
+export-objs		:= audio.o fb.o tsb43aa82.o keyboard.o hardware.o 
 
 include $(TOPDIR)/Rules.make
diff -urN arch/armnommu/mach-ipod/arch.c arch/armnommu/mach-ipod/arch.c
--- arch/armnommu/mach-ipod/arch.c	2008-10-10 03:49:22.000000000 -0400
+++ arch/armnommu/mach-ipod/arch.c	2008-10-10 03:43:42.000000000 -0400
@@ -26,7 +26,7 @@
 
 MACHINE_START(IPOD, "iPod")
 	MAINTAINER("Bernard Leach")
-	BOOT_MEM(0x28000000, 0xc0000000, 0x00000000)
+	BOOT_MEM(0x10000000, 0x60000000, 0x00000000)
 	INITIRQ(ipod_init_irq)
 	FIXUP(ipod_fixup)
 MACHINE_END
diff -urN arch/armnommu/mach-ipod/as3514.h arch/armnommu/mach-ipod/as3514.h
--- arch/armnommu/mach-ipod/as3514.h	1969-12-31 19:00:00.000000000 -0500
+++ arch/armnommu/mach-ipod/as3514.h	2008-10-10 03:43:42.000000000 -0400
@@ -0,0 +1,77 @@
+/***************************************************************************
+ *             __________               __   ___.
+ *   Open      \______   \ ____   ____ |  | _\_ |__   _______  ___
+ *   Source     |       _//  _ \_/ ___\|  |/ /| __ \ /  _ \  \/  /
+ *   Jukebox    |    |   (  <_> )  \___|    < | \_\ (  <_> > <  <
+ *   Firmware   |____|_  /\____/ \___  >__|_ \|___  /\____/__/\_ \
+ *                     \/            \/     \/    \/            \/
+ * $Id$
+ *
+ * Copyright (C) 2007 by Daniel Ankers
+ *
+ * All files in this archive are subject to the GNU General Public License.
+ * See the file COPYING in the source tree root for full license agreement.
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
+ * KIND, either express or implied.
+ *
+ ****************************************************************************/
+
+#ifndef _AS3514_H
+#define _AS3514_H
+
+#include <stdbool.h>
+
+extern int tenthdb2master(int db);
+
+extern void audiohw_enable_output(bool enable);
+extern int audiohw_set_master_vol(int vol_l, int vol_r);
+extern int audiohw_set_lineout_vol(int vol_l, int vol_r);
+extern void audiohw_set_sample_rate(int sampling_control);
+
+/* Register Descriptions */
+#define LINE_OUT_R 0x00
+#define LINE_OUT_L 0x01
+#define HPH_OUT_R  0x02
+#define HPH_OUT_L  0x03
+#define LSP_OUT_R  0x04
+#define LSP_OUT_L  0x05
+#define MIC1_R     0x06
+#define MIC1_L     0x07
+#define MIC2_R     0x08
+#define MIC2_L     0x09
+#define LINE_IN1_R 0x0a
+#define LINE_IN1_L 0x0b
+#define LINE_IN2_R 0x0c
+#define LINE_IN2_L 0x0d
+#define DAC_R      0x0e
+#define DAC_L      0x0f
+#define ADC_R      0x10
+#define ADC_L      0x11
+#define AUDIOSET1  0x14
+#define AUDIOSET2  0x15
+#define AUDIOSET3  0x16
+#define PLLMODE    0x1d
+
+#define SYSTEM     0x20
+#define DCDC15     0x23
+#define SUPERVISOR 0x24
+
+#define IRQ_ENRD0  0x25
+#define IRQ_ENRD1  0x26
+#define IRQ_ENRD2  0x27
+
+#define RTC_0      0x2a
+#define RTC_1      0x2b
+#define RTC_2      0x2c
+#define RTC_3      0x2d
+#define ADC_0      0x2e
+#define ADC_1      0x2f
+
+/* Headphone volume goes from -73.5 ... +6dB */
+#define VOLUME_MIN -735
+#define VOLUME_MAX   60
+
+#define AS3514_I2C_ADDR 0x46
+
+#endif /* _AS3514_H */
diff -urN arch/armnommu/mach-ipod/audio.c arch/armnommu/mach-ipod/audio.c
--- arch/armnommu/mach-ipod/audio.c	2008-10-10 03:49:22.000000000 -0400
+++ arch/armnommu/mach-ipod/audio.c	2008-10-10 03:43:42.000000000 -0400
@@ -23,253 +23,409 @@
 #include <asm/io.h>
 #include <asm/arch/irqs.h>
 #include <asm/arch/hardware.h>
+#include "pp5020.h"
+#include "as3514.h"
 
-#define D2A_POWER_OFF   1
-#define D2A_POWER_SB    2
-#define D2A_POWER_ON    3
-
-/* locations for our shared variables */
-#define DMA_READ_OFF	0x40000000
-#define DMA_WRITE_OFF	0x40000004
-#define DMA_ACTIVE	0x40000008
-#define DMA_STEREO	0x4000000c
-#define DMA_BASE	0x40000010
+extern int i2c_readbyte(unsigned int dev_addr, int addr);
+void i2s_reset(void);
 
 /* length of shared buffer in half-words (starting at DMA_BASE) */
-#define BUF_LEN		(46*1024)
+#define BUF_LEN		(40*1024)
 
 static int ipodaudio_isopen;
-static int ipodaudio_power_state;
-static unsigned ipod_hw_ver;
+// static int ipodaudio_power_state;
 static devfs_handle_t dsp_devfs_handle, mixer_devfs_handle;
 static int ipod_sample_rate = 44100;
-static volatile int *ipodaudio_stereo = (int short *)DMA_STEREO;
+static volatile int *ipodaudio_stereo = (int *)DMA_STEREO;
 static int ipod_mic_boost = 100;
-static int ipod_line_level = 0x17;	// 0dB
-static int ipod_pcm_level = 0x65;	// -6dB
+static int ipod_line_level = 0x17;
+static int ipod_pcm_level = 60;	
 static int ipod_active_rec = SOUND_MASK_MIC;
 
-static void
-set_clock_enb(unsigned short clks, int on)
-{
-	if ( on ) {
-		outw(inw(0xcf005000) | clks, 0xcf005000);
-	}
-	else {
-		outw(inw(0xcf005000) & ~clks, 0xcf005000);
-	}
-}
 
-static void
-d2a_set_active(int active)
-{
-	/* set active to 0x0 or 0x1 */
-	if ( active == 0 ) {
-		ipod_i2c_send(0x1a, 0x12, 0x00);
+#define ARRAYLEN(a) (sizeof(a)/sizeof((a)[0]))
 
-	} else {
-		ipod_i2c_send(0x1a, 0x12, 0x01);
-	}
-}
 
-static int
-d2a_set_sample_rate(int rate)
+/* Shadow registers */
+struct as3514_info
 {
-	int sampling_control;
+   int          vol_r;       /* Cached volume level (R) */
+   int          vol_l;       /* Cached volume level (L) */
+   unsigned int regs[0x1e];  /* last audio register: PLLMODE 0x1d */
+} as3514;
 
-	if (rate <= 8000) {
-		if (ipod_hw_ver == 0x3) {
-			/* set CLKIDIV2=1 SR=0011 BOSR=0 USB/NORM=1 (USB) */
-			sampling_control = 0x4d;
-		}
-		else {
-			/* set CLKIDIV2=1 SR=0001 BOSR=0 USB/NORM=1 (USB) */
-			sampling_control = 0x45;
-		}
-		rate = 8000;
-	}
-	else if (rate <= 32000) {
-		/* set CLKIDIV2=1 SR=0110 BOSR=0 USB/NORM=1 (USB) */
-		sampling_control = 0x59;
-		rate = 32000;
-	}
-	else if (rate <= 44100) {
-		/* set CLKIDIV2=1 SR=1000 BOSR=1 USB/NORM=1 (USB) */
-		sampling_control = 0x63;
-		rate = 44100;
-	}
-	else if (rate <= 48000) {
-		/* set CLKIDIV2=1 SR=0000 BOSR=0 USB/NORM=1 (USB) */
-		sampling_control = 0x41;
-		rate = 48000;
-	}
-	else if (rate <= 88200) {
-		/* set CLKIDIV2=1 SR=1111 BOSR=1 USB/NORM=1 (USB) */
-		sampling_control = 0x7f;
-		rate = 88200;
-	}
-	else {
-		/* set for 96kHz */
-		/* set CLKIDIV2=1 SR=0111 BOSR=0 USB/NORM=1 (USB) */
-		sampling_control = 0x5d;
-		rate = 96000;
-	}
+enum
+{
+   SOURCE_DAC = 0,
+      SOURCE_MIC1,
+      SOURCE_LINE_IN1,
+      SOURCE_LINE_IN1_ANALOG
+};
 
-	d2a_set_active(0x0);
-	ipod_i2c_send(0x1a, 0x10, sampling_control);
-	d2a_set_active(0x1);
+static unsigned int source = SOURCE_DAC;
 
-	ipod_sample_rate = rate;
 
-	return ipod_sample_rate;
+static void as3514_write(unsigned int reg, unsigned int value)
+{
+   unsigned char data[2];
+   
+   data[0] = reg;
+   data[1] = value;
+ 
+   ipod_i2c_lock();
+   if(ipod_i2c_send_bytes(AS3514_I2C_ADDR, 2, data) != 0)
+   {
+//      DEBUGF("as3514 error reg=0x%02x", reg);
+   }
+   ipod_i2c_unlock();
+  
+   if (reg < ARRAYLEN(as3514.regs))
+   {
+      as3514.regs[reg] = value;
+   }
+   else
+   {
+//      DEBUGF("as3514 error reg=0x%02x", reg);
+   }
 }
 
-static void
-d2a_set_power(int new_state)
+/* Helpers to set/clear bits */
+static void as3514_write_or(unsigned int reg, unsigned int bits)
 {
-	if ( ipodaudio_power_state == new_state) {
-		return;
-	}
+   as3514_write(reg, as3514.regs[reg] | bits);
+}
 
-	if ( new_state != D2A_POWER_OFF ) {
-		set_clock_enb((1<<1), 0x1);
-	}
+static void as3514_write_and(unsigned int reg, unsigned int bits)
+{
+   as3514_write(reg, as3514.regs[reg] & bits);
+}
 
-	if ( new_state == D2A_POWER_ON ) {
-		/* set power register to POWER_OFF=0 on OUTPD=0, DACPD=0 */
-		ipod_i2c_send(0x1a, 0xc, 0x67);
+/* convert tenth of dB volume to master volume register value */
+int as3514_tenthdb2master(int db)
+{
+   /* +6 to -73.5dB in 1.5dB steps == 53 levels */
+   if (db < VOLUME_MIN) {
+      return 0x0;
+   } else if (db >= VOLUME_MAX) {
+      return 0x35;
+   } else {
+      return((db-VOLUME_MIN)/15); /* VOLUME_MIN is negative */
+   }
+}
 
-		/* de-activate the d2a */
-		d2a_set_active(0x0);
+void as3514_mute(bool mute)
+{
+   if (mute) {
+      as3514_write_or(HPH_OUT_L, (1 << 7));
+   } else {
+      as3514_write_and(HPH_OUT_L, ~(1 << 7));
+   }
+}
 
-		/* set DACSEL=1 */
-		if (ipod_hw_ver == 0x3) {
-			ipod_i2c_send(0x1a, 0x8, 0x18);
-		} else {
-			ipod_i2c_send(0x1a, 0x8, 0x10);
-		}
+void as3514_enable_output(bool enable)
+{
+   if (enable) {
+      /* reset the I2S controller into known state */
+      i2s_reset();
+      
+      as3514_write_or(HPH_OUT_L, (1 << 6)); /* power on */
+      as3514_mute(0);
+   } else {
+      as3514_mute(1);
+      as3514_write_and(HPH_OUT_L, ~(1 << 6)); /* power off */
+   }
+}
 
-		/* set DACMU=0 DEEMPH=0 */
-		ipod_i2c_send(0x1a, 0xa, 0x00);
+int as3514_set_master_vol(int vol_l, int vol_r)
+{
+    unsigned int hph_r = as3514.regs[HPH_OUT_R] & ~0x1f;
+    unsigned int hph_l = as3514.regs[HPH_OUT_L] & ~0x1f;
+    unsigned int mix_l, mix_r;
+    unsigned int mix_reg_r, mix_reg_l;
+
+    /* keep track of current setting */
+    as3514.vol_l = vol_l;
+    as3514.vol_r = vol_r;
+
+    if (source == SOURCE_LINE_IN1_ANALOG) {
+        mix_reg_r = LINE_IN1_R;
+        mix_reg_l = LINE_IN1_L;
+    } else {
+        mix_reg_r = DAC_R;
+        mix_reg_l = DAC_L;
+    }
+
+    mix_r = as3514.regs[mix_reg_r] & ~0x1f;    
+    mix_l = as3514.regs[mix_reg_l] & ~0x1f;    
+
+    /* we combine the mixer channel volume range with the headphone volume
+       range */
+    if (vol_r <= 0x16) {
+        mix_r |= vol_r;
+        /* hph_r - set 0 */
+    } else {
+        mix_r |= 0x16;
+        hph_r += vol_r - 0x16;
+    }
+
+    if (vol_l <= 0x16) {
+        mix_l |= vol_l;
+        /* hph_l - set 0 */
+    } else {
+        mix_l |= 0x16;
+        hph_l += vol_l - 0x16;
+    }
+
+    as3514_write(mix_reg_r, mix_r);
+    as3514_write(mix_reg_l, mix_l);
+    as3514_write(HPH_OUT_R, hph_r);
+    as3514_write(HPH_OUT_L, hph_l);
 
-		/* set BCLKINV=0(Dont invert BCLK) MS=1(Enable Master) LRSWAP=0 LRP=0 IWL=10(24 bit) FORMAT=10(I2S format) */
-		ipod_i2c_send(0x1a, 0xe, 0x4a);
+    return 0;
+}
 
-		d2a_set_sample_rate(ipod_sample_rate);
+int as3514_set_lineout_vol(int vol_l, int vol_r)
+{
+    as3514_write(LINE_OUT_R, vol_r);
+    as3514_write(LINE_OUT_L, (1 << 6) | vol_l);
 
-		/* activate the d2a */
-		d2a_set_active(0x1);
-	}
-	else {
-		/* power off or standby the audio chip */
+    return 0;
+}
 
-		/* de-activate d2a */
-		d2a_set_active(0x0);
+void as3514_close(void)
+{
+    /* mute headphones */
+    as3514_mute(true);
 
-		/* line in mute left & right*/
-		ipod_i2c_send(0x1a, 0x0 | 0x1, 0x80);
+    /* turn off everything */
+    as3514_write(AUDIOSET1, 0x0);
+}
 
-		/* set DACMU=1 DEEMPH=0 */
-		ipod_i2c_send(0x1a, 0xa, 0x8);
+void as3514_set_sample_rate(int sampling_control)
+{
+    (void)sampling_control;
+}
 
-		/* set DACSEL=0, MUTEMIC=1 */
-		ipod_i2c_send(0x1a, 0x8, 0x2);
+void as3514_enable_recording(bool source_mic)
+{
+    if (source_mic) {
+        source = SOURCE_MIC1;
 
-		/* set POWEROFF=0 OUTPD=0 DACPD=1 */
-		ipod_i2c_send(0x1a, 0xc, 0x6f);
+        /* Sync mixer volumes before switching inputs */
+        as3514_set_master_vol(as3514.vol_l, as3514.vol_r);
 
-		if ( new_state == D2A_POWER_OFF ) {
-			/* power off the chip */
+        /* ADCmux = Stereo Microphone */
+        as3514_write_and(ADC_R, ~(0x3 << 6));
+        /* MIC1_on, LIN1_off */
+        as3514_write(AUDIOSET1,
+            (as3514.regs[AUDIOSET1] & ~(1 << 2)) | (1 << 0));
+        /* M1_AGC_off */
+        as3514_write_and(MIC1_R, ~(1 << 7));
+    } else {
+        source = SOURCE_LINE_IN1;
+
+        as3514_set_master_vol(as3514.vol_l, as3514.vol_r);
+
+        /* ADCmux = Line_IN1 */
+        as3514_write(ADC_R,
+            (as3514.regs[ADC_R] & ~(0x3 << 6)) | (0x1 << 6));
+        /* MIC1_off, LIN1_on */
+        as3514_write(AUDIOSET1,
+            (as3514.regs[AUDIOSET1] & ~(1 << 0)) | (1 << 2));
+    }
+
+    /* ADC_Mute_off */
+    as3514_write_or(ADC_L, (1 << 6));
+    /* ADC_on */
+    as3514_write_or(AUDIOSET1, (1 << 7));
+}
 
-			/* set POWEROFF=1 OUTPD=1 DACPD=1 */
-			ipod_i2c_send(0x1a, 0xc, 0xff);
+void as3514_disable_recording(void)
+{
+    source = SOURCE_DAC;
 
-			set_clock_enb((1<<1), 0x0);
-		}
-		else {
-			/* standby the chip */
+    /* ADC_Mute_on */
+    as3514_write_and(ADC_L, ~(1 << 6));
 
-			/* set POWEROFF=0 OUTPD=1 DACPD=1 */
-			ipod_i2c_send(0x1a, 0xc, 0x7f);
-		}
-	}
+    /* ADC_off, LIN1_off, MIC_off */
+    as3514_write_and(AUDIOSET1, ~((1 << 7) | (1 << 2) | (1 << 0)));
 
-	ipodaudio_power_state = new_state;
+    as3514_set_master_vol(as3514.vol_l, as3514.vol_r);
 }
 
-static void
-d2a_activate_linein(void)
+/**
+ * Set recording volume
+ *
+ * Line in   : 0 .. 23 .. 31 =>
+               Volume -34.5 .. +00.0 .. +12.0 dB
+ * Mic (left): 0 .. 23 .. 39 =>
+ *             Volume -34.5 .. +00.0 .. +24.0 dB
+ *
+ */
+void as3514_set_recvol(int left, int right, int mic)
 {
-	d2a_set_active(0x0);
-
-	if (ipod_line_level == 0) {
-		ipod_i2c_send(0x1a, 0x0 | 0x1, 0x80);
-	} else {
-		ipod_i2c_send(0x1a, 0x0 | 0x1, ipod_line_level);
-	}
-	ipod_i2c_send(0x1a, 0x4 | 0x1, 0x0);   /* headphone mute left & right */
-	ipod_i2c_send(0x1a, 0x8, 0xa);   /* BY PASS, mute mic, INSEL=line in */
-
-	ipod_i2c_send(0x1a, 0xa, 0x9); /* disable ADC high pass filter, mute dac */
+    if(mic)
+    {
+        /* Combine MIC gains seamlessly with ADC levels */
+        unsigned int mic1_r = as3514.regs[MIC1_R] & ~(0x3 << 5);
+
+        if (left >= 36) {
+            /* M1_Gain = +40db, ADR_Vol = +7.5dB .. +12.0 dB =>
+               +19.5 dB .. +24.0 dB */
+            left -= 8;
+            mic1_r |= (0x2 << 5);
+        } else if (left >= 32) {
+            /* M1_Gain = +34db, ADR_Vol = +7.5dB .. +12.0 dB =>
+               +13.5 dB .. +18.0 dB */
+            left -= 4; 
+            mic1_r |= (0x1 << 5);
+        }
+            /* M1_Gain = +28db, ADR_Vol = -34.5dB .. +12.0 dB =>
+               -34.5 dB .. +12.0 dB */
+
+        right = left;
+
+        as3514_write(MIC1_R, mic1_r);
+    }
+    as3514_write(ADC_R, (as3514.regs[ADC_R] & ~0x1f) | right);
+    as3514_write(ADC_L, (as3514.regs[ADC_L] & ~0x1f) | left);
+}
 
-	/* power on (PWR_OFF=0) */
-	ipod_i2c_send(0x1a, 0xc, 0x7a);  /* MICPD */
+/**
+ * Enable line in 1 analog monitoring
+ *
+ */
+void as3514_set_monitor(bool enable)
+{
+    /* LI1R_Mute_on - default */
+    unsigned int line_in1_r = as3514.regs[LINE_IN1_R] & ~(1 << 5);
+    /* LI1L_Mute_on - default */
+    unsigned int line_in1_l = as3514.regs[LINE_IN1_L] & ~(1 << 5);
+    /* LIN1_off - default */
+    unsigned int audioset1 = as3514.regs[AUDIOSET1] & ~(1 << 2);
+
+    if (enable) {
+        source = SOURCE_LINE_IN1_ANALOG;
+
+        /* LI1R_Mute_off */
+        line_in1_r |= (1 << 5);
+        /* LI1L_Mute_off */
+        line_in1_l |= (1 << 5);
+        /* LIN1_on */
+        audioset1 |= (1 << 2);
+    }
+
+    as3514_write(AUDIOSET1, audioset1);
+    as3514_write(LINE_IN1_R, line_in1_r);
+    as3514_write(LINE_IN1_L, line_in1_l);
 
-	d2a_set_active(0x1);
+    /* Sync mixer volume */
+    as3514_set_master_vol(as3514.vol_l, as3514.vol_r);
 }
 
-static void
-d2a_activate_mic(void)
+static void as3514_init_pb(void)
 {
-	d2a_set_active(0x0);
+   /* Set ADC off, mixer on, DAC on, line out off, line in off, mic off */
+   
+   /* Turn on SUM, DAC */
+   as3514_write(AUDIOSET1, (1 << 6) | (1 << 5));
+   /* Power on */
+   as3514_enable_output(true);
+   /* Unmute the master channel (DAC should be at zero point now). */
+   as3514_mute(false);
+   as3514_set_master_vol(as3514.vol_l, as3514.vol_r);
+}
 
-	ipod_i2c_send(0x1a, 0x0 | 0x1, 0x80);  /* line in mute left & right */
-	ipod_i2c_send(0x1a, 0x4 | 0x1, 0x0);   /* headphone mute left & right */
+static int codec_set_sample_rate(int rate)
+{
+//	ipod_sample_rate = rate;
+	return ipod_sample_rate;
+}
 
-	if (ipod_mic_boost) {
-		ipod_i2c_send(0x1a, 0x8, 0x5);   /* INSEL=mic, MIC_BOOST */
-	}
-	else {
-		ipod_i2c_send(0x1a, 0x8, 0x4);   /* INSEL=mic */
-	}
+static void codec_init_pb(void)
+{
+	as3514_init_pb();
+}
 
-	ipod_i2c_send(0x1a, 0xa, 0x9); /* disable ADC high pass filter, mute dac */
+static void codec_activate_mic(void)
+{
+	as3514_enable_recording(true);
+}
 
-	/* power on (PWR_OFF=0) */
-	ipod_i2c_send(0x1a, 0xc, 0x79);  /* CLKOUTPD OSCPD OUTPD DACPD LINEINPD */
+static void codec_activate_linein(void)
+{
+   as3514_enable_recording(false);
+}
 
-	d2a_set_active(0x1);
+static void codec_deinit(void)
+{
+	as3514_close();
 }
 
-static void ipodaudio_process_pb_dma(void)
+#if 0
+#define GPIOG_OUTPUT_VAL (*(volatile unsigned long *)(0x6000d0a8))
+#define GPIO_CLEAR_BITWISE(port, mask) do { *(&port + (0x800/sizeof(long))) = mask << 8; } while(0)
+#define GPIO_SET_BITWISE(port, mask) do { *(&port + (0x800/sizeof(long))) = (mask << 8) | mask; } while(0)
+
+static bool btnOn = true;
+#endif
+static void i2s_pp5020_pb_dma(void)
 {
 	volatile int *r_off = (int *)DMA_READ_OFF;
 	volatile int *w_off = (int *)DMA_WRITE_OFF;
 	volatile int *dma_active = (int *)DMA_ACTIVE;
 	volatile unsigned short *dma_buf = (unsigned short *)DMA_BASE;
 	int stereo = *ipodaudio_stereo;
+	int free_count;
+
+	outl(inl(0x70002800) & ~0x2, 0x70002800);
 
-	inl(0xcf001040);
-	outl(inl(0xc000251c) & ~(1<<9), 0xc000251c);
+repeat:
+	while (*r_off != *w_off) {
+		free_count = (inl(0x7000280c) & 0x3f0000) >> 16;
+
+		if (free_count < 2) {
+			/* enable interrupt */
+			outl(inl(0x70002800) | 0x2, 0x70002800);
 
-	while ( *r_off != *w_off ) {
-		if ( (inl(0xc000251c) & 0x7800000) == 0 ) {
-			outl(inl(0xc000251c)|(1<<9), 0xc000251c);
 			return;
 		}
 
-		outl(((unsigned)dma_buf[*r_off]) << 16, 0xc0002540);
-		if ( !stereo ) {
-			outl(((unsigned)dma_buf[*r_off]) << 16, 0xc0002540);
+		outl(((unsigned)dma_buf[*r_off]) << 16, 0x70002840);
+		if (!stereo) {
+			outl(((unsigned)dma_buf[*r_off]) << 16, 0x70002840);
 		}
 
+		/* enable playback fifo */
+		outl(inl(0x70002800) | 0x20000000, 0x70002800);
+
 		*r_off = (*r_off + 1) % BUF_LEN;
 	}
 
+	/* wait for fifo to empty */
+	while ((inl(0x70002804) & 0x80000000) == 0) {
+		if (*r_off != *w_off) {
+			goto repeat;
+		}
+	}
+
+	/* disable playback fifo */
+	outl(inl(0x70002800) & ~0x20000000, 0x70002800);
+   
+   IIS_IRQTX_REG &= ~IIS_IRQTX;
+
 	*dma_active = 0;
+
+#if 0
+   if(btnOn)
+      GPIO_CLEAR_BITWISE(GPIOG_OUTPUT_VAL, 0x80);
+   else
+      GPIO_SET_BITWISE(GPIOG_OUTPUT_VAL, 0x80);
+   btnOn = !btnOn;
+#endif
 }
 
-static void ipodaudio_process_rec_dma(void)
+static void i2s_pp5020_rec_dma(void)
 {
 	volatile int *r_off = (int *)DMA_READ_OFF;
 	volatile int *w_off = (int *)DMA_WRITE_OFF;
@@ -277,26 +433,35 @@
 	volatile unsigned short *dma_buf = (unsigned short *)DMA_BASE;
 	int stereo = *ipodaudio_stereo;
 
-	inl(0xcf001040);
-	outl(inl(0xc000251c) & ~(1<<14), 0xc000251c);
+	outl(inl(0x70002800) & ~0x1, 0x70002800);
 
-	while ( ((inl(0xc000251c) & 0x78000000)>>27) < 8 ) {
-		dma_buf[*w_off] = (unsigned short)(inl(0xc0002580) >> 8);
-		if ( !stereo ) {
+	while (*dma_active != 2) {
+		int full_count = (inl(0x7000280c) & 0x3f000000) >> 24;
+		if (full_count < 2) {
+			/* enable interrupt */
+			outl(inl(0x70002800) | 0x1, 0x70002800);
+			return;
+		}
+
+		dma_buf[*w_off] = (unsigned short)(inl(0x70002880) >> 16);
+		if (!stereo) {
 			/* throw away second sample */
-			inl(0xc0002580);
+			inl(0x70002880);
 		}
 
 		*w_off = (*w_off + 1) % BUF_LEN;
 
 		/* check for buffer over run */
-		if ( *r_off == *w_off ) {
+		if (*r_off == *w_off) {
 			*r_off = (*r_off + 1) % BUF_LEN;
 		}
 	}
 
-	outl(inl(0xc000251c) | (1<<14), 0xc000251c);
-	/* *dma_active = 0; */
+	/* disable fifo */
+	outl(inl(0x70002800) & ~0x10000000, 0x70002800);
+   
+	/* tell the cpu we are no longer active */
+	*dma_active = 3;
 }
 
 static int ipodaudio_open(struct inode *inode, struct file *filep)
@@ -305,7 +470,7 @@
 	volatile int *w_off = (int *)DMA_WRITE_OFF;
 	volatile int *dma_active = (int *)DMA_ACTIVE;
 
-	if ( ipodaudio_isopen ) {
+	if (ipodaudio_isopen) {
 		return -EBUSY;
 	}
 
@@ -316,58 +481,45 @@
 
 	ipodaudio_isopen = 1;
 	ipod_sample_rate = 44100;
-	*ipodaudio_stereo = 1;
+	*ipodaudio_stereo = 0;
 
-	/* cop setup */
-	if (filep->f_mode & FMODE_WRITE) {
-		d2a_set_power(D2A_POWER_ON);
+	/* reset the I2S controller into known state */
+	i2s_reset();
 
-		/* set the volume to -6dB */
-		ipod_i2c_send(0x1a, 0x4 | 0x1, ipod_pcm_level);
+	if (filep->f_mode & FMODE_WRITE) {
+		codec_init_pb();
 
-		if (ipod_hw_ver == 0x3) {
-			outl(inl(0xcf000004) & ~0xf, 0xcf000004);
-		}
+		/* setup I2S FIQ handler */
+		ipod_set_process_dma(i2s_pp5020_pb_dma);
 
-		ipod_set_process_dma(ipodaudio_process_pb_dma);
-		outl(inl(0xcf00103c) | (1 << DMA_OUT_IRQ) , 0xcf00103c);
-		outl((1 << DMA_OUT_IRQ), 0xcf001034);
+		/* setup I2S interrupt for FIQ */
+		outl(inl(0x6000403c) | PP5020_I2S_MASK, 0x6000403c);
+		outl(PP5020_I2S_MASK, 0x60004034);
 	}
 
 	if (filep->f_mode & FMODE_READ) {
-		/* 3g recording */
-		if (ipod_hw_ver != 0x3) {
-			return -ENODEV;
-		}
-
-		outl(inl(0xcf000004) & ~0xf, 0xcf000004);
-		outl(inl(0xcf004044) & ~0x4, 0xcf004044);
-
-		d2a_set_power(D2A_POWER_ON);
-
-		d2a_set_active(0x0);
-
-		/* set BCLKINV=0(Dont invert BCLK) MS=1(Enable Master) LRSWAP=0
-		   LRP=0 IWL=10(24 bit) FORMAT=00(MSB-First,right justified) */
- 		/* MS IWL=24bit FORMAT=MSB */
-		ipod_i2c_send(0x1a, 0xe, 0x48);
-
-		d2a_set_active(0x1);
-
+      
 		if (ipod_active_rec == SOUND_MASK_LINE) {
-			d2a_activate_linein();
-		}
-		else if (ipod_active_rec == SOUND_MASK_MIC) {
-			d2a_activate_mic();
+			codec_activate_linein();
+		} else if (ipod_active_rec == SOUND_MASK_MIC) {
+			codec_activate_mic();
 		}
 	}
-
 	return 0;
 }
 
 static void ipodaudio_txdrain(void)
 {
-	while ( (inl(0xc000251c) & (1<<0)) == 0 ) {
+	volatile int *r_off = (int *)DMA_READ_OFF;
+	volatile int *w_off = (int *)DMA_WRITE_OFF;
+	volatile int *dma_active = (int *)DMA_ACTIVE;
+
+	if (!*dma_active) {
+		printk(KERN_ERR "dma not active\n");
+		return;
+	}
+
+	while (*r_off != *w_off) {
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule_timeout(2);
 
@@ -379,23 +531,36 @@
 
 static int ipodaudio_close(struct inode *inode, struct file *filep)
 {
-	if (filep->f_mode & FMODE_WRITE) {
+   if (filep->f_mode & FMODE_WRITE) {
 		ipodaudio_txdrain();
 
-		outl((1 << DMA_OUT_IRQ), 0xcf001038);
-		ipod_set_process_dma(0);
+		/* mask the interrupt */
+//		outl(PP5020_I2S_MASK, 0x60004038);
+outl(inl(0x60004034) & ~PP5020_I2S_MASK, 0x60004034);
 	}
 
 	if (filep->f_mode & FMODE_READ) {
 		volatile int *dma_active = (int *)DMA_ACTIVE;
 
-		*dma_active = 0;
-		outl((1 << DMA_IN_IRQ), 0xcf001038);
-		ipod_set_process_dma(0);
-	}
+		if (*dma_active) {
+			/* tell COP dma to exit */
+			*dma_active = 2;
+
+			/* wait for the COP to signal its done */
+			while (*dma_active != 3) {
+				set_current_state(TASK_INTERRUPTIBLE);
+				schedule_timeout(2);
 
+				if (signal_pending(current)) {
+					break;
+				}
+			}
+		}
+	}
+	/* clear the handler */
+	ipod_set_process_dma(0);
 
-	d2a_set_power(D2A_POWER_OFF);
+	codec_deinit();
 
 	ipodaudio_isopen = 0;
 
@@ -414,7 +579,7 @@
 	volatile int *dma_active = (int *)DMA_ACTIVE;
 	volatile unsigned short *dma_buf = (unsigned short *)DMA_BASE;
 
-	if ( count <= 0 ) {
+	if (count <= 0) {
 		return 0;
 	}
 
@@ -423,7 +588,7 @@
 
 	write_off_current = *w_off;
 
-	while ( rem > 0 ) {
+	while (rem > 0) {
 		int cnt;
 
 		write_off_next = (write_off_current + 1) % BUF_LEN;
@@ -431,7 +596,7 @@
 		read_off_current = *r_off;
 
 		/* buffer full? */
-		if ( write_off_next == read_off_current ) {
+		if (write_off_next == read_off_current) {
 			/* buffer is full */
 			set_current_state(TASK_INTERRUPTIBLE);
 
@@ -439,30 +604,29 @@
 			schedule_timeout(2);
 		}
 
-		if ( read_off_current <= write_off_current ) {
+		if (read_off_current <= write_off_current) {
 			/* room at end of buffer? */
 			cnt = BUF_LEN - 1 - write_off_current;
-			if ( read_off_current > 0 ) cnt++;
+			if (read_off_current > 0) cnt++;
 
-			if ( cnt > 0 )  {
-				if ( cnt > rem ) cnt = rem;
+			if (cnt > 0)  {
+				if (cnt > rem) cnt = rem;
 
 				memcpy((void*)&dma_buf[write_off_current], bufsp, cnt<<1);
 
 				rem -= cnt;
 				bufsp += cnt;
 
-				write_off_current += cnt;
+				write_off_current = (write_off_current + cnt) % BUF_LEN;
 			}
 
 			/* room at start of buffer (and more data)? */
-			if ( read_off_current > 0 && rem > 0 ) {
+			if (read_off_current > 0 && rem > 0) {
 				int n;
 
-				if ( rem >= read_off_current ) {
+				if (rem >= read_off_current) {
 					n = read_off_current - 1;
-				}
-				else {
+				} else {
 					n = rem;
 				}
 
@@ -473,10 +637,9 @@
 
 				write_off_current = n;
 			}
-		}
-		else if ( read_off_current > write_off_current ) {
+		} else if (read_off_current > write_off_current) {
 			cnt = read_off_current - 1 - write_off_current;
-			if ( cnt > rem ) cnt = rem;
+			if (cnt > rem) cnt = rem;
 
 			memcpy((void*)&dma_buf[write_off_current], bufsp, cnt<<1);
 
@@ -488,10 +651,10 @@
 
 		*w_off = write_off_current;
 
-		if ( !*dma_active ) {
+      if (!*dma_active) {
 			*dma_active = 1;
-
-			outl(inl(0xc000251c)|(1<<9), 0xc000251c);
+			outl(inl(0x70002800) | 0x2, 0x70002800);
+			outl(inl(0x70002800) | 0x20000000, 0x70002800);
 		}
 	}
 
@@ -508,38 +671,41 @@
 	volatile int *dma_active = (int *)DMA_ACTIVE;
 	volatile unsigned short *dma_buf = (unsigned short *)DMA_BASE;
 
-	if ( !*dma_active ) {
+	if (!*dma_active) {
 		*dma_active = 1;
 
-		ipod_set_process_dma(ipodaudio_process_rec_dma);
-		outl(inl(0xcf00103c) | (1 << DMA_IN_IRQ) , 0xcf00103c);
-		outl((1 << DMA_IN_IRQ), 0xcf001034);
-
 		*r_off = 0;
 		*w_off = 0;
-		outl(inl(0xc000251c) | 0x20000, 0xc000251c);
 
-		outl(inl(0xc000251c) | (1<<14), 0xc000251c);
-	}
+		/* setup I2S FIQ handler */
+		ipod_set_process_dma(i2s_pp5020_rec_dma);
+
+		/* setup FIQ */
+		outl(inl(0x6000403c) | PP5020_I2S_MASK, 0x6000403c);
+		outl(PP5020_I2S_MASK, 0x60004034);
 
+		/* interrupt on full fifo */
+		outl(inl(0x70002800) | 0x1, 0x70002800);
+
+		/* enable record fifo */
+		outl(inl(0x70002800) | 0x10000000, 0x70002800);
+	}
 	bufsp = (unsigned short *)buf;
 	rem = count/2;
 
-	while ( rem > 0 ) {
+	while (rem > 0) {
 		int write_pos = *w_off;
 		int read_pos = *r_off;
 		int len = 0;
 
-		if ( read_pos < write_pos ) {
+		if (read_pos < write_pos) {
 			/* read data between read pos and write pos */
 			len = write_pos - read_pos;
-		}
-		else if ( write_pos < read_pos ) {
+		} else if (write_pos < read_pos) {
 			/* read data to end of buffer */
 			/* next loop iteration will read the rest */
 			len = BUF_LEN - read_pos;
-		}
-		else {
+		} else {
 			/* buffer is empty */
 			set_current_state(TASK_INTERRUPTIBLE);
 
@@ -547,7 +713,7 @@
 			schedule_timeout(2);
 		}
 
-		if ( len > rem ) {
+		if (len > rem) {
 			len = rem;
 		}
 
@@ -558,10 +724,9 @@
 			rem -= len;
 
 			/* check for buffer over run */
-			if ( read_pos == *r_off ) {
+			if (read_pos == *r_off) {
 				*r_off = (*r_off + len) % BUF_LEN;
-			}
-			else {
+			} else {
 				printk(KERN_ERR "ADC buffer overrun\n");
 			}
 		}
@@ -577,6 +742,30 @@
 	return count;
 }
 
+static int ipodaudio_getspace_ioctl(void *arg)
+{
+	audio_buf_info abinfo;
+	int read_pos = *(int *)DMA_READ_OFF;
+	int write_pos = *(int *)DMA_WRITE_OFF;
+	int len;
+
+	if (read_pos == write_pos) {
+		len = BUF_LEN - 1;	/* ring buffer empty */
+	} else if (read_pos < write_pos) {
+		len = BUF_LEN - 1 - (write_pos - read_pos);
+	} else {
+		int next_write_pos = (write_pos + 1) % BUF_LEN;
+
+		len = read_pos - next_write_pos;
+	}
+
+	abinfo.bytes = len * 2;
+	abinfo.fragsize = BUF_LEN / 2;
+	abinfo.fragments = abinfo.bytes / abinfo.fragsize;
+
+	return copy_to_user(arg, &abinfo, sizeof(abinfo)) ? -EFAULT : 0;
+}
+
 static int ipodaudio_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
 {
 	int rc = 0;
@@ -585,10 +774,10 @@
 	switch (cmd) {
 	case SNDCTL_DSP_SPEED:
 		rc = verify_area(VERIFY_READ, (void *) arg, sizeof(val));
-		if ( rc == 0 ) {
+		if (rc == 0) {
 			get_user(val, (int *) arg);
 
-			val = d2a_set_sample_rate(val);
+			val = codec_set_sample_rate(val);
 
 			put_user(val, (int *) arg);
 		}
@@ -596,7 +785,7 @@
 
 	case SNDCTL_DSP_GETFMTS:
 		rc = verify_area(VERIFY_READ, (void *) arg, sizeof(val));
-		if ( rc == 0 ) {
+		if (rc == 0) {
 			put_user(AFMT_S16_LE, (int *) arg);
 		}
 		break;
@@ -604,9 +793,9 @@
 	case SNDCTL_DSP_SETFMT:
 	/* case SNDCTL_DSP_SAMPLESIZE: */
 		rc = verify_area(VERIFY_READ, (void *) arg, sizeof(val));
-		if ( rc == 0 ) {
+		if (rc == 0) {
 			get_user(val, (int *) arg);
-			if ( val != AFMT_S16_LE ) {
+			if (val != AFMT_S16_LE) {
 				put_user(AFMT_S16_LE, (int *) arg);
 			}
 		}
@@ -614,12 +803,11 @@
 
 	case SNDCTL_DSP_STEREO:
 		rc = verify_area(VERIFY_READ, (void *) arg, sizeof(val));
-		if ( rc == 0 ) {
+		if (rc == 0) {
 			get_user(val, (int *) arg);
-			if ( val != 0 && val != 1 ) {
+			if (val != 0 && val != 1) {
 				put_user(1, (int *) arg);
-			}
-			else {
+			} else {
 				*ipodaudio_stereo = val;
 			}
 		}
@@ -627,7 +815,7 @@
 
 	case SNDCTL_DSP_CHANNELS:
 		rc = verify_area(VERIFY_READ, (void *) arg, sizeof(val));
-		if ( rc == 0 ) {
+		if (rc == 0) {
 			get_user(val, (int *) arg);
 			if (val > 2) {
 				val = 2;
@@ -639,7 +827,7 @@
 
 	case SNDCTL_DSP_GETBLKSIZE:
 		rc = verify_area(VERIFY_WRITE, (void *) arg, sizeof(long));
-		if ( rc == 0 ) {
+		if (rc == 0) {
 			put_user(BUF_LEN/2, (int *) arg);
 		}
 		break;
@@ -652,6 +840,9 @@
 	case SNDCTL_DSP_RESET:
 		rc = 0;
 		break;
+
+	case SNDCTL_DSP_GETOSPACE:
+		return ipodaudio_getspace_ioctl((void *)arg);
 	}
 
 	return rc;
@@ -681,9 +872,12 @@
 {
 	if (cmd == SOUND_MIXER_INFO) {
 		mixer_info info;
+		unsigned char *codec;
 
-		strncpy(info.id, "WM8731", sizeof(info.id));
-		strncpy(info.name, "Wolfson WM8731", sizeof(info.name));
+      codec = "AS3514";
+	       
+		strncpy(info.id, codec, sizeof(info.id));
+		strncpy(info.name, "AS", sizeof(info.name));
 		if (copy_to_user((void *) arg, &info, sizeof(info)))
 			return -EFAULT;
 		return 0;
@@ -716,7 +910,7 @@
 			return put_user(ipod_active_rec, (int *)arg);
 
 		case SOUND_MIXER_PCM:		/* codec output level */
-			val = (ipod_pcm_level - 0x2f) * 100 / 80;
+			val = ipod_pcm_level;
 			val = val << 8 | val;
 			return put_user(val, (int *)arg);
 
@@ -742,12 +936,10 @@
 		case SOUND_MIXER_RECSRC:
 			if (val != ipod_active_rec) {
 				if (val == SOUND_MASK_LINE) {
-					d2a_activate_linein();
-				}
-				else if (val == SOUND_MASK_MIC) {
-					d2a_activate_mic();
-				}
-				else {
+					codec_activate_linein();
+				} else if (val == SOUND_MASK_MIC) {
+					codec_activate_mic();
+				} else {
 					val = ipod_active_rec;
 				}
 
@@ -757,29 +949,25 @@
 			return put_user(val, (int *)arg);
 
 		case SOUND_MIXER_PCM:		/* codec output level */
-			/* +6 to -73dB 1dB steps (plus mute == 80levels) 7bits */
-			/* 1111001 == 0dB */
-			/* 0110000 == -73dB */
-			/* 0101111 == mute (0x2f) */
 			left = val & 0xff;
 			right = (val >> 8) & 0xff;
 
 			if (left > 100) left = 100;
 			if (right > 100) right = 100;
+         ipod_pcm_level = left;
+         
+         if(left > 5)
+            left = ((26 * left)/100) + 23;  // max 47 (53 is too loud)
+         else 
+            left = 0;
+         if(right > 5)
+            right = ((26 * right)/100) + 23; // max 47 (53 is too loud)
+         else
+            right = 0;
 
-			if (left == right) {
-				ipod_pcm_level = (left * 80 / 100) + 0x2f;
-				ipod_i2c_send(0x1a, 0x4 | 0x1, ipod_pcm_level);
-			}
-			else {
-				ipod_pcm_level = (left * 80 / 100) + 0x2f;
-				ipod_i2c_send(0x1a, 0x4, ipod_pcm_level);
+         as3514_set_master_vol(left, right);
 
-				right = (right * 80 / 100) + 0x2f;
-				ipod_i2c_send(0x1a, 0x6, right);
-			}
-
-			return put_user(val, (int *)arg);
+         return put_user(val, (int *)arg);
 
 		case SOUND_MIXER_LINE:	/* line-in jack */
 			/* +12 to -34.5dB 1.5dB steps (plus mute == 32levels) 5bits + mute */
@@ -790,46 +978,16 @@
 			if (left > 100) left = 100;
 			if (right > 100) right = 100;
 
-			if (left == right) {
-				ipod_line_level = left * 31 / 100;
-				if (ipod_line_level == 0) {
-					ipod_i2c_send(0x1a, 0x0 | 0x1, 0x80);
-				} else {
-					ipod_i2c_send(0x1a, 0x0 | 0x1, ipod_line_level);
-				}
-			}
-			else {
-				ipod_line_level = left * 31 / 100;
-				if (ipod_line_level == 0) {
-					ipod_i2c_send(0x1a, 0x0, 0x80);
-				} else {
-					ipod_i2c_send(0x1a, 0x0, ipod_line_level);
-				}
-				right = right * 31 / 100;
-				if (right == 0) {
-					ipod_i2c_send(0x1a, 0x2, 0x80);
-				} else {
-					ipod_i2c_send(0x1a, 0x2, right);
-				}
-			}
+         ipod_line_level = left * 31 / 100;
+         as3514_set_recvol(left, right, false);
 
 			return put_user(val, (int *)arg);
 
 		case SOUND_MIXER_MIC:		/* microphone */
 			/* 0 or +20dB (mic boost) plus mute */
-			if (val == 100) {
-				/* enable mic boost */
-				if (ipod_active_rec == SOUND_MASK_MIC) {
-					ipod_i2c_send(0x1a, 0x8, 0x5);   /* INSEL=mic, MIC_BOOST */
-				}
-			}
-			else {
-				/* disable mic boost */
-				val = 0;
-				if (ipod_active_rec == SOUND_MASK_MIC) {
-					ipod_i2c_send(0x1a, 0x8, 0x4);   /* INSEL=mic */
-				}
-			}
+
+         as3514_set_recvol(val, val, true);
+         
 			ipod_mic_boost = val;
 
 			return put_user(val, (int *)arg);
@@ -848,9 +1006,108 @@
 	ioctl: ipod_mixer_ioctl,
 };
 
+void i2s_reset(void)
+{
+   /* I2S soft reset */
+   IISCONFIG |= IIS_RESET;
+   IISCONFIG &= ~IIS_RESET;
+   
+   /* BIT.FORMAT */
+   IISCONFIG = ((IISCONFIG & ~IIS_FORMAT_MASK) | IIS_FORMAT_IIS);
+   /* BIT.SIZE */
+   IISCONFIG = ((IISCONFIG & ~IIS_SIZE_MASK) | IIS_SIZE_16BIT);
+   
+   /* FIFO.FORMAT */
+   /* If BIT.SIZE < FIFO.FORMAT low bits will be 0 */
+   /* AS3514 can only operate as I2S Slave */
+   IISCONFIG |= IIS_MASTER;
+   /* Set I2S to 44.1kHz */
+   IISCLK = (IISCLK & ~0x1ff) | 33;
+   IISDIV = 7;
+   
+   IISCONFIG = ((IISCONFIG & ~IIS_FIFO_FORMAT_MASK) | IIS_FIFO_FORMAT_LE32);
+   
+   /* RX_ATN_LVL = when 12 slots full */
+   /* TX_ATN_LVL = when 12 slots empty */
+   IISFIFO_CFG |= IIS_RX_FULL_LVL_12 | IIS_TX_EMPTY_LVL_12;
+   
+   /* Rx.CLR = 1, TX.CLR = 1 */
+   IISFIFO_CFG |= IIS_RXCLR | IIS_TXCLR;
+}
+
+static void __init ipodaudio_hw_init(void)
+{
+   int i;
+	/* reset I2C */
+	ipod_i2c_init();
+
+
+   /* normal outputs for CDI and I2S pin groups */
+   DEV_INIT2 &= ~0x300;
+   
+   /*mini2?*/
+   DEV_INIT1 &=~0x3000000;
+   /*mini2?*/
+   
+   /* device reset */
+   DEV_RS |= DEV_I2S;
+   DEV_RS &=~DEV_I2S;
+   
+   /* device enable */
+   DEV_EN |= (DEV_I2S | 0x7);
+   
+   /* enable external dev clock clocks */
+   DEV_EN |= 0x2;
+   
+   /* external dev clock to 24MHz */
+   outl(inl(0x70000018) & ~0xc, 0x70000018);
+   
+   i2s_reset();
+   
+   /* Set ADC off, mixer on, DAC on, line out off, line in off, mic off */
+   
+   /* Turn on SUM, DAC */
+   as3514_write(AUDIOSET1, (1 << 6) | (1 << 5));
+   
+   /* Set BIAS on, DITH on, AGC on, IBR_DAC max, LSP_LP on, IBR_LSP min */
+   as3514_write(AUDIOSET2, (1 << 2) | (3 << 0));
+   
+   /* Set HPCM off, ZCU off*/
+   as3514_write(AUDIOSET3, (1 << 2) | (1 << 0));
+   
+   /* Mute and disable speaker */
+   as3514_write(LSP_OUT_R, 0);
+   as3514_write(LSP_OUT_L, (1 << 7));
+   
+   /* set vol and set headphone over-current to 0 */
+   as3514_write(HPH_OUT_R, (0x3 << 6) | 0x16);
+   /* set default vol for headphone */
+   as3514_write(HPH_OUT_L, 0x16);
+   
+   /* LRCK 24-48kHz */
+   as3514_write(PLLMODE, 0x00);
+   
+   /* DAC_Mute_off */
+   as3514_write_or(DAC_L, (1 << 6));
+   
+   /* M1_Sup_off */
+   as3514_write_or(MIC1_L, (1 << 7));
+   /* M2_Sup_off */
+   as3514_write_or(MIC2_L, (1 << 7));
+   
+   /* read all reg values */
+   ipod_i2c_lock();
+   for (i = 0; i < ARRAYLEN(as3514.regs); i++)
+   {
+      as3514.regs[i] = i2c_readbyte(AS3514_I2C_ADDR, i);
+   }
+   ipod_i2c_unlock();
+   as3514_set_master_vol(37, 37);
+}
+
 static int __init ipodaudio_init(void)
 {
-	printk("ipodaudio: (c) Copyright 2003,2004 Bernard Leach <leachbj@bouncycastle.org>\n");
+   printk("ipodaudio: (c) Copyright 2008 Bernard Leach <leachbj@bouncycastle.org>\n");
 
 	dsp_devfs_handle = devfs_register(NULL, "dsp", DEVFS_FL_DEFAULT,
 			SOUND_MAJOR, SND_DEV_DSP,
@@ -871,50 +1128,12 @@
 		return 0;
 	}
 
-	ipod_hw_ver = ipod_get_hw_version() >> 16;
-	if (ipod_hw_ver == 0x3) {
-		/* reset I2C */
-		ipod_i2c_init();
-
-		/* reset DAC and ADC fifo */
-		outl(inl(0xc000251c) | 0x10000, 0xc000251c);
-		outl(inl(0xc000251c) | 0x20000, 0xc000251c);
-		outl(inl(0xc000251c) & ~0x30000, 0xc000251c);
-
-		/* enable ADC/DAC */
-		outl(0xd, 0xc0002500);
-
-		/* bits 11,10 == 01 */
-		outl(inl(0xcf004040) | 0x400, 0xcf004040);
-		outl(inl(0xcf004040) & ~0x800, 0xcf004040);
-
-		outl(inl(0xcf004048) & ~0x1, 0xcf004048);
-	}
-	else {
-		/* reset DAC fifo */
-		outl(inl(0xc000251c) | 0x10000, 0xc000251c);
-		outl(inl(0xc000251c) & ~0x10000, 0xc000251c);
-
-		/* enable DAC */
-		outl(0x5, 0xc0002500);
-
-		/* nb this is different to 3g!? */
-		/* bits 11,10 == 10 */
-		outl(inl(0xcf004040) & ~0x400, 0xcf004040);
-		outl(inl(0xcf004040) | 0x800, 0xcf004040);
-	}
-
-	/* GPIO D bit 6 enable for output */
-	outl(inl(0xcf00000c) | 0x40, 0xcf00000c);
-	outl(inl(0xcf00001c) & ~0x40, 0xcf00001c);
-
+	ipodaudio_hw_init();
 	return 0;
 }
 
 static void __exit ipodaudio_exit(void)
 {
-	ipod_set_process_dma(0);
-
 	devfs_unregister_chrdev(SOUND_MAJOR, "mixer");
 	devfs_unregister(mixer_devfs_handle);
 
@@ -928,3 +1147,4 @@
 MODULE_AUTHOR("Bernard Leach <leachbj@bouncycastle.org>");
 MODULE_DESCRIPTION("Audio driver for IPod");
 MODULE_LICENSE("GPL");
+
diff -urN arch/armnommu/mach-ipod/battery.c arch/armnommu/mach-ipod/battery.c
--- arch/armnommu/mach-ipod/battery.c	1969-12-31 19:00:00.000000000 -0500
+++ arch/armnommu/mach-ipod/battery.c	2008-10-10 03:43:42.000000000 -0400
@@ -0,0 +1,182 @@
+/*
+ * battery.c - battery-status for iPod
+ *
+ * Copyright (c) 2008 Bernard Leach (Sebastian.Duell@iPodLinux.org)
+ *
+ * Routines mostly from Rockbox and iPodLinux
+ */
+
+#include <linux/module.h>
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/major.h>
+#include <linux/miscdevice.h>
+#include <linux/fcntl.h>
+#include <linux/init.h>
+
+#include <linux/proc_fs.h>
+
+#include "pp5020.h"
+#include "as3514.h"
+
+#define NUM_ADC_CHANNELS 13
+#define ADC_BVDD         0  /* Battery voltage of 4V LiIo accumulator */
+
+extern ipod_i2c_send(unsigned int addr, int data0, int data1);
+extern int ipod_i2c_readbytes(unsigned int dev_addr, int addr, int len, unsigned char *data);
+
+/* Read 10-bit channel data */
+unsigned short adc_read(int channel)
+{
+   unsigned short data = 0;
+   
+   if ((unsigned)channel < NUM_ADC_CHANNELS)
+   {
+      /* Select channel */   
+      ipod_i2c_lock();
+      if (ipod_i2c_send( AS3514_I2C_ADDR, ADC_0, (channel << 4)) >= 0)
+      {
+         unsigned char buf[2];
+         
+         /* Read data */
+         if (ipod_i2c_readbytes( AS3514_I2C_ADDR, ADC_0, 2, buf) >= 0)
+         {
+            data = (((buf[0] & 0x3) << 8) | buf[1]);
+         }
+      }
+      ipod_i2c_unlock();
+   }
+   
+   return data;
+}
+
+/* voltages (millivolt) of 0%, 10%, ... 100% when charging disabled */
+const unsigned short percent_to_volt_discharge[11] =
+{
+   /* iPod Li Ion 750mAH, took from battery benchs */
+     3300, 3390, 3480, 3570, 3660, 3750, 3840, 3930, 4020, 4110, 4200 
+};
+
+
+static int voltage_to_percent(int voltage, const short* table)
+{
+   if (voltage <= table[0])
+      return 0;
+   else
+      if (voltage >= table[10])
+         return 100;
+      else {
+         /* search nearest value */
+         int i = 0;
+         while ((i < 10) && (table[i+1] < voltage))
+            i++;
+         /* interpolate linear between the smaller and greater value */
+         return (i * 10) /* Tens digit, 10% per entry */
+            + (((voltage - table[i]) * 10)
+            / (table[i+1] - table[i])); /* Ones digit: interpolated */
+      }
+}
+
+/* ADC should read 0x3ff=5.12V */
+#define BATTERY_SCALE_FACTOR 5125       
+/* full-scale ADC readout (2^10) in millivolt */
+
+/* Returns battery voltage from ADC [millivolts] */
+unsigned int battery_adc_voltage(void)
+{
+   return (adc_read(ADC_BVDD) * BATTERY_SCALE_FACTOR) >> 10;
+}
+
+static int ipod_apm_read(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	char *p;
+
+	static char driver_version[] = "1.16";      /* no spaces */
+
+	unsigned short  ac_line_status = 0xff;
+	unsigned short  battery_status = 0;
+	unsigned short  battery_flag   = 0xff;
+	int             percentage     = -1;
+	int             time_units     = -1;
+	char            *units         = "?";
+
+   percentage = voltage_to_percent(battery_adc_voltage(), percent_to_volt_discharge);
+   time_units = ((percentage * 512) / 100);
+
+   if(GPIOB_INPUT_VAL & 0x10)
+      battery_status = 0x3;	// charging 
+   
+	units = "ipods";
+
+        /* Arguments, with symbols from linux/apm_bios.h.  Information is
+           from the Get Power Status (0x0a) call unless otherwise noted.
+
+           0) Linux driver version (this will change if format changes)
+           1) APM BIOS Version.  Usually 1.0, 1.1 or 1.2.
+           2) APM flags from APM Installation Check (0x00):
+              bit 0: APM_16_BIT_SUPPORT
+              bit 1: APM_32_BIT_SUPPORT
+              bit 2: APM_IDLE_SLOWS_CLOCK
+              bit 3: APM_BIOS_DISABLED
+              bit 4: APM_BIOS_DISENGAGED
+           3) AC line status
+              0x00: Off-line
+              0x01: On-line
+              0x02: On backup power (BIOS >= 1.1 only)
+              0xff: Unknown
+           4) Battery status
+              0x00: High
+              0x01: Low
+              0x02: Critical
+              0x03: Charging
+              0x04: Selected battery not present (BIOS >= 1.2 only)
+              0xff: Unknown
+           5) Battery flag
+              bit 0: High
+              bit 1: Low
+              bit 2: Critical
+              bit 3: Charging
+              bit 7: No system battery
+              0xff: Unknown
+           6) Remaining battery life (percentage of charge):
+              0-100: valid
+              -1: Unknown
+           7) Remaining battery life (time units):
+              Number of remaining minutes or seconds
+              -1: Unknown
+           8) min = minutes; sec = seconds */
+
+	p = page;
+	p += sprintf(p, "%s %d.%d 0x%02x 0x%02x 0x%02x 0x%02x %d%% %d %s\n",
+		driver_version,
+		1, // (apm_info.bios.version >> 8) & 0xff,
+		0, // apm_info.bios.version & 0xff,
+		0, // apm_info.bios.flags,
+		ac_line_status,
+		battery_status,
+		battery_flag,
+		percentage,
+		time_units,
+		units);
+
+	return p - page;
+}
+
+static int __init battery_init(void)
+{
+   ipod_i2c_init();
+   create_proc_read_entry("apm", 0, NULL, ipod_apm_read, NULL);
+   return 0;
+}
+
+static void __exit battery_exit(void)
+{
+   remove_proc_entry("apm", NULL);
+}
+
+module_init(battery_init);
+module_exit(battery_exit);
+
+MODULE_AUTHOR("Bernard Leach (Sebastian.Duell@iPodLinux.org)");
+MODULE_DESCRIPTION("Battery-status for iPod");
+MODULE_LICENSE("GPL");
\ No newline at end of file
diff -urN arch/armnommu/mach-ipod/cop.S arch/armnommu/mach-ipod/cop.S
--- arch/armnommu/mach-ipod/cop.S	2008-10-10 03:49:22.000000000 -0400
+++ arch/armnommu/mach-ipod/cop.S	2008-10-10 03:43:42.000000000 -0400
@@ -1,83 +1,89 @@
 /*
  * cop.S - coprocessor code
  *
- * Copyright (c) 2003, Bernard Leach (leachbj@bouncycastle.org)
+ * Copyright (c) 2003-2005, Bernard Leach (leachbj@bouncycastle.org)
  */
 
+#include <asm/arch/hardware.h>
+
 	.global cop_fiq
-	.global cop_end
 	.global cop_idle
 
-	.equ C_PROCESSOR_ID, 0xc4000000
-	.equ C_CPU_ID, 0x55
-
-	.equ C_CFG_COPROC, 0xcf004058
-	.equ C_CPU_SLEEP, 0xca
-
 cop_fiq:
-	stmdb   sp!, {r0, lr}
-
-.ifdef NOTDEF
-	ldr	r0, L_lcd_base
-	ldr	r1, [r0]
-	orr	r1, r1, #0x2
-	str	r1, [r0]
-.endif
-	ldr	r0, L_C_PROCESSOR_ID
-	ldr	r0, [r0]
-	and	r0, r0, #0xff
-	cmp	r0, #C_CPU_ID
+	mov	r8, #PP_CPU_TYPE
+	ldr	r8, [r8]
+	cmp	r8, #0
+
+	ldreq	r8, =PP5002_PROC_ID
+	ldrne	r8, =PP5020_PROC_ID
+	ldr	r8, [r8]
+	and	r8, r8, #0xff
+	cmp	r8, #0x55
 	beq	1f
 
-	mov	lr, pc
-	ldr	pc, L_ipod_handle_dma
+	stmdb   sp!, {r0-r7, lr}
 
-	nop
-	nop
-	nop
+	bl	ipod_handle_dma
 
+	ldmia   sp!, {r0-r7, lr}
 1:
-	ldmia   sp!, {r0, lr}
 	subs	pc, lr, #4
 
-L_C_PROCESSOR_ID:	.word C_PROCESSOR_ID
-
-cop_fiq_end:
 
 cop_idle:
+	mov	r0, #0x0
+	bl	ipod_set_process_dma
+
+	mov	r0, #0x0
+	bl	ipod_set_handle_cop
+
 	/* enable FIQ */
 	mrs     r0, cpsr
 	bic     r0, r0, #0x40
 	msr     cpsr_c, r0
 
 cop_sleep:
+	mov	r0, #PP_CPU_TYPE
+	ldr	r0, [r0]
+	cmp	r0, #0
+	bne	pp5020
+
+	/* PP5002 */
 	/* put us (co-processor) to sleep */
-	ldr	r4, L_CFG_COPROC
-	mov	r3, #C_CPU_SLEEP
-	strh	r3, [r4]
+	ldr	r1, =PP5002_COP_CTRL
+	mov	r0, #0xca	
+	strh	r0, [r1]
+	b	1f
 
+pp5020:
+	/* PP5020 */
+	/* put us (co-processor) to sleep */
+	ldr	r1, =PP5020_COP_CTRL
+	mov	r0, #0x80000000	
+	str	r0, [r1]
+
+1:
 	nop
 	nop
 
-	b	cop_sleep
 
-	.global cop_fiq_stack
-	.global cop_svc_stack
+	ldr	r1, =COP_STATE
+	mov	r0, #0x1
+	str	r0, [r1]
+	
+	bl	ipod_handle_cop
 
-	.lcomm cop_fiq_stack, 1024
-	.lcomm cop_svc_stack, 1024
 
-L_CFG_COPROC:	.word C_CFG_COPROC
+	ldr	r1, =COP_STATE
+	mov 	r0, #0x0
+	str 	r0, [r1]
 
-L_ipod_handle_dma:.word ipod_handle_dma
 
-L_lcd_base:	.word 0xc0001000
+	b	cop_sleep
 
-/* these must match those in audio.c */
-L_DMA_READ_OFF:	.word 0x40000000
-L_DMA_WRITE_OFF:.word 0x40000004
-L_DMA_ACTIVE:	.word 0x40000008
-L_DMA_BASE:	.word 0x4000000c
+	.global cop_fiq_stack
+	.global cop_svc_stack
 
-cop_end:
+	.lcomm cop_fiq_stack, 1024
+	.lcomm cop_svc_stack, 1024
 
diff -urN arch/armnommu/mach-ipod/fb.c arch/armnommu/mach-ipod/fb.c
--- arch/armnommu/mach-ipod/fb.c	2008-10-10 03:49:22.000000000 -0400
+++ arch/armnommu/mach-ipod/fb.c	2008-10-11 23:06:10.000000000 -0400
@@ -1,9 +1,9 @@
 /*
  * fb.c - Frame-buffer driver for iPod
  *
- * Copyright (c) 2003,2004 Bernard Leach (leachbj@bouncycastle.org)
+ * Copyright (c) 2008 Bernard Leach (Sebastian.Duell@iPodLinux.org)
  *
- * The LCD uses the HD66753 controller from Hitachi (now owned by Renesas).
+ * Skeleton from iPodLinux, routines mostly from Rockbox
  */
 
 #include <linux/config.h>
@@ -24,232 +24,522 @@
 #include <asm/uaccess.h>
 
 #include <video/fbcon.h>
-#include <video/fbcon-cfb2.h>
+#include <video/fbcon-cfb16.h>
 
-/* the ID returned by the controller */
-#define HD66753_ID	0x5307
+#include "pp5020.h"
+#include "as3514.h"
 
-#define IPOD_LCD_BASE	0xc0001000
-#define IPOD_RTC	0xcf001110
+#define IPOD_LCD_WIDTH	220
+#define IPOD_LCD_HEIGHT	176
 
-#define IPOD_LCD_WIDTH	160
-#define IPOD_LCD_HEIGHT	128
+#define LCD_WIDTH	IPOD_LCD_WIDTH
+#define LCD_HEIGHT	IPOD_LCD_HEIGHT
+
+/* Reverse Flag */
+#define R_DISP_CONTROL_NORMAL 0x0004
+#define R_DISP_CONTROL_REV    0x0000
+static unsigned short r_disp_control_rev = R_DISP_CONTROL_NORMAL;
+
+/* Flipping */
+#define R_DRV_OUTPUT_CONTROL_NORMAL  0x101b
+#define R_DRV_OUTPUT_CONTROL_FLIPPED 0x131b
+static unsigned short r_drv_output_control  = R_DRV_OUTPUT_CONTROL_NORMAL;
+
+#define GPIOG_OUTPUT_VAL (*(volatile unsigned long *)(0x6000d0a8))
+#define GPIO_CLEAR_BITWISE(port, mask) do { *(&port + (0x800/sizeof(long))) = mask << 8; } while(0)
+#define GPIO_SET_BITWISE(port, mask) do { *(&port + (0x800/sizeof(long))) = (mask << 8) | mask; } while(0)
+
+#define LCD_CLOCK_GPIO GPIOB_OUTPUT_VAL
+#define LCD_CLOCK_PIN 5
+
+#define LCD_DATA_OUT_GPIO GPIOB_OUTPUT_VAL
+#define LCD_DATA_OUT_PIN 7
+
+#define LCD_CS_GPIO GPIOD_OUTPUT_VAL
+#define LCD_CS_PIN 6
+
+
+#define LCD_REG_0 (*(volatile unsigned long *)(0xc2000000))
+#define LCD_REG_1 (*(volatile unsigned long *)(0xc2000004))
+#define LCD_REG_2 (*(volatile unsigned long *)(0xc2000008))
+#define LCD_REG_3 (*(volatile unsigned long *)(0xc200000c))
+#define LCD_REG_4 (*(volatile unsigned long *)(0xc2000010))
+#define LCD_REG_5 (*(volatile unsigned long *)(0xc2000014))
+#define LCD_REG_6 (*(volatile unsigned long *)(0xc2000018))
+#define LCD_REG_7 (*(volatile unsigned long *)(0xc200001c))
+#define LCD_REG_8 (*(volatile unsigned long *)(0xc2000020))
+#define LCD_REG_9 (*(volatile unsigned long *)(0xc2000024))
+#define LCD_FB_BASE_REG (*(volatile unsigned long *)(0xc2000028))
+
+/* Taken from HD66789 datasheet and seems similar enough.
+Definitely a Renesas chip though with a perfect register index
+match but at least one bit seems to be set that that datasheet
+doesn't show. It says T.B.D. on the regmap anyway. */
+#define R_START_OSC             0x00
+#define R_DRV_OUTPUT_CONTROL    0x01
+#define R_DRV_WAVEFORM_CONTROL  0x02
+#define R_ENTRY_MODE            0x03
+#define R_COMPARE_REG1          0x04
+#define R_COMPARE_REG2          0x05
+#define R_DISP_CONTROL1         0x07
+#define R_DISP_CONTROL2         0x08
+#define R_DISP_CONTROL3         0x09
+#define R_FRAME_CYCLE_CONTROL   0x0b
+#define R_EXT_DISP_INTF_CONTROL 0x0c
+#define R_POWER_CONTROL1        0x10
+#define R_POWER_CONTROL2        0x11
+#define R_POWER_CONTROL3        0x12
+#define R_POWER_CONTROL4        0x13
+#define R_RAM_ADDR_SET          0x21
+#define R_RAM_READ_DATA         0x21
+#define R_RAM_WRITE_DATA        0x22
+#define R_RAM_WRITE_DATA_MASK1  0x23
+#define R_RAM_WRITE_DATA_MASK2  0x24
+#define R_GAMMA_FINE_ADJ_POS1   0x30
+#define R_GAMMA_FINE_ADJ_POS2   0x31
+#define R_GAMMA_FINE_ADJ_POS3   0x32
+#define R_GAMMA_GRAD_ADJ_POS    0x33
+#define R_GAMMA_FINE_ADJ_NEG1   0x34
+#define R_GAMMA_FINE_ADJ_NEG2   0x35
+#define R_GAMMA_FINE_ADJ_NEG3   0x36
+#define R_GAMMA_GRAD_ADJ_NEG    0x37
+#define R_GAMMA_AMP_ADJ_POS     0x38
+#define R_GAMMA_AMP_ADJ_NEG     0x39
+#define R_GATE_SCAN_START_POS   0x40
+#define R_VERT_SCROLL_CONTROL   0x41
+#define R_1ST_SCR_DRIVE_POS     0x42
+#define R_2ND_SCR_DRIVE_POS     0x43
+#define R_HORIZ_RAM_ADDR_POS    0x44
+#define R_VERT_RAM_ADDR_POS     0x45
+
+
+#define DEFAULT_BRIGHTNESS_SETTING  6
+
+
+#define P2_M1(p2)  ((1 << (p2))-1)
+
+/* align up or down to nearest 2^p2 */
+#define ALIGN_DOWN_P2(n, p2) ((n) & ~P2_M1(p2))
+#define ALIGN_UP_P2(n, p2)   ALIGN_DOWN_P2((n) + P2_M1(p2),p2)
+
+#define uintptr_t   unsigned long
+#define CACHEALIGN_BITS (5) /* 2^5 = 32 bytes */
+
+#define CACHEALIGN_UP(x)  ((typeof (x))ALIGN_UP_P2((uintptr_t)(x), CACHEALIGN_BITS))
+/* Aligns at least to the greater of size x or CACHEALIGN_SIZE */
+#define CACHEALIGN_AT_LEAST_ATTR(x)   __attribute__((aligned(CACHEALIGN_UP(x))))
 
-/* allow for 2bpp */
-static char ipod_scr[IPOD_LCD_HEIGHT * (IPOD_LCD_WIDTH/4)];
-
-
-/* get current usec counter */
-static int
-timer_get_current(void)
-{
-	return inl(IPOD_RTC);
-}
-
-/* check if number of useconds has past */
-static int
-timer_check(int clock_start, int usecs)
-{
-	if ( (inl(IPOD_RTC) - clock_start) >= usecs ) {
-		return 1;
-	} else {
-		return 0;
-	}
-}
-
-/* wait for LCD with timeout */
-static void
-lcd_wait_write(void)
-{
-	if ( (inl(IPOD_LCD_BASE) & 0x1) != 0 ) {
-		int start = timer_get_current();
-
-		do {
-			if ( (inl(IPOD_LCD_BASE) & (unsigned int)0x8000) == 0 ) break;
-		} while ( timer_check(start, 1000) == 0 );
-	}
-}
-
-
-/* send LCD data */
-static void
-lcd_send_data(int data_lo, int data_hi)
-{
-	lcd_wait_write();
-	outl(data_lo, 0xc0001010);
-	lcd_wait_write();
-	outl(data_hi, 0xc0001010);
-}
-
-/* send LCD command */
-static void
-lcd_prepare_cmd(int cmd)
-{
-	lcd_wait_write();
-	outl(0x0, 0xc0001008);
-	lcd_wait_write();
-	outl(cmd, 0xc0001008);
-}
-
-/* send LCD command and data */
-static void
-lcd_cmd_and_data(int cmd, int data_lo, int data_hi)
-{
-	lcd_prepare_cmd(cmd);
-
-	lcd_send_data(data_lo, data_hi);
-}
-
-static unsigned
-get_contrast(void)
-{
-	unsigned data_lo, data_hi;
-
-	/* data_lo has the scan line */
-	lcd_wait_write();
-	data_lo = inl(0xc0001008);
-	/* data_hi has the contrast */
-	lcd_wait_write();
-	data_hi = inl(0xc0001008);
-
-	return data_hi & 0xff;
-}
-
-static void
-set_contrast(int contrast)
-{
-	lcd_cmd_and_data(0x4, 0x4, contrast);
-}
-
-static int
-get_backlight(void)
-{
-	return inl(IPOD_LCD_BASE) & 0x2 ? 1 : 0;
-}
-
-static void
-set_backlight(int on)
-{
-	int lcd_state = inl(IPOD_LCD_BASE);
-
-	if (on) {
-		lcd_state = lcd_state | 0x2;
-		outl(lcd_state, IPOD_LCD_BASE);
+#define UNCACHED_BASE_ADDR 0x10000000
+#define UNCACHED_ADDR(a) ((typeof (a))((uintptr_t)(a) | UNCACHED_BASE_ADDR))
 
-		/* display control (1 00 0 1) */
-		/* GSH=01 -> 2/3 level grayscale control */
-		/* GSL=00 -> 1/4 level grayscale control */
-		/* REV=0 -> don't reverse */
-		/* D=1 -> display on */
-		lcd_cmd_and_data(0x7, 0x0, 0x11 /* | 0x2 */);
-	}
-	else {
-		lcd_state = lcd_state & ~0x2;
-		outl(lcd_state, IPOD_LCD_BASE);
+/* allow for 2bpp */
+//#define ipod_scr ipod_scrDriver
+typedef unsigned short fb_data;
 
-		/* display control (10 0 1) */
-		/* GSL=10 -> 2/4 level grayscale control */
-		/* REV=0 -> don't reverse */
-		/* D=1 -> display on */
-		lcd_cmd_and_data(0x7, 0x0, 0x9 /* | 0x2 */);
-	}
-}
+static fb_data ipod_scr[IPOD_LCD_HEIGHT][IPOD_LCD_WIDTH];
+static /*volatile*/ fb_data ipod_scrDriver[IPOD_LCD_HEIGHT][IPOD_LCD_WIDTH]   CACHEALIGN_AT_LEAST_ATTR(16);
 
-static unsigned
-read_controller_id(void)
-{
-	unsigned data_lo, data_hi;
+static int power_on   = 0; /* Is the power turned on?   */
+static int display_on = 0; /* Is the display turned on? */
 
-	/* read the Start Osciallation register -> it gives us a id */
-	lcd_prepare_cmd(0x0);
 
-	lcd_wait_write();
-	data_lo = inl(0xc0001010);
-	lcd_wait_write();
-	data_hi = inl(0xc0001010);
+static void lcd_bus_idle(void)
+{
+   LCD_CLOCK_GPIO |= (1 << LCD_CLOCK_PIN);
+   LCD_DATA_OUT_GPIO |= (1 << LCD_DATA_OUT_PIN);
+}
+
+static void lcd_send_byte(unsigned char byte)
+{
+   
+   int i;
+   
+   for (i = 7; i >=0 ; i--)
+   {
+      LCD_CLOCK_GPIO &= ~(1 << LCD_CLOCK_PIN);
+      if ((byte >> i) & 1)
+      {
+         LCD_DATA_OUT_GPIO |= (1 << LCD_DATA_OUT_PIN);
+      } else {
+         LCD_DATA_OUT_GPIO &= ~(1 << LCD_DATA_OUT_PIN);
+      }
+      udelay(1);
+      LCD_CLOCK_GPIO |= (1 << LCD_CLOCK_PIN);
+      udelay(1);
+      lcd_bus_idle();
+      udelay(3);
+   }
+}
+
+static void lcd_send_msg(unsigned char cmd, unsigned int data)
+{
+   lcd_bus_idle();
+   udelay(1);
+   LCD_CS_GPIO &= ~(1 << LCD_CS_PIN);
+   udelay(10);
+   lcd_send_byte(cmd);
+   lcd_send_byte((unsigned char)(data >> 8));
+   lcd_send_byte((unsigned char)(data & 0xff));
+   LCD_CS_GPIO |= (1 << LCD_CS_PIN);
+   udelay(1);
+   lcd_bus_idle();
+}
+
+static void lcd_write_reg(unsigned int reg, unsigned int data)
+{
+   lcd_send_msg(0x70, reg);
+   lcd_send_msg(0x72, data);
+}
+
+static inline unsigned long phys_fb_address(typeof (ipod_scr) fb)
+{
+   if ((unsigned long)fb < 0x10000000)
+   {
+      return (unsigned long)fb + 0x10000000;
+   }
+   else
+   {
+      return (unsigned long)fb;
+   }
+}
+
+static void lcd_init_gpio(void)
+{
+   GPIOB_ENABLE |= (1<<7);
+   GPIOB_ENABLE |= (1<<5);
+   GPIOB_OUTPUT_EN |= (1<<7);
+   GPIOB_OUTPUT_EN |= (1<<5);
+   GPIOD_ENABLE |= (1<<6);
+   GPIOD_OUTPUT_EN |= (1<<6);
+}
+
+#define HZ 1000000
+#define sleep udelay
+
+/* Run the powerup sequence for the driver IC */
+static void lcd_power_on(void)
+{
+    /* Clear standby bit */
+    lcd_write_reg(R_POWER_CONTROL1, 0x0000);
+
+    /** Power ON Sequence **/
+    lcd_write_reg(R_START_OSC, 0x0001);
+    /* 10ms or more for oscillation circuit to stabilize */
+    sleep(HZ/50);
+
+    /* SAP2-0=100, BT2-0=100, AP2-0=100, DK=1, SLP=0, STB=0 */
+    lcd_write_reg(R_POWER_CONTROL1, 0x4444);
+    /* DC12-10=000, DC2-0=000, VC2-0=001 */
+    lcd_write_reg(R_POWER_CONTROL2, 0x0001);
+    /* PON=0, VRH3-0=0011 */
+    lcd_write_reg(R_POWER_CONTROL3, 0x0003);
+    /* VCOMG=0, VDV4-0=10001, VCM3-0=11001 */
+    lcd_write_reg(R_POWER_CONTROL4, 0x1119);
+    /* PON=1, VRH3-0=0011 */
+    lcd_write_reg(R_POWER_CONTROL3, 0x0013);
+    sleep(HZ/25);
+
+    /* SAP2-0=100, BT2-0=100, AP2-0=100, DK=0, SLP=0, STB=0 */
+    lcd_write_reg(R_POWER_CONTROL1, 0x4440);
+    /* VCOMG=1, VDV4-0=10001, VCM3-0=11001 */
+    lcd_write_reg(R_POWER_CONTROL4, 0x3119);
+    sleep(HZ/6);
+
+    /* VSPL=0, HSPL=0, DPL=1, EPL=0, SM=0, GS=x, SS=x, NL4-0=11011 */
+    lcd_write_reg(R_DRV_OUTPUT_CONTROL, r_drv_output_control);
+    /* FLD=0, FLD0=1, B/C=1, EOR=1, NW5-0=000000 */
+    lcd_write_reg(R_DRV_WAVEFORM_CONTROL, 0x0700);
+    /* TRI=0, DFM1-0=11, BGR=0, HWM=1, ID1-0=10, AM=0, LG2-0=000
+     * AM: horizontal update direction
+     * ID1-0: H decrement, V increment
+     */
+    lcd_write_reg(R_ENTRY_MODE, 0x6038);
+    lcd_write_reg(R_COMPARE_REG1, 0x0000);
+    lcd_write_reg(R_COMPARE_REG2, 0x0000);
+    /* FP3-0=0010, BP3-0=0010 */
+    lcd_write_reg(R_DISP_CONTROL2, 0x0202);
+    /* PTG1-0=00 (normal scan), ISC3-0=0000 (ignored) */
+    lcd_write_reg(R_DISP_CONTROL3, 0x0000);
+    /* NO2-0=01, SDT1-0=00, EQ1-0=01, DIV1-0=00, RTN3-0=0000 */
+    lcd_write_reg(R_FRAME_CYCLE_CONTROL, 0x4400);
+    /* RM=1, DM1-0=01, RIM1-0=00 */
+    lcd_write_reg(R_EXT_DISP_INTF_CONTROL, 0x0110);
+    /* SCN4-0=00000 - G1 if GS=0, G240 if GS=1 */
+    lcd_write_reg(R_GATE_SCAN_START_POS, 0x0000);
+    /* VL7-0=00000000 (0 lines) */
+    lcd_write_reg(R_VERT_SCROLL_CONTROL, 0x0000);
+    /* SE17-10=219, SS17-10=0 - 220 gates */
+    lcd_write_reg(R_1ST_SCR_DRIVE_POS, (219 << 8));
+    /* SE27-10=0, SS27-10=0 - no second screen */
+    lcd_write_reg(R_2ND_SCR_DRIVE_POS, 0x0000);
+    /* HEA=175, HSA=0 = H window from 0-175 */
+    lcd_write_reg(R_HORIZ_RAM_ADDR_POS, (175 << 8));
+    /* VEA=219, VSA=0 = V window from 0-219 */
+    lcd_write_reg(R_VERT_RAM_ADDR_POS, (219 << 8));
+    /* PKP12-10=000, PKP02-00=000 */
+    lcd_write_reg(R_GAMMA_FINE_ADJ_POS1, 0x0000);
+    /* PKP32-30=111, PKP22-20=100 */
+    lcd_write_reg(R_GAMMA_FINE_ADJ_POS2, 0x0704);
+    /* PKP52-50=001, PKP42-40=111 */
+    lcd_write_reg(R_GAMMA_FINE_ADJ_POS3, 0x0107);
+    /* PRP12-10=111, PRP02-00=100 */
+    lcd_write_reg(R_GAMMA_GRAD_ADJ_POS, 0x0704);
+    /* PKN12-10=001, PKN02-00=111 */
+    lcd_write_reg(R_GAMMA_FINE_ADJ_NEG1, 0x0107);
+    /* PKN32-30=000, PKN22-20=010 */
+    lcd_write_reg(R_GAMMA_FINE_ADJ_NEG2, 0x0002);
+    /* PKN52-50=111, PKN42-40=111 */
+    lcd_write_reg(R_GAMMA_FINE_ADJ_NEG3, 0x0707);
+    /* PRN12-10=101, PRN02-00=011 */
+    lcd_write_reg(R_GAMMA_GRAD_ADJ_NEG, 0x0503);
+    /* VRP14-10=00000, VRP03-00=0000 */
+    lcd_write_reg(R_GAMMA_AMP_ADJ_POS, 0x0000);
+    /* WRN14-10=00000, VRN03-00=0000 */
+    lcd_write_reg(R_GAMMA_AMP_ADJ_NEG, 0x0000);
+    /* AD15-0=175 (upper right corner) */
+    lcd_write_reg(R_RAM_ADDR_SET, 0);
+    /* RM=1, DM1-0=01, RIM1-0=00 */
+    lcd_write_reg(R_EXT_DISP_INTF_CONTROL, 0x0110);
+
+    power_on = 1;
+}
+
+/* Run the display on sequence for the driver IC */
+static void lcd_display_on(void)
+{
+    if (!power_on)
+    {
+        /* Power has been turned off so full reinit is needed */
+        lcd_power_on();
+    }
+    else
+    {
+        /* Restore what we fiddled with when turning display off */
+        /* PON=1, VRH3-0=0011 */
+        lcd_write_reg(R_POWER_CONTROL3, 0x0013);
+        /* NO2-0=01, SDT1-0=00, EQ1-0=01, DIV1-0=00, RTN3-0=0000 */
+        lcd_write_reg(R_FRAME_CYCLE_CONTROL, 0x4400);
+        /* VCOMG=1, VDV4-0=10001, VCM3-0=11001 */
+        lcd_write_reg(R_POWER_CONTROL4, 0x3119);
+    }
+
+    /* SAP2-0=100, BT2-0=111, AP2-0=100, DK=1, SLP=0, STB=0 */
+    lcd_write_reg(R_POWER_CONTROL1, 0x4740);
+
+    sleep(HZ/25);
+
+    /* PT1-0=00, VLE2-1=00, SPT=0, IB6(??)=1, GON=0, DTE=0, CL=0,
+       REV=x, D1-0=01 */
+    lcd_write_reg(R_DISP_CONTROL1, 0x0041 | r_disp_control_rev);
+
+    sleep(HZ/30);
+
+    /* PT1-0=00, VLE2-1=00, SPT=0, IB6(??)=1, GON=1, DTE=0, CL=0,
+       REV=x, D1-0=01 */
+    lcd_write_reg(R_DISP_CONTROL1, 0x0061 | r_disp_control_rev);
+    /* PT1-0=00, VLE2-1=00, SPT=0, IB6(??)=1, GON=1, DTE=0, CL=0,
+       REV=x, D1-0=11 */
+    lcd_write_reg(R_DISP_CONTROL1, 0x0063 | r_disp_control_rev);
+
+    sleep(HZ/30);
+
+    /* PT1-0=00, VLE2-1=00, SPT=0, IB6(??)=1, GON=1, DTE=1, CL=0,
+       REV=x, D1-0=11 */
+    lcd_write_reg(R_DISP_CONTROL1, 0x0073 | r_disp_control_rev);
+
+    /* Go into write data mode */
+    lcd_send_msg(0x70, R_RAM_WRITE_DATA);
+
+    /* tell that we're on now */
+    display_on = 1;
+}
+
+/* Turn off visible display operations */
+static void lcd_display_off(void)
+{
+    /* block drawing operations and changing of first */
+    display_on = 0;
+
+    /* NO2-0=01, SDT1-0=00, EQ1-0=00, DIV1-0=00, RTN3-0=0000 */
+    lcd_write_reg(R_FRAME_CYCLE_CONTROL, 0x4000);
+
+    /* PT1-0=00, VLE2-1=00, SPT=0, IB6(??)=1, GON=1, DTE=1, CL=0,
+       REV=x, D1-0=10 */
+    lcd_write_reg(R_DISP_CONTROL1, 0x0072 | r_disp_control_rev);
+
+    sleep(HZ/25);
+
+    /* PT1-0=00, VLE2-1=00, SPT=0, IB6(??)=1, GON=1, DTE=0, CL=0,
+       REV=x, D1-0=10 */
+    lcd_write_reg(R_DISP_CONTROL1, 0x0062 | r_disp_control_rev);
+
+    sleep(HZ/25);
+
+    /* PT1-0=00, VLE2-1=00, SPT=0, IB6(??)=0, GON=0, DTE=0, CL=0,
+       REV=0, D1-0=00 */
+    lcd_write_reg(R_DISP_CONTROL1, 0x0000);
+    /* SAP2-0=000, BT2-0=000, AP2-0=000, DK=0, SLP=0, STBY=0 */
+    lcd_write_reg(R_POWER_CONTROL1, 0x0000);
+    /* PON=0, VRH3-0=0011 */
+    lcd_write_reg(R_POWER_CONTROL3, 0x0003);
+    /* VCOMG=0, VDV4-0=10001, VCM4-0=11001 */
+    lcd_write_reg(R_POWER_CONTROL4, 0x1119);
+}
+
+void lcd_init_device(void)
+{
+/* All this is magic worked out by MrH */
+
+/* Stop any DMA which is in progress */
+    LCD_REG_6 &= ~1;
+    udelay(100000);
+
+/* Init GPIO ports */
+    lcd_init_gpio();
+/* Controller init */
+    GPO32_ENABLE |= (1 << 28);
+    GPO32_VAL &= ~(1 << 28);
+    DEV_INIT1 = ( (DEV_INIT1 & 0x03ffffff) | (0x15 << 26) );
+    outl(((inl(0x70000014) & (0x0fffffff)) | (0x5 << 28)), 0x70000014);
+    outl((inl(0x70000020) & ~(0x3 << 10)), 0x70000020);
+    DEV_EN |= DEV_LCD; /* Enable controller */
+    outl(0x6, 0x600060d0);
+    DEV_RS |= DEV_LCD; /* Reset controller */
+    outl((inl(0x70000020) & ~(1 << 14)), 0x70000020);
+    lcd_bus_idle();
+    DEV_RS &=~DEV_LCD; /* Clear reset */
+    udelay(1000);
+
+    LCD_REG_0 = (LCD_REG_0 & (0x00ffffff)) | (0x22 << 24);
+    LCD_REG_0 = (LCD_REG_0 & (0xff00ffff)) | (0x14 << 16);
+    LCD_REG_0 = (LCD_REG_0 & (0xffffc0ff)) | (0x3 << 8);
+    LCD_REG_0 = (LCD_REG_0 & (0xffffffc0)) | (0xa);
+
+    LCD_REG_1 &= 0x00ffffff;
+    LCD_REG_1 &= 0xff00ffff;
+    LCD_REG_1 = (LCD_REG_1 & 0xffff03ff) | (0x2 << 10);
+    LCD_REG_1 = (LCD_REG_1 & 0xfffffc00) | (0xdd);
+
+    LCD_REG_2 |= (1 << 5);
+    LCD_REG_2 |= (1 << 6);
+    LCD_REG_2 = (LCD_REG_2 & 0xfffffcff) | (0x2 << 8);
+
+    LCD_REG_7 &= (0xf800ffff);
+    LCD_REG_7 &= (0xfffff800);
+
+    LCD_REG_8 = (LCD_REG_8 & (0xf800ffff)) | (0xb0 << 16);
+    LCD_REG_8 = (LCD_REG_8 & (0xfffff800)) | (0xdc); /* X-Y Geometry? */
+
+    LCD_REG_5 |= 0xc;
+    LCD_REG_5 = (LCD_REG_5 & ~(0x70)) | (0x3 << 4);
+    LCD_REG_5 |= 2;
+
+    LCD_REG_6 &= ~(1 << 15);
+    LCD_REG_6 |= (0xe00);
+    LCD_REG_6 = (LCD_REG_6 & (0xffffff1f)) | (0x4 << 5);
+    LCD_REG_6 |= (1 << 4);
+
+    LCD_REG_5 &= ~(1 << 7);
+    LCD_FB_BASE_REG = ((unsigned long)&ipod_scrDriver[0][0] & 0x0fffffff) | 0x10000000; //0x11000000;//phys_fb_address(lcd_driver_framebuffer);
+
+    udelay(100000);
+
+/* LCD init */
+    /* Pull RESET low, then high to reset driver IC */
+    GPO32_VAL &= ~(1 << 28);
+    udelay(10000);
+    GPO32_VAL |= (1 << 28);
+    udelay(10000);
 
-	return ((data_hi & 0xff) << 8) | (data_lo & 0xff);
+    lcd_display_on();
+    LCD_REG_6 |= 1; /* Start DMA */
 }
 
 /* initialise the LCD */
-static void
-init_lcd(void)
-{
-	if ( read_controller_id() != HD66753_ID )  {
-		printk(KERN_ERR "Unknown LCD controller ID: 0x%x id?\n", read_controller_id());
-	}
-
-	/* driver output control - 168x128 -> we use 160x128 */
-	/* CMS=0, SGS=1 */
-	lcd_cmd_and_data(0x1, 0x1, 0xf);
-
-	/* ID=1 -> auto decrement address counter */
-	/* AM=00 -> data is continuously written in parallel */
-	/* LG=00 -> no logical operation */
-	lcd_cmd_and_data(0x5, 0x0, 0x10);
-
-	/* backlight off & set grayscale */
-	set_backlight(0);
-}
-
-
-void contrast_up(void)
-{
-	int contrast = get_contrast();
-	if ( contrast < 0xff ) {
-		contrast++; 
-		lcd_cmd_and_data(0x4, 0x4, contrast);
-
-#if 0
-		printk("ctrst=0x%x\n", get_contrast());
-#endif
-	}
-}
-
-void contrast_down(void)
+static void init_lcd(void)
 {
-	int contrast = get_contrast();
-	if ( contrast > 0 ) {
-		contrast--; 
-		lcd_cmd_and_data(0x4, 0x4, contrast);
-
-#if 0
-		printk("ctrst=0x%x\n", get_contrast());
-#endif
-	}
+   ipod_i2c_init();
+   lcd_init_device();
 }
 
-static void ipod_update_display(struct display *p, int sx, int sy, int mx, int my)
+static void ipod_update_display(struct display *p, int x, int y, int width, int height)
 {
-	unsigned short cursor_pos;
-	unsigned short y;
-
-	cursor_pos = sx + (sy * fontheight(p) * 0x20);
-
-	for ( y = sy * fontheight(p); y < my * fontheight(p); y++ ) {
-		unsigned char *img_data;
-		unsigned char x;
-
-		/* move the cursor */
-		lcd_cmd_and_data(0x11, cursor_pos >> 8, cursor_pos & 0xff);
-
-		/* setup for printing */
-		lcd_prepare_cmd(0x12);
-
-		/* cursor pos * image data width */
-		img_data = &ipod_scr[y * p->line_length + sx * 2];
-
-		/* 160/8 -> 20 == loops 20 times */
-		for ( x = sx; x < mx; x++ ) {
-			/* display a character */
-			lcd_send_data(*(img_data + 1), *img_data);
-
-			img_data += 2;
-		}
-
-		/* update cursor pos counter */
-		cursor_pos += 0x20;
-	}
+    if(display_on)
+    {
+       fb_data *dst, *src;
+       dst = UNCACHED_ADDR(&ipod_scrDriver[0][0]);
+       src = &ipod_scr[0][0];
+
+       memcpy(dst, src, LCD_WIDTH * LCD_HEIGHT * sizeof(fb_data));
+    }
+}
+
+void lcd_sleep(void)
+{
+   LCD_REG_6 &= ~1;
+   sleep(HZ/50);
+   
+   if (power_on)
+   {
+      /* Turn off display */
+      if (display_on)
+         lcd_display_off();
+      
+      power_on = 0;
+   }
+   
+   /* Set standby mode */
+   /* SAP2-0=000, BT2-0=000, AP2-0=000, DK=0, SLP=0, STB=1 */
+   lcd_write_reg(R_POWER_CONTROL1, 0x0001);
+}
+
+void lcd_enable(int on)
+{
+   if (on)
+   {
+      if(!display_on)
+      {
+//         DEV_EN |= DEV_LCD; /* Enable LCD controller */
+         lcd_display_on();  /* Turn on display */
+//         ipod_update_display(NULL, 0, 0, 0, 0);      /* Resync display */
+         LCD_REG_6 |= 1;    /* Restart DMA */
+//         sleep(HZ/50);      /* Wait for a frame to be written */
+      }
+   }
+   else
+   {
+      LCD_REG_6 &= ~1;    /* Disable DMA */
+      sleep(HZ/50);       /* Wait for dma end (assuming 50Hz) */
+      lcd_display_off();  /* Turn off display */
+//      DEV_EN &= ~DEV_LCD; /* Disable LCD controller */
+   }
+}
+
+static int backlightStatus = 1;
+
+static void set_backlight(int on)
+{
+   if(on != backlightStatus)
+   {
+      if(on)
+      {
+         lcd_enable(1);
+         ipod_i2c_lock();
+         ipod_i2c_send(AS3514_I2C_ADDR, DCDC15, DEFAULT_BRIGHTNESS_SETTING);
+         ipod_i2c_unlock();
+         GPIO_SET_BITWISE(GPIOG_OUTPUT_VAL, 0x80);
+      }
+      else
+      {
+         GPIO_CLEAR_BITWISE(GPIOG_OUTPUT_VAL, 0x80);
+         ipod_i2c_lock();
+         ipod_i2c_send(AS3514_I2C_ADDR, DCDC15, 0x0);
+         ipod_i2c_unlock();
+         lcd_enable(0);
+         lcd_sleep();
+      }
+      backlightStatus = on;
+   }
 }
 
 struct ipodfb_info {
@@ -285,40 +575,40 @@
 
 void ipod_fb_setup(struct display *p)
 {
-	fbcon_cfb2.setup(p);
+	fbcon_cfb16.setup(p);
 }
 
 void ipod_fb_bmove(struct display *p, int sy, int sx, int dy, int dx,
 		     int height, int width)
 {
-	fbcon_cfb2.bmove(p, sy, sx, dy, dx, height, width);
+	fbcon_cfb16.bmove(p, sy, sx, dy, dx, height, width);
 	ipod_update_display(p, 0, 0, IPOD_LCD_WIDTH/8, IPOD_LCD_HEIGHT/fontheight(p));
 }
 
 void ipod_fb_clear(struct vc_data *conp, struct display *p, int sy, int sx,
 		     int height, int width)
 {
-	fbcon_cfb2.clear(conp, p, sy, sx, height, width);
+	fbcon_cfb16.clear(conp, p, sy, sx, height, width);
 	ipod_update_display(p, sx, sy, sx+width, sy+height);
 }
 
 void ipod_fb_putc(struct vc_data *conp, struct display *p, int c, int yy,
 		    int xx)
 {
-	fbcon_cfb2.putc(conp, p, c, yy, xx);
+	fbcon_cfb16.putc(conp, p, c, yy, xx);
 	ipod_update_display(p, xx, yy, xx+1, yy+1);
 }
 
 void ipod_fb_putcs(struct vc_data *conp, struct display *p, 
 		     const unsigned short *s, int count, int yy, int xx)
 {
-	fbcon_cfb2.putcs(conp, p, s, count, yy, xx);
+	fbcon_cfb16.putcs(conp, p, s, count, yy, xx);
 	ipod_update_display(p, xx, yy, xx+count, yy+1);
 }
 
 void ipod_fb_revc(struct display *p, int xx, int yy)
 {
-	fbcon_cfb2.revc(p, xx, yy);
+	fbcon_cfb16.revc(p, xx, yy);
 	ipod_update_display(p, xx, yy, xx+1, yy+1);
 }
 
@@ -378,12 +668,12 @@
 	strcpy(fix->id, "iPod");
 	/* required for mmap() */
 	fix->smem_start = ipod_scr;
-	fix->smem_len = IPOD_LCD_HEIGHT * (IPOD_LCD_WIDTH/4);
+	fix->smem_len = IPOD_LCD_HEIGHT * IPOD_LCD_WIDTH * 2;
 
 	fix->type= FB_TYPE_PACKED_PIXELS;
 
-	fix->visual = FB_VISUAL_PSEUDOCOLOR;	/* fixed visual */
-	fix->line_length = IPOD_LCD_WIDTH >> 2;	/* cfb2 default */
+	fix->visual = FB_VISUAL_TRUECOLOR; //FB_VISUAL_DIRECTCOLOR; //FB_VISUAL_PSEUDOCOLOR;	/* fixed visual */
+	fix->line_length = IPOD_LCD_WIDTH * 2;	/* cfb2 default */
 
 	fix->xpanstep = 0;	/* no hardware panning */
 	fix->ypanstep = 0;	/* no hardware panning */
@@ -415,7 +705,7 @@
 		return -EINVAL;
 	}
 
-	if ( var->bits_per_pixel != 2 ) {
+	if ( var->bits_per_pixel != 16 ) {
 		return -EINVAL;
 	}
 
@@ -437,8 +727,7 @@
 	var->xoffset = 0;
 	var->yoffset = 0;
 
-	var->bits_per_pixel = 2;
-	var->grayscale = 1;
+	var->bits_per_pixel = 16;
 
 	return 0;
 }
@@ -513,7 +802,7 @@
 static int ipod_blank(int blank_mode, const struct fb_info *info)
 {
 	static int backlight_on = -1;
-
+#if 0
 	switch (blank_mode) {
 	case VESA_NO_BLANKING:
 		/* printk(KERN_ERR "VESA_NO_BLANKING\n"); */
@@ -563,7 +852,7 @@
 		/* printk(KERN_ERR "unknown blank value %d\n", blank_mode); */
 		return -EINVAL;
 	}
-
+#endif
 	return 0;
 }
 
@@ -632,20 +921,14 @@
 
 	switch (cmd) {
 	case FBIOGET_CONTRAST:
-		val = get_contrast();
-		if (put_user(val, (int *)arg))
-			return -EFAULT;
+		val = IPOD_MAX_CONTRAST;
 		break;
 
 	case FBIOPUT_CONTRAST:
-		val = (int)arg;
-		if (val < IPOD_MIN_CONTRAST || val > IPOD_MAX_CONTRAST)
-			return -EINVAL;
-		set_contrast(val);
 		break;
 
 	case FBIOGET_BACKLIGHT:
-		val = get_backlight();
+		val = backlightStatus;
 		if (put_user(val, (int *)arg))
 			return -EFAULT;
 		break;
@@ -690,7 +973,9 @@
 
 int __init ipodfb_init(void)
 {
-	fb_info.gen.fbhw = &ipod_switch;
+   int i,j;
+
+   fb_info.gen.fbhw = &ipod_switch;
 
 	fb_info.gen.fbhw->detect();
 
diff -urN arch/armnommu/mach-ipod/hardware.c arch/armnommu/mach-ipod/hardware.c
--- arch/armnommu/mach-ipod/hardware.c	2008-10-10 03:49:22.000000000 -0400
+++ arch/armnommu/mach-ipod/hardware.c	2008-10-10 03:43:42.000000000 -0400
@@ -1,7 +1,7 @@
 /*
  * hardware.c - special hardware routines for iPod
  *
- * Copyright (c) 2003,2004 Bernard Leach <leachbj@bouncycastle.org>
+ * Copyright (c) 2003-2008 Bernard Leach, Bernard Leach, Rockbox
  */
 
 #include <linux/config.h>
@@ -14,29 +14,25 @@
 #include <asm/io.h>
 #include <asm/hardware.h>
 #include <asm/system.h>
-
-#define SYSINFO_TAG     (unsigned char *)0x40017f18
-#define SYSINFO_PTR     (struct sysinfo_t **)0x40017f1c
+#include "pp5020.h"
+#include "as3514.h"
 
 static struct sysinfo_t ipod_sys_info;
 static int ipod_sys_info_set;
 
 void ipod_set_sys_info(void);
+int ipod_i2c_readbyte(unsigned int dev_addr, int addr);
+
 
-/*
- * 3rd generation (docking) 0x30000, 0x30001
- * 2nd generation (touch wheel) 0x20000, 0x20001
- * 1st generation (scroll wheel) iPods 0x10000, 0x10001, 0x10002
- * failed 0x0
- */
 unsigned ipod_get_hw_version(void)
 {
+   return 0x60000;
 	if (!ipod_sys_info_set) {
 		ipod_set_sys_info();
 	}
 
 	if (ipod_sys_info_set > 0) {
-		return ipod_sys_info.boardHwSwInterfaceRev;
+		return system_rev;
 	}
 
 	return 0x0;
@@ -55,184 +51,134 @@
 	return 0x0;
 }
 
+int ipod_is_pp5022(void) {
+	return (inl(0x70000000) << 8) >> 24 == '2';
+}
+
 void ipod_set_sys_info(void)
 {
+#if 0
 	if (!ipod_sys_info_set) {
-		if ( *(unsigned *)SYSINFO_TAG == *(unsigned *)"IsyS" 
-				&& (*SYSINFO_PTR)->IsyS ==  *(unsigned *)"IsyS" ) {
-			memcpy(&ipod_sys_info, *SYSINFO_PTR, sizeof(struct sysinfo_t));
+		unsigned sysinfo_tag = SYSINFO_TAG;
+		struct sysinfo_t ** sysinfo_ptr = SYSINFO_PTR;
+
+		if (ipod_is_pp5022()) {
+			sysinfo_tag = SYSINFO_TAG_PP5022;
+			sysinfo_ptr = SYSINFO_PTR_PP5022;
+		}
+
+		if (*(unsigned *)sysinfo_tag == *(unsigned *)"IsyS" 
+				&& (*(struct sysinfo_t **)sysinfo_ptr)->IsyS ==  *(unsigned *)"IsyS" ) {
+			memcpy(&ipod_sys_info, *sysinfo_ptr, sizeof(struct sysinfo_t));
 			ipod_sys_info_set = 1;
-			system_rev = ipod_sys_info.boardHwSwInterfaceRev;
+			/* magic length based on newer ipod nano sysinfo */
+			if (ipod_sys_info.len == 0xf8) {
+				system_rev = ipod_sys_info.sdram_zero2;
+			} else {
+				system_rev = ipod_sys_info.boardHwSwInterfaceRev;
+			}
 		}
 		else {
 			ipod_sys_info_set = -1;
 		}
 	}
+#endif
 }
 
 void ipod_hard_reset(void)
 {
-	outl(inl(0xcf005030) | 0x4, 0xcf005030);
-}
-
-/* make startup piezo noise */
-void ipod_startup_noise(void)
-{
-	int i1, i2;
+   ipod_i2c_lock();
+   CACHE_CTL &= ~CACHE_CTL_VECT_REMAP;
 
-	outl(0x80, 0xc000604c);
+   ipod_i2c_send(AS3514_I2C_ADDR, DCDC15, 0x0); /* backlight off */
 
-	/* set divisor low word */
-	outl(0xd, 0xc0006040);
-
-	outl(0x3, 0xc000604c);
-
-	outl(0x3, 0xc0006050);
-	outl(0x7, 0xc0006048);
-
-	for ( i1 = 0; i1 < 500; i1++ ) {
-		outl(0x0, 0xc0006040);
-
-		/* delay for a bit */
-		for ( i2 = 0; i2 < i1; i2++ ) {
-			/* empty */
-		}
-	}
-}
-
-/* wait for action button to be pressed and then released */
-void
-wait_for_action(void)
-{
-	/* wait for press */
-	do {
-		inl(0xcf000030);
-	} while ( (inl(0xcf000030) & 0x2) != 0 );
-
-	/* wait for release */
-	do {
-		inl(0xcf000030);
-	} while ( (inl(0xcf000030) & 0x2) == 0 );
+   /* Magic used by the c200 OF: 0x23066000
+    Magic used by the c200 BL: 0x23066b7b
+    In both cases, the OF executes these 2 commands from iram. */
+   STRAP_OPT_A = 0x23066b7b;
+   DEV_RS = DEV_SYSTEM;
+}
+
+void ipod_power_off(void)
+{
+   char byte;
+   
+   ipod_i2c_lock();
+   /* Mask them on both cores */
+   CPU_INT_CLR = -1;
+   COP_INT_CLR = -1;
+   
+   /* Send shutdown command to PMU */
+   byte = i2c_readbyte(AS3514_I2C_ADDR, SYSTEM);
+   byte &= ~0x1;   
+   ipod_i2c_send(AS3514_I2C_ADDR, SYSTEM, byte);
+   
+   /* Halt everything and wait for device to power off */
+   while (1)
+   {
+      CPU_CTL = PROC_SLEEP;
+      COP_CTL = PROC_SLEEP;
+   }
 }
 
 void
 ipod_init_cache(void)
 {
 	unsigned i;
-
-	outl(inl(0xcf004050) & ~0x700, 0xcf004050);
-	outl(0x4000, 0xcf004020);
-
-	outl(0x2, 0xcf004024);
+	/* cache init mode? */
+	outl(0x4, 0x6000C000);
 
 	/* PP5002 has 8KB cache */
 	for (i = 0xf0004000; i < 0xf0006000; i += 16) {
 		outl(0x0, i);
 	}
 
-	outl(0x0, 0xf000f020);
-	outl(0x3fc0, 0xf000f024);
+	outl(0x0, 0xf000f040);
+	outl(0x3fc0, 0xf000f044);
+
+	/* enable cache */
+	outl(0x1, 0x6000C000);
 
-	outl(0x3, 0xcf004024);
+	for (i = 0x10000000; i < 0x10002000; i += 16) {
+		inb(i);
+	}
 }
 
+extern void (*pm_power_off)(void);
+
 void
 ipod_set_cpu_speed(void)
 {
-	outl(0x02, 0xcf005008);
-
-	outl(0x55, 0xcf00500c);
-	outl(0x6000, 0xcf005010);
-
-#if 1
-	// 75  MHz (24/24 * 75) (default)
-	outl(24, 0xcf005018);
-	outl(75, 0xcf00501c);
-#endif
-
-#if 0
-	// 66 MHz (24/3 * 8)
-	outl(3, 0xcf005018);
-	outl(8, 0xcf00501c);
-#endif
-
-	outl(0xe000, 0xcf005010);
-
-	udelay(2000);
-
-	outl(0xa8, 0xcf00500c);
+   DEV_RS2 |= 0x20;
+   DEV_RS = 0x3bfffef8;
+   DEV_RS2 = -1;
+   DEV_RS = 0;
+   DEV_RS2 = 0;
+   outl(inl(0x6000a000) | 0x80000000, 0x6000a000); /* Init DMA controller? */
+
+   
+   DEV_INIT2 |= 1 << 30; /* enable PLL power */
+
+   CLOCK_SOURCE = 0x10007772;  /* source #1: 24MHz, #2, #3, #4: PLL */
+   DEV_TIMING1  = 0x00000303;
+   PLL_CONTROL  = 0x8a121403;  /* (20/3 * 24MHz) / 2 */
+   udelay(250);
+   while (!(PLL_STATUS & 0x80000000)); /* wait for relock */
+
+   DEV_TIMING1 = 0x00000808;
+   CLOCK_SOURCE = (CLOCK_SOURCE & ~0xf0000000) | 0x20000000;  /* select source #2 */
+
+   pm_power_off = ipod_power_off;
 }
 
-static void
-set_boot_variable(unsigned *dest, char *src, unsigned len)
-{
-	if ( !(((unsigned)dest | (unsigned)src) & 0x3 ) ) {
-
-		unsigned lr = 0x01010101;
-
-		unsigned ip;
-		unsigned t;
-
-		do {
-			if ( len < 4 ) break;
 
-			ip = *(unsigned *)src;
-			*dest = ip;
-
-			dest ++;
-			src += 4;
-			len -= 4;
-
-			/* this magic checks for embedded nulls */
-			t = ip - lr;
-			t = t & ~ip;
-		} while ( (t & (lr << 7)) == 0 );
-	}
-
-	if ( len == 0 ) return;
-
-	{
-		char ip;
-
-		do {
-			ip = *src++;
-			*((char *)dest)++ = ip;
-			if ( ip == 0 ) break;
-			len--;
-		} while ( len != 0 );
-
-		if ( len <= 1 ) return;
-	}
-
-	len --;
-
-	do {
-		*((unsigned char *)dest)++ = '\0';
-		len--;
-	} while ( len != 0 );
-}
-
-void
-ipod_reboot_to_diskmode(void)
-{
-	/* select new mode and icon to show during boot */
-	set_boot_variable((unsigned *)0x40017f00, "diskmode", 8);
-	set_boot_variable((unsigned *)0x40017f08, "hotstuff", 8);
-
-	/* do special startup? */
-	outl(0x1, 0x40017f10);
-
-	/* reset */
-	outl(inl(0xcf005030) | 0x4, 0xcf005030);
-}
-
-#define IPOD_I2C_CTRL	0xc0008000
-#define IPOD_I2C_ADDR	0xc0008004
-#define IPOD_I2C_DATA0	0xc000800c
-#define IPOD_I2C_DATA1	0xc0008010
-#define IPOD_I2C_DATA2	0xc0008014
-#define IPOD_I2C_DATA3	0xc0008018
-#define IPOD_I2C_STATUS	0xc000801c
+#define IPOD_I2C_CTRL	(ipod_i2c_base+0x00)
+#define IPOD_I2C_ADDR	(ipod_i2c_base+0x04)
+#define IPOD_I2C_DATA0	(ipod_i2c_base+0x0c)
+#define IPOD_I2C_DATA1	(ipod_i2c_base+0x10)
+#define IPOD_I2C_DATA2	(ipod_i2c_base+0x14)
+#define IPOD_I2C_DATA3	(ipod_i2c_base+0x18)
+#define IPOD_I2C_STATUS	(ipod_i2c_base+0x1c)
 
 /* IPOD_I2C_CTRL bit definitions */
 #define IPOD_I2C_SEND	0x80
@@ -242,6 +188,9 @@
 
 #define POLL_TIMEOUT (HZ)
 
+static unsigned ipod_i2c_base;
+struct semaphore i2c_lock_mutex;
+
 static int
 ipod_i2c_wait_not_busy(void)
 {
@@ -254,7 +203,6 @@
 		}
 		yield();
 	}
-
 	return -ETIMEDOUT;
 }
 
@@ -263,13 +211,59 @@
 {
 	static int i2c_init = 0;
 
-	if (i2c_init == 0) {
+	if (i2c_init == 0) 
+   {
 		i2c_init = 1;
+      init_MUTEX(&i2c_lock_mutex);
+
+    DEV_EN |= DEV_I2C;  /* Enable I2C */
+    DEV_RS |= DEV_I2C;  /* Start I2C Reset */
+    DEV_RS &=~DEV_I2C;  /* End I2C Reset */
+
+    outl(0x0, 0x600060a4);
+    outl(0x23, 0x600060a4);
+
+    ipod_i2c_base = 0x7000c000;
+
+    i2c_readbyte(0x8, 0);
+	}
+}
+
+static int
+ipod_i2c_read_byte(unsigned int addr, unsigned int *data)
+{
+	if (ipod_i2c_wait_not_busy() < 0) {
+		return -ETIMEDOUT;
+	}
 
-		/* reset I2C */
-                outl(inl(0xcf005030) | (1<<8), 0xcf005030);
-		outl(inl(0xcf005030) & ~(1<<8), 0xcf005030);
+	// clear top 15 bits, left shift 1, or in 0x1 for a read
+	outb(((addr << 17) >> 16) | 0x1, IPOD_I2C_ADDR);
+
+	outb(inb(IPOD_I2C_CTRL) | 0x20, IPOD_I2C_CTRL);
+
+	outb(inb(IPOD_I2C_CTRL) | IPOD_I2C_SEND, IPOD_I2C_CTRL);
+
+	if (ipod_i2c_wait_not_busy() < 0) {
+		return -ETIMEDOUT;
+	}
+
+	if (data) {
+		*data = inb(IPOD_I2C_DATA0);
 	}
+
+	return 0;
+}
+
+int ipod_i2c_readbytes(unsigned int dev_addr, int addr, int len, unsigned char *data) {
+   unsigned int temp;
+   int i;
+   ipod_i2c_send_byte(dev_addr, addr);
+   for (i = 0; i < len; i++) {
+      ipod_i2c_read_byte(dev_addr, &temp);
+//      i2c_readbyte(dev_addr, &temp);
+      data[i] = temp;
+   }
+   return i;
 }
 
 int
@@ -316,63 +310,61 @@
 	return ipod_i2c_send_bytes(addr, 2, data);
 }
 
+int
+ipod_i2c_send_byte(unsigned int addr, int data0)
+{
+	unsigned char data[1];
+
+	data[0] = data0;
+
+	return ipod_i2c_send_bytes(addr, 1, data);
+}
+
+int
+i2c_readbyte(unsigned int dev_addr, int addr)
+{
+	int data;
+
+	ipod_i2c_send_byte(dev_addr, addr);
+	ipod_i2c_read_byte(dev_addr, &data);
+
+   return data;
+}
+
+void ipod_i2c_lock()
+{
+   down(&i2c_lock_mutex);
+}
+
+void ipod_i2c_unlock()
+{
+   up(&i2c_lock_mutex);
+}
+
+
 void
 ipod_serial_init(void)
 {
-	int hw_ver = ipod_get_hw_version() >> 16;
+}
+
+/* put our ptr in on chip ram to avoid caching problems */
+static ipod_dma_handler_t * ipod_dma_handler = DMA_HANDLER;
+
+static ipod_cop_handler_t * ipod_cop_handler = COP_HANDLER;
 
-	/* enable ttyS1 (piezo) */
-	outl(inl(0xcf004040) & ~(1<<12), 0xcf004040);
-	if (hw_ver == 0x3) {
-		/* port c, bit 0 and 3 disabled */
-		outl(inl(0xcf00000c) & ~((1<<0)|(1<<3)), 0xcf00000c);
-	}
-
-	if (hw_ver == 0x3) {
-		/* 100100010001, 11,8,4,0 */
-		// outl(0x911, 0xcf004040);
-		/* 1000000000011100, 16,4,3,2 */
-		// outl(0x801c, 0xcf004048);
-
-		outl(inl(0xcf004040) | (1<<8) | (1<<4), 0xcf004040);
-		outl(0x801c, 0xcf004048);
-	}
-	else {
-		/* 011110010001, 10,9,8,7,4,0 */
-		// outl(0x791, 0xcf004040);
-	}
-
-	/* enable ttyS0 (remote) */
-	if (hw_ver != 0x3) {
-		outl(inl(0xcf00000c) & ~0x8, 0xcf00000c);
-	}
-
-	/* 3g ttyS0 init */
-	if (hw_ver == 0x3) {
-		ipod_i2c_send(0x8, 0x24, 0xf5);
-		ipod_i2c_send(0x8, 0x25, 0xf8);
-		ipod_i2c_send(0x8, 0x26, 0xf5);
-		ipod_i2c_send(0x8, 0x34, 0x02);
-		ipod_i2c_send(0x8, 0x1b, 0xf9);
-
-		// sub_0_2800147C(0)
-		outl(inl(0xcf004044) | (1<<4), 0xcf004044);
-		outl(inl(0xcf004048) & ~(1<<4), 0xcf004048);
-
-		/* port c bit 3 output 1 */
-		// sub_0_28001434(1)
-		outl(inl(0xcf000008) | (1<<3), 0xcf000008);
-		outl(inl(0xcf000018) | (1<<3), 0xcf000018);
-		outl(inl(0xcf000028) | (1<<3), 0xcf000028);
-
-		// rmt_uart_init
-		outl(inl(0xcf00000c) & ~0x1, 0xcf00000c);
-		outl(inl(0xcf00000c) & ~0x8, 0xcf00000c);
+
+void ipod_handle_cop(void)
+{
+	if (*ipod_cop_handler != 0) {
+		(*ipod_cop_handler)();
 	}
 }
 
-/* put our ptr in on chip ram to avoid caching problems */
-static ipod_dma_handler_t * ipod_dma_handler = SYSINFO_TAG;
+void ipod_set_handle_cop(ipod_cop_handler_t new_handler)
+{
+	*ipod_cop_handler = new_handler;
+}
+
 
 void ipod_set_process_dma(ipod_dma_handler_t new_handler)
 {
@@ -388,9 +380,12 @@
 
 EXPORT_SYMBOL(ipod_get_hw_version);
 EXPORT_SYMBOL(ipod_get_sysinfo);
+EXPORT_SYMBOL(ipod_is_pp5022);
 EXPORT_SYMBOL(ipod_i2c_init);
 EXPORT_SYMBOL(ipod_i2c_send_bytes);
 EXPORT_SYMBOL(ipod_i2c_send);
+EXPORT_SYMBOL(ipod_i2c_send_byte);
 EXPORT_SYMBOL(ipod_serial_init);
 EXPORT_SYMBOL(ipod_set_process_dma);
+EXPORT_SYMBOL(ipod_set_handle_cop);
 
diff -urN arch/armnommu/mach-ipod/irq.c arch/armnommu/mach-ipod/irq.c
--- arch/armnommu/mach-ipod/irq.c	2008-10-10 03:49:22.000000000 -0400
+++ arch/armnommu/mach-ipod/irq.c	2008-10-10 03:43:42.000000000 -0400
@@ -6,11 +6,16 @@
 
 #include <linux/config.h>
 #include <linux/version.h>
+#include <linux/kernel.h>
 #include <asm/io.h>
 #include <asm/mach/irq.h>
 #include <asm/irq.h>
+#include <asm/timex.h>
 
-static void ipod_unmask_irq(unsigned int irq)
+#include "pp5020.h"
+
+/* PP5002 functions */
+static void pp5002_unmask_irq(unsigned int irq)
 {
 	/* unmask the interrupt */
 	outl((1 << irq), 0xcf001024);
@@ -18,58 +23,130 @@
 	outl(inl(0xcf00102c) & ~(1 << irq), 0xcf00102c);
 }
 
-static void ipod_mask_irq(unsigned int irq)
+static void pp5002_mask_irq(unsigned int irq)
 {
 	/* mask the interrupt */
 	outl((1 << irq), 0xcf001028);
 }
 
-static void ipod_mask_ack_irq(unsigned int irq)
+static void pp5002_mask_ack_irq(unsigned int irq)
 {
 
 	/* there is no general IRQ ack, we have to do it at the source */
 	switch (irq) {
-	case IDE_INT0_IRQ:
+	case PP5002_IDE_IRQ:
 		/* clear FIFO interrupt status */
 		outl(0xff, 0xc0003020);
 		outl(inl(0xc0003024) | (1<<4) | (1<<5), 0xc0003024);
 		break;
 
-	case TIMER1_IRQ:
-		inl(0xcf001104);
+	case PP5002_TIMER1_IRQ:
+		inl(PP5002_TIMER1_ACK);
 		break;
 	}
 
-	ipod_mask_irq(irq);
+	pp5002_mask_irq(irq);
+}
+
+/* PP5020 functions */
+static void pp5020_unmask_irq(unsigned int irq)
+{
+	switch (irq) {
+	case PP5020_IDE_IRQ:
+		outl(inl(0xc3000028) | (1<<5), 0xc3000028);
+	}
+
+	if (irq < 32) {
+		outl((1 << irq), 0x60004024);
+	}
+	else {
+		/* hi interrupt enable */
+		outl(0x40000000, 0x60004024);
+
+		outl((1 << (irq - 32)), 0x60004124);
+	}
+}
+
+static void pp5020_mask_irq(unsigned int irq)
+{
+	/* mask the interrupt */
+	if (irq < 32) {
+		outl((1 << irq), 0x60004028);
+	}
+	else {
+		outl((1 << (irq - 32)), 0x60004128);
+	}
+}
+
+static void pp5020_mask_ack_irq(unsigned int irq)
+{
+	/* there is no general IRQ ack, we have to do it at the source */
+	switch (irq) {
+	case PP5020_TIMER1_IRQ:
+		inl(PP5020_TIMER1_ACK);
+		break;
+
+	case PP5020_IDE_IRQ:
+		outl(inl(0xc3000028) & ~((1<<4) | (1<<5)), 0xc3000028);
+		break;
+	}
+
+	pp5020_mask_irq(irq);
 }
 
 int ipod_init_irq(void)
 {
-	unsigned int irq;
+	int irq;
+
 
 	/* disable all interrupts */
-	outl(-1, 0xcf00101c);
-	outl(-1, 0xcf001028);
-	outl(-1, 0xcf001038);
+/*		outl(-1, 0x60001138);
+		outl(-1, 0x60001128);
+		outl(-1, 0x6000111c);
+
+		outl(-1, 0x60001038);
+		outl(-1, 0x60001028);
+		outl(-1, 0x6000101c);
+*/
+   COP_HI_INT_CLR      = -1;
+   CPU_HI_INT_CLR      = -1;
+   HI_INT_FORCED_CLR   = -1;
+   
+   COP_INT_CLR         = -1;
+   CPU_INT_CLR         = -1;
+   INT_FORCED_CLR      = -1;
+   
+   GPIOA_INT_EN        = 0;
+   GPIOB_INT_EN        = 0;
+   GPIOC_INT_EN        = 0;
+   GPIOD_INT_EN        = 0;
+   GPIOE_INT_EN        = 0;
+   GPIOF_INT_EN        = 0;
+   GPIOG_INT_EN        = 0;
+   GPIOH_INT_EN        = 0;
+   GPIOI_INT_EN        = 0;
+   GPIOJ_INT_EN        = 0;
+   GPIOK_INT_EN        = 0;
+   GPIOL_INT_EN        = 0;
 
 	/* clear all interrupts */
 	for ( irq = 0; irq < NR_IRQS; irq++ ) {
 
-		if (!VALID_IRQ(irq)) continue;
+			if (!PP5020_VALID_IRQ(irq)) continue;
 
 		irq_desc[irq].valid     = 1;
 		irq_desc[irq].probe_ok  = 1;
-		irq_desc[irq].mask_ack  = ipod_mask_ack_irq;
-		irq_desc[irq].mask      = ipod_mask_irq;
-		irq_desc[irq].unmask    = ipod_unmask_irq;
+		irq_desc[irq].mask_ack  = pp5020_mask_ack_irq;
+		irq_desc[irq].mask      = pp5020_mask_irq;
+		irq_desc[irq].unmask    = pp5020_unmask_irq;
 	}
 
 	/*
 	 * since the interrupt vectors at 0x0 are now installed
 	 * we can wake up the COP safely
 	 */
-	outl(0xce, 0xcf004058);
+	outl(0x0, 0x60007004);
 
-        return 0;
+   return 0;
 }
 
diff -urN arch/armnommu/mach-ipod/keyboard.c arch/armnommu/mach-ipod/keyboard.c
--- arch/armnommu/mach-ipod/keyboard.c	2008-10-10 03:49:22.000000000 -0400
+++ arch/armnommu/mach-ipod/keyboard.c	2008-10-12 00:43:16.000000000 -0400
@@ -1,7 +1,8 @@
 /*
  * keyboard.c - keyboard driver for iPod
  *
- * Copyright (c) 2003,2004 Bernard Leach (leachbj@bouncycastle.org)
+ * taken from Rockbox and modified 
+ *
  */
 
 #include <linux/module.h>
@@ -14,232 +15,490 @@
 #include <linux/mm.h>
 #include <linux/kbd_kern.h>
 #include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/miscdevice.h>
+#include <linux/poll.h>
 #include <asm/io.h>
 #include <asm/arch/irqs.h>
 #include <asm/keyboard.h>
 #include <asm/hardware.h>
+#include <asm/uaccess.h>
+
+#include "pp5020.h"
+
 
-/* undefine these to produce keycodes from left/right/up/down */
-#undef DO_SCROLLBACK
-#undef DO_CONTRAST
-#undef USE_ARROW_KEYS
+#define TIME_AFTER(a,b)		((long)(b) - (long)(a) < 0)
+#define TIME_BEFORE(a,b)	TIME_AFTER(b,a)
+#define current_tick		(signed)(USEC_TIMER/10000)
+
+#define BUTTON_SCROLL_BACK	0x00000080
+#define BUTTON_SCROLL_FWD	0x00000100
+
+#define BUTTON_NONE		0
+#define BUTTON_REL		0x02000000
+#define BUTTON_REPEAT		0x04000000
+#define BUTTON_TOUCHPAD		0x08000000
+
+#define WHEEL_REPEAT_INTERVAL	300000
+#define WHEEL_FAST_ON_INTERVAL	20000
+#define WHEEL_FAST_OFF_INTERVAL	60000
+#define WHEELCLICKS_PER_ROTATION 96
+
+/* Clickwheel */
+static unsigned	int	old_wheel_value		= 0;
+static unsigned	int	wheel_repeat		= 0;
+static unsigned	int	wheel_click_count	= 0;
+static unsigned	int	wheel_delta		= 0;
+static		int	wheel_fast_mode		= 0;
+static unsigned	long	last_wheel_usec		= 0;
+static unsigned	long	wheel_velocity		= 0;
+static		long	last_wheel_post		= 0;
+static		long	next_backlight_on	= 0;
+/* Buttons */
+static		int	hold_button		= 0;
+static unsigned	int	int_btn			= 0x7f;
 
 /* we use the keycodes and translation is 1 to 1 */
-#define R_SC		19	/* 'r' */
-#define L_SC		38	/* 'l' */
+#define R_SC		KEY_R
+#define L_SC		KEY_L
 
-#if defined(USE_ARROW_KEYS)
-#define UP_SC		103
-#define LEFT_SC		105
-#define RIGHT_SC	106
-#define DOWN_SC		108
-#else
-#define UP_SC		50	/* 'm' */
-#define LEFT_SC		17	/* 'w' */
-#define RIGHT_SC	33	/* 'f' */
-#define DOWN_SC		32	/* 'd' */
-#endif
-
-#define ACTION_SC	28	/* '\n' */
-
-/* send ^S and ^Q for the hold switch */
-#define LEFT_CTRL_SC	29
-#define Q_SC		16
-#define S_SC		31
+#define UP_SC		KEY_M
+#define LEFT_SC		KEY_W
+#define RIGHT_SC	KEY_F
+#define DOWN_SC		KEY_D
+
+#define HOLD_SC		KEY_H
+#define REC_SC		KEY_C
+#define POWER_SC	KEY_P
+#define ACTION_SC	KEY_ENTER
 
 /* need to pass something becuase we use a shared irq */
-#define KEYBOARD_DEV_ID	0x4b455942
+#define KEYBOARD_DEV_ID	(void *)0x4b455942
 
 static unsigned ipod_hw_ver;
 
-static void keyboard_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+#define EV_SCROLL	0x1000
+#define EV_TAP		0x2000
+#define EV_PRESS	0x4000
+#define EV_RELEASE	0x8000
+#define EV_TOUCH	0x0100
+#define EV_LIFT		0x0200
+#define EV_MASK		0xff00
+
+#define BTN_ACTION	0x0001
+#define BTN_NEXT	0x0002
+#define BTN_PREVIOUS	0x0004
+#define BTN_PLAY	0x0008
+#define BTN_MENU	0x0010
+#define BTN_HOLD	0x0020
+#define BTN_REC		0x0040
+#define BTN_POWER	0x0080
+#define BTN_MASK	0x00ff
+
+#define SCROLL_LEFT	0x0080
+#define SCROLL_RIGHT	0x0000
+#define SCROLL(dist)	((dist) < 0? (-(dist) & 0x7f) | SCROLL_LEFT : (dist) & 0x7f)
+#define SCROLL_MASK	0x007f
+
+/*
+ * We really want to restrict it to less-than-0x60,
+ * but that's not a power of 2 so 0x5f doesn't work as mask.
+ * We'll settle for 0x7f, since the val should never get
+ * above 0x5f in hardware anyway.
+ */
+#define TAP(loc)	((loc) & 0x7f)
+#define TOUCH(loc)	((loc) & 0x7f)
+#define LIFT(loc)	((loc) & 0x7f)
+#define TAP_MASK	0x007f
+#define TOUCH_MASK	0x007f
+#define LIFT_MASK	0x007f
+
+static volatile int ikb_reading;
+static volatile int ikb_opened;
+static volatile unsigned short ikb_events[32];
+static volatile unsigned ikb_ev_head, ikb_ev_tail;
+
+static volatile unsigned ikb_pressed_at; /* jiffy value when user touched wheel, 0 if not touching. */
+static volatile unsigned ikb_first_loc; /* location where user first touched wheel */
+static volatile int ikb_current_scroll; /* current scroll distance */
+static volatile unsigned ikb_buttons_pressed, ikb_buttons_pressed_new; /* mask of BTN_* values */
+
+static DECLARE_WAIT_QUEUE_HEAD (ikb_read_wait);
+
+static void ikb_push_event (unsigned ev) 
 {
-	static int prev_scroll = -1;
-	unsigned char source, state;
-	static int was_hold = 0;
+	if (!ikb_opened) return;
+	
+	if ((ikb_ev_head+1 == ikb_ev_tail) || (ikb_ev_head == 31 && ikb_ev_tail == 0))
+		printk (KERN_ERR "dropping event %08x\n", ev);
+	
+	ikb_events[ikb_ev_head++] = ev;
+	ikb_ev_head &= 31;
+	wake_up_interruptible (&ikb_read_wait);
+}
 
-	/* we need some delay for g3, cause hold generates several interrupts,
-	 * some of them delayed
-	 */
-	if (ipod_hw_ver == 0x3) {
-		udelay(250);
+/* Turn the counter into a scroll event. */
+static void ikb_make_scroll_event (void)
+{
+	if (ikb_current_scroll) {
+		ikb_push_event (EV_SCROLL | SCROLL(ikb_current_scroll));
+		ikb_current_scroll = 0;
 	}
+}
 
-	/* get source of interupts */
-	source = inb(0xcf000040);
-	if ( source == 0 ) {
-		return; 	/* not for us */
-	}
+static void ikb_scroll (int dir) 
+{
+	ikb_current_scroll += dir;
 
-	/* get current keypad status */
-	state = inb(0xcf000030);
-	outb(~state, 0xcf000060);
+	while (dir > 0) {
+		handle_scancode (R_SC, 1);
+		handle_scancode (R_SC, 0);
+		dir--;
+	}
 
-	if (ipod_hw_ver == 0x3) {
-		if (was_hold && source == 0x40 && state == 0xbf) {
-			/* ack any active interrupts */
-			outb(source, 0xcf000070);
-			return;
-		}
-		was_hold = 0;
+	while (dir < 0) {
+		handle_scancode (L_SC, 1);
+		handle_scancode (L_SC, 0);
+		dir++;
 	}
 
-#ifdef CONFIG_VT
-	kbd_pt_regs = regs;
+	if (ikb_reading)
+		ikb_make_scroll_event();
+}
 
-	if ( source & 0x20 ) {
-		if ((ipod_hw_ver == 0x3 && (state & 0x20) == 0 ) || 
-				(state & 0x20)) {
-			/* CTRL-S down */
-			handle_scancode(LEFT_CTRL_SC, 1);
-			handle_scancode(S_SC, 1);
-
-			/* CTRL-S up */
-			handle_scancode(S_SC, 0);
-			handle_scancode(LEFT_CTRL_SC, 0);
-		}
-		else {
-			/* CTRL-Q down */
-			handle_scancode(LEFT_CTRL_SC, 1);
-			handle_scancode(Q_SC, 1);
-
-			/* CTRL-Q up */
-			handle_scancode(Q_SC, 0);
-			handle_scancode(LEFT_CTRL_SC, 0);
-			if (ipod_hw_ver == 0x3) {
-				was_hold = 1;
+static void handle_scroll_wheel(int new_scroll, int was_hold, int reverse)
+{
+	static int prev_scroll = -1;
+	static int scroll_state[4][4] = {
+		{0, 1, -1, 0},
+		{-1, 0, 0, 1},
+		{1, 0, 0, -1},
+		{0, -1, 1, 0}
+	};
+
+	if ( prev_scroll == -1 ) {
+		prev_scroll = new_scroll;
+	}
+	else if (!was_hold) {
+		switch (scroll_state[prev_scroll][new_scroll]) {
+		case 1:
+			if (reverse) {
+				/* 'r' keypress */
+				ikb_scroll (1);
 			}
-		}
-		/* hold switch on 3g causes all outputs to go low */
-		/* we shouldn't interpret these as key presses */
-		if (ipod_hw_ver == 0x3) {
-			goto done;
+			else {
+				/* 'l' keypress */
+				ikb_scroll (-1);
+			}
+			break;
+		case -1:
+			if (reverse) {
+				/* 'l' keypress */
+				ikb_scroll (-1);
+			}
+			else {
+				/* 'r' keypress */
+				ikb_scroll (1);
+			}
+			break;
+		default:
+			/* only happens if we get out of sync */
+			break;
 		}
 	}
 
-	if ( source & 0x1 ) {
-		if ( state & 0x1 ) {
-#if defined(DO_SCROLLBACK)
-			scrollfront(0);
-#else
-			handle_scancode(RIGHT_SC, 0);
-#endif
-		}
-#if !defined(DO_SCROLLBACK)
-		else {
-			handle_scancode(RIGHT_SC, 1);
-		}
-#endif
+	prev_scroll = new_scroll;
+}
+
+static void ikb_handle_button (int button, int press) 
+{
+	int sc;
+
+	if (press)
+		ikb_buttons_pressed_new |= button;
+	else
+		ikb_buttons_pressed_new &= ~button;
+	
+	/* Send the code to the TTY driver too */
+	switch (button) {
+	case BTN_ACTION:
+		sc = ACTION_SC;
+		break;
+	case BTN_PREVIOUS:
+		sc = DOWN_SC;
+		break;
+	case BTN_NEXT:
+		sc = UP_SC;
+		break;
+	case BTN_MENU:
+		sc = LEFT_SC;
+		break;
+	case BTN_PLAY:
+		sc = RIGHT_SC;
+		break;
+	case BTN_HOLD:
+		sc = HOLD_SC;
+		break;
+	case BTN_REC:
+		sc = REC_SC;
+		break;
+	case BTN_POWER:
+		sc = POWER_SC;
+		break;
+	default:
+		sc = 0;
+		break;
 	}
-	if ( source & 0x2 ) {
-		if ( state & 0x2 ) {
-			handle_scancode(ACTION_SC, 0);
-		}
-		else {
-			handle_scancode(ACTION_SC, 1);
-		}
+
+	if (sc)
+		handle_scancode (sc, press);
+}
+
+static void ikb_start_buttons (void)
+{
+	ikb_buttons_pressed_new = ikb_buttons_pressed;
+}
+
+static void ikb_finish_buttons (void)
+{
+	/* Pressed: */
+	if (ikb_buttons_pressed_new & ~ikb_buttons_pressed) {
+		ikb_push_event (EV_PRESS | (ikb_buttons_pressed_new & ~ikb_buttons_pressed));
+	}
+	/* Released: */
+	if (ikb_buttons_pressed & ~ikb_buttons_pressed_new) {
+		ikb_push_event (EV_RELEASE | (ikb_buttons_pressed & ~ikb_buttons_pressed_new));
 	}
+	
+	ikb_buttons_pressed = ikb_buttons_pressed_new;
+}
 
-	if ( source & 0x4 ) {
-		if ( state & 0x4 ) {
-#if defined(DO_CONTRAST)
-			contrast_down();
-#else
-			handle_scancode(DOWN_SC, 0);
-#endif
+static ssize_t ikb_read (struct file *file, char *buf, size_t nbytes, loff_t *ppos) 
+{
+	DECLARE_WAITQUEUE (wait, current);
+	ssize_t retval = 0, count = 0;
+	
+	if (nbytes == 0) return 0;
+
+	ikb_make_scroll_event();
+	ikb_reading = 1;
+
+	add_wait_queue (&ikb_read_wait, &wait);
+	while (nbytes > 0) {
+		int ev;
+
+		set_current_state (TASK_INTERRUPTIBLE);
+
+		if (ikb_ev_head == ikb_ev_tail) {
+			if (file->f_flags & O_NONBLOCK) {
+				retval = -EAGAIN;
+				break;
+			}
+			if (signal_pending (current)) {
+				retval = -ERESTARTSYS;
+				break;
+			}
+			schedule();
+			continue;
 		}
-#if !defined(DO_CONTRAST)
-		else {
-			handle_scancode(DOWN_SC, 1);
+		
+		for (ev = ikb_ev_tail; ev != ikb_ev_head && nbytes >= 2; ikb_ev_tail++, ikb_ev_tail &= 31, ev = ikb_ev_tail) {
+			put_user (ikb_events[ev], (unsigned short *)buf);
+			count += 2;
+			buf += 2;
+			nbytes -= 2;
 		}
-#endif
+
+		break; /* only read as much as we have */
 	}
-	if ( source & 0x8 ) {
-		if ( state & 0x8 ) {
-#if defined(DO_SCROLLBACK)
-			scrollback(0);
-#else
-			handle_scancode(LEFT_SC, 0);
-#endif
-		}
-#if !defined(DO_SCROLLBACK)
-		else {
-			handle_scancode(LEFT_SC, 1);
+
+	ikb_reading = 0;
+	current->state = TASK_RUNNING;
+	remove_wait_queue (&ikb_read_wait, &wait);
+
+	return (count? count : retval);
+}
+
+static unsigned int ikb_poll (struct file *file, poll_table *wait) 
+{
+	unsigned int mask = 0;
+	poll_wait (file, &ikb_read_wait, wait);
+	if (ikb_ev_head != ikb_ev_tail)
+		mask |= POLLIN | POLLRDNORM;
+	return mask;
+}
+
+/*
+ * We allow multiple opens, even though multiple readers will compete for events,
+ * since usually one reader is in wait() for the other to complete.
+ * (It's no worse than a bog-standard TTY device.)
+ */
+static int ikb_open (struct inode *inode, struct file *file) 
+{
+	MOD_INC_USE_COUNT;
+	ikb_opened++;
+	return 0;
+}
+
+static int ikb_release (struct inode *inode, struct file *file) 
+{
+	ikb_opened--;
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+static struct file_operations ikb_fops = {
+	read:		ikb_read,
+	poll:		ikb_poll,
+	open:		ikb_open,
+	release:	ikb_release,
+};
+static struct miscdevice ikb_misc = { MISC_DYNAMIC_MINOR, "wheel", &ikb_fops };
+
+void clickwheel_int(void)
+{
+	/* Read wheel 
+	 * Bits 6 and 7 of GPIOH change as follows:
+	 * Clockwise rotation	01 -> 00 -> 10 -> 11
+	 * Counter-clockwise	11 -> 10 -> 00 -> 01
+	 *
+	 * This is equivalent to wheel_value of:
+	 * Clockwise rotation	0x40 -> 0x00 -> 0x80 -> 0xc0
+	 * Counter-clockwise	0xc0 -> 0x80 -> 0x00 -> 0x40
+	 */
+	static const unsigned char wheel_tbl[2][4] =
+	{
+		/* 0x00  0x40  0x80  0xc0 */ /* Wheel value		*/
+		{ 0x40, 0xc0, 0x00, 0x80 }, /* Clockwise rotation */
+		{ 0x80, 0x00, 0xc0, 0x40 }, /* Counter-clockwise  */ 
+	};
+
+	unsigned int wheel_value;
+
+	wheel_value = GPIOH_INPUT_VAL & 0xc0;
+	GPIOH_INT_LEV = (GPIOH_INT_LEV & ~0xc0) | (wheel_value ^ 0xc0);
+	GPIOH_INT_CLR = GPIOH_INT_STAT & 0xc0;
+
+	if (!hold_button)
+	{
+		unsigned int btn = BUTTON_NONE;
+		if (old_wheel_value == wheel_tbl[0][wheel_value >> 6])
+		{
+			btn = BUTTON_SCROLL_FWD;
+			ikb_scroll (1);
+		}
+		else if (old_wheel_value == wheel_tbl[1][wheel_value >> 6])
+		{
+			btn = BUTTON_SCROLL_BACK;
+			ikb_scroll (-1);
 		}
-#endif
 	}
-	if ( source & 0x10 ) {
-		if ( state & 0x10 ) {
-#if defined(DO_CONTRAST)
-			contrast_up();
-#else
-			handle_scancode(UP_SC, 0);
-#endif
-		}
-#if !defined(DO_CONTRAST)
-		else {
-			handle_scancode(UP_SC, 1);
-		}
-#endif
+
+	old_wheel_value = wheel_value;
+}
+
+/* device buttons */
+void button_int()
+{	
+	int newHold;
+	unsigned char state;
+	unsigned int newBtn;
+
+	state = GPIOF_INPUT_VAL & 0xff;
+
+	newHold = (state & 0x80) != 0;
+	if(newHold != hold_button)
+	{
+		if(newHold)
+		  ikb_handle_button (BTN_HOLD, 1);
+		else
+		  ikb_handle_button (BTN_HOLD, 0);
+
+		hold_button = newHold;
 	}
 
-	if ( source & 0xc0 ) {
-		static int scroll_state[4][4] = {
-			{0, 1, -1, 0},
-			{-1, 0, 0, 1},
-			{1, 0, 0, -1},
-			{0, -1, 1, 0}
-		};
-		unsigned now_scroll = (state & 0xc0) >> 6;
-						
-		if ( prev_scroll == -1 ) {
-			prev_scroll = now_scroll;
-		}
-		else {
-			switch (scroll_state[prev_scroll][now_scroll]) {
-			case 1:
-				/* 'l' keypress */
-				handle_scancode(L_SC, 1);
-				handle_scancode(L_SC, 0);
-				break;
-			case -1:
-				/* 'r' keypress */
-				handle_scancode(R_SC, 1);
-				handle_scancode(R_SC, 0);
-				break;
-			default:
-				/* only happens if we get out of sync */
-				break;
-			}
-		}
 
-		prev_scroll = now_scroll;
+	if (!hold_button)
+	{
+		newBtn = int_btn ^ (state & 0x7f);
+		if ((newBtn & 0x01) != 0)
+			ikb_handle_button (BTN_REC, (state & 0x01) == 0);
+		if ((newBtn & 0x02) != 0)
+			ikb_handle_button (BTN_PLAY, (state & 0x02) == 0);
+		if ((newBtn & 0x04) != 0)
+			ikb_handle_button (BTN_NEXT, (state & 0x04) == 0);
+		if ((newBtn & 0x08) != 0)
+			ikb_handle_button (BTN_PREVIOUS, (state & 0x08) == 0);
+		if ((newBtn & 0x10) != 0)
+			ikb_handle_button (BTN_ACTION, (state & 0x10) == 0);
+		if ((newBtn & 0x20) != 0)
+			ikb_handle_button (BTN_MENU, (state & 0x20) == 0);
+		if ((newBtn & 0x40) != 0)
+			ikb_handle_button (BTN_POWER, (state & 0x40) == 0);
+		int_btn = (state & 0x7f);
 	}
-done:
+	GPIOF_INT_LEV = (GPIOF_INT_LEV & ~0xff) | (state ^ 0xff);
+	GPIOF_INT_CLR = GPIOF_INT_STAT;
+}
+
+void keyboard_int(int irq, void *dev_id, struct pt_regs *regs)
+{
+
+	ikb_start_buttons();
+
+	if(regs != NULL)
+		kbd_pt_regs = regs;
 
-	tasklet_schedule(&keyboard_tasklet);
-#endif /* CONFIG_VT */
+	if (GPIOF_INT_STAT & 0xff)
+		button_int();
+	if (GPIOH_INT_STAT & 0xc0)
+		clickwheel_int();
 
-	/* ack any active interrupts */
-	outb(source, 0xcf000070);
+	tasklet_schedule(&keyboard_tasklet);  
+	ikb_finish_buttons();
 }
 
 void __init ipodkb_init_hw(void)
 {
-	outb(~inb(0xcf000030), 0xcf000060);
-	outb(inb(0xcf000040), 0xcf000070);
+	/* Enable all buttons */
+	GPIOF_OUTPUT_EN &= ~0xff;
+	GPIOF_ENABLE |= 0xff;
+
+	/* Scrollwheel light - enable control through GPIOG pin 7 and set timeout */
+	GPIOG_OUTPUT_EN |= 0x80;
+	GPIOG_ENABLE = 0x80;
+
+	/* Mask these before performing init ... because init has possibly
+		occurred before */
+	GPIOF_INT_EN &= ~0xff;
+	GPIOH_INT_EN &= ~0xc0;
+
+	/* Get current tick before enabling button interrupts */
+	last_wheel_usec = USEC_TIMER;
+	last_wheel_post = last_wheel_usec;
+
+	GPIOH_ENABLE |= 0xc0;
+	GPIOH_OUTPUT_EN &= ~0xc0;
+
+	/* Read initial buttons */
+	button_int();
+	GPIOF_INT_CLR = 0xff;
 
-	outb(inb(0xcf000004) | 0x1, 0xcf000004);
-	outb(inb(0xcf000014) | 0x1, 0xcf000014);
-	outb(inb(0xcf000024) | 0x1, 0xcf000024);
+	/* Read initial wheel value (bit 6-7 of GPIOH) */
+	old_wheel_value = GPIOH_INPUT_VAL & 0xc0;
+	GPIOH_INT_LEV = (GPIOH_INT_LEV & ~0xc0) | (old_wheel_value ^ 0xc0);
+	GPIOH_INT_CLR = 0xc0;
 
-	if ( request_irq(GPIO_IRQ, keyboard_interrupt, SA_SHIRQ, "keyboard", KEYBOARD_DEV_ID) ) {
-		printk("ipodkb: IRQ %d failed\n", GPIO_IRQ);
+	if (request_irq(PP5020_GPIO1_IRQ, keyboard_int, SA_SHIRQ, "keyboard", KEYBOARD_DEV_ID)) {
+		printk("ipoddkb: IRQ %d failed\n", PP5020_GPIO1_IRQ);
 	}
 
-	outb(0xff, 0xcf000050);
+	/* Enable button interrupts */
+	GPIOF_INT_EN |= 0xff;
+	GPIOH_INT_EN |= 0xc0;
 
-	/* get our hardware type */
-	ipod_hw_ver = ipod_get_hw_version() >> 16;
+	misc_register (&ikb_misc);
 }
 
diff -urN arch/armnommu/mach-ipod/pp5020.h arch/armnommu/mach-ipod/pp5020.h
--- arch/armnommu/mach-ipod/pp5020.h	1969-12-31 19:00:00.000000000 -0500
+++ arch/armnommu/mach-ipod/pp5020.h	2008-10-10 03:43:42.000000000 -0400
@@ -0,0 +1,527 @@
+/***************************************************************************
+ *             __________               __   ___.
+ *   Open      \______   \ ____   ____ |  | _\_ |__   _______  ___
+ *   Source     |       _//  _ \_/ ___\|  |/ /| __ \ /  _ \  \/  /
+ *   Jukebox    |    |   (  <_> )  \___|    < | \_\ (  <_> > <  <
+ *   Firmware   |____|_  /\____/ \___  >__|_ \|___  /\____/__/\_ \
+ *                     \/            \/     \/    \/            \/
+ * $Id: pp5020.h 15758 2007-11-22 20:51:00Z zagor $
+ *
+ * Copyright (C) 2004 by Thom Johansen 
+ *
+ * All files in this archive are subject to the GNU General Public License.
+ * See the file COPYING in the source tree root for full license agreement.
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
+ * KIND, either express or implied.
+ *
+ ****************************************************************************/
+#ifndef __PP5020_H__
+#define __PP5020_H__
+
+/* All info gleaned and/or copied from the iPodLinux project. */
+
+/* DRAM starts at 0x10000000, but in Rockbox we remap it to 0x00000000 */
+#define DRAM_START       0x10000000
+
+/* Processor ID */
+#define PROCESSOR_ID     (*(volatile unsigned long *)(0x60000000))
+
+#define PROC_ID_CPU      0x55
+#define PROC_ID_COP      0xaa
+
+/* Mailboxes */
+#define MBX_BASE            (0x60001000)
+/* Read bits in the mailbox */
+#define MBX_MSG_STAT        (*(volatile unsigned long *)(0x60001000))
+/* Set bits in the mailbox */
+#define MBX_MSG_SET         (*(volatile unsigned long *)(0x60001004))
+/* Clear bits in the mailbox */
+#define MBX_MSG_CLR         (*(volatile unsigned long *)(0x60001008))
+/* Doesn't seem to be COP_REPLY at all :) */
+#define MBX_UNKNOWN1        (*(volatile unsigned long *)(0x6000100c))
+/* COP can set bit 29 - only CPU read clears it */
+#define CPU_QUEUE           (*(volatile unsigned long *)(0x60001010))
+/* CPU can set bit 29 - only COP read clears it */
+#define COP_QUEUE           (*(volatile unsigned long *)(0x60001020))
+
+#define PROC_QUEUE(core)    ((&CPU_QUEUE)[(core)*4])
+
+/* Interrupts */
+#define CPU_INT_STAT        (*(volatile unsigned long*)(0x60004000))
+#define COP_INT_STAT        (*(volatile unsigned long*)(0x60004004))
+#define CPU_FIQ_STAT        (*(volatile unsigned long*)(0x60004008))
+#define COP_FIQ_STAT        (*(volatile unsigned long*)(0x6000400c))
+
+#define INT_STAT            (*(volatile unsigned long*)(0x60004010))
+#define INT_FORCED_STAT     (*(volatile unsigned long*)(0x60004014))
+#define INT_FORCED_SET      (*(volatile unsigned long*)(0x60004018))
+#define INT_FORCED_CLR      (*(volatile unsigned long*)(0x6000401c))
+
+#define CPU_INT_EN_STAT     (*(volatile unsigned long*)(0x60004020))
+#define CPU_INT_EN          (*(volatile unsigned long*)(0x60004024))
+#define CPU_INT_CLR         (*(volatile unsigned long*)(0x60004028))
+#define CPU_INT_PRIORITY    (*(volatile unsigned long*)(0x6000402c))
+
+#define COP_INT_EN_STAT     (*(volatile unsigned long*)(0x60004030))
+#define COP_INT_EN          (*(volatile unsigned long*)(0x60004034))
+#define COP_INT_CLR         (*(volatile unsigned long*)(0x60004038))
+#define COP_INT_PRIORITY    (*(volatile unsigned long*)(0x6000403c))
+
+#define CPU_HI_INT_STAT     (*(volatile unsigned long*)(0x60004100))
+#define COP_HI_INT_STAT     (*(volatile unsigned long*)(0x60004104))
+#define CPU_HI_FIQ_STAT     (*(volatile unsigned long*)(0x60004108))
+#define COP_HI_FIQ_STAT     (*(volatile unsigned long*)(0x6000410c))
+
+#define HI_INT_STAT         (*(volatile unsigned long*)(0x60004110))
+#define HI_INT_FORCED_STAT  (*(volatile unsigned long*)(0x60004114))
+#define HI_INT_FORCED_SET   (*(volatile unsigned long*)(0x60004118))
+#define HI_INT_FORCED_CLR   (*(volatile unsigned long*)(0x6000411c))
+
+#define CPU_HI_INT_EN_STAT  (*(volatile unsigned long*)(0x60004120))
+#define CPU_HI_INT_EN       (*(volatile unsigned long*)(0x60004124))
+#define CPU_HI_INT_CLR      (*(volatile unsigned long*)(0x60004128))
+#define CPU_HI_INT_PRIORITY (*(volatile unsigned long*)(0x6000412c))
+ 
+#define COP_HI_INT_EN_STAT  (*(volatile unsigned long*)(0x60004130))
+#define COP_HI_INT_EN       (*(volatile unsigned long*)(0x60004134))
+#define COP_HI_INT_CLR      (*(volatile unsigned long*)(0x60004138))
+#define COP_HI_INT_PRIORITY (*(volatile unsigned long*)(0x6000413c))
+
+#define TIMER1_IRQ   0
+#define TIMER2_IRQ   1
+#define MAILBOX_IRQ  4
+#define IIS_IRQ      10
+#define USB_IRQ      20
+#define IDE_IRQ      23
+#define FIREWIRE_IRQ 25
+#define HI_IRQ       30
+#define GPIO0_IRQ    (32+0) /* Ports A..D */
+#define GPIO1_IRQ    (32+1) /* Ports E..H */
+#define GPIO2_IRQ    (32+2) /* Ports I..L */
+#define SER0_IRQ     (32+4)
+#define SER1_IRQ     (32+5)
+#define I2C_IRQ      (32+8)
+
+#define TIMER1_MASK   (1 << TIMER1_IRQ)
+#define TIMER2_MASK   (1 << TIMER2_IRQ)
+#define MAILBOX_MASK  (1 << MAILBOX_IRQ)
+#define IIS_MASK      (1 << IIS_IRQ)
+#define IDE_MASK      (1 << IDE_IRQ)
+#define USB_MASK      (1 << USB_IRQ)
+#define FIREWIRE_MASK (1 << FIREWIRE_IRQ)
+#define HI_MASK       (1 << HI_IRQ)
+#define GPIO0_MASK    (1 << (GPIO0_IRQ-32))
+#define GPIO1_MASK    (1 << (GPIO1_IRQ-32))
+#define GPIO2_MASK    (1 << (GPIO2_IRQ-32))
+#define SER0_MASK     (1 << (SER0_IRQ-32))
+#define SER1_MASK     (1 << (SER1_IRQ-32))
+#define I2C_MASK      (1 << (I2C_IRQ-32))
+
+/* Timers */
+#define TIMER1_CFG   (*(volatile unsigned long *)(0x60005000))
+#define TIMER1_VAL   (*(volatile unsigned long *)(0x60005004))
+#define TIMER2_CFG   (*(volatile unsigned long *)(0x60005008))
+#define TIMER2_VAL   (*(volatile unsigned long *)(0x6000500c))
+#define USEC_TIMER   (*(volatile unsigned long *)(0x60005010))
+#define RTC          (*(volatile unsigned long *)(0x60005014))
+
+/* Device Controller */
+#define DEV_RS       (*(volatile unsigned long *)(0x60006004))
+#define DEV_RS2      (*(volatile unsigned long *)(0x60006008))
+#define DEV_EN       (*(volatile unsigned long *)(0x6000600c))
+#define DEV_EN2      (*(volatile unsigned long *)(0x60006010))
+
+#define DEV_SYSTEM      0x00000004
+#define DEV_SER0        0x00000040
+#define DEV_SER1        0x00000080
+#define DEV_I2S         0x00000800
+#define DEV_I2C         0x00001000
+#define DEV_ATA         0x00004000
+#define DEV_OPTO        0x00010000
+#define DEV_PIEZO       0x00010000
+#define DEV_USB         0x00400000
+#define DEV_FIREWIRE    0x00800000
+#define DEV_IDE0        0x02000000
+#define DEV_LCD         0x04000000
+
+/* clock control */
+#define CLOCK_SOURCE    (*(volatile unsigned long *)(0x60006020))
+#define MLCD_SCLK_DIV   (*(volatile unsigned long *)(0x6000602c))
+        /* bits 0..1: Mono LCD bridge serial clock divider: 1 / (n+1) */
+#define PLL_CONTROL     (*(volatile unsigned long *)(0x60006034))
+#define PLL_STATUS      (*(volatile unsigned long *)(0x6000603c))
+#define ADC_CLOCK_SRC   (*(volatile unsigned long *)(0x60006094))
+#define CLCD_CLOCK_SRC  (*(volatile unsigned long *)(0x600060a0))
+
+/* Processors Control */
+#define CPU_CTL          (*(volatile unsigned long *)(0x60007000))
+#define COP_CTL          (*(volatile unsigned long *)(0x60007004))
+#define PROC_CTL(core)   ((&CPU_CTL)[core])
+
+#define PROC_SLEEP     0x80000000
+#define PROC_WAIT      0x40000000
+#define PROC_WAIT_CLR  0x20000000
+#define PROC_CNT_START 0x08000000
+#define PROC_WAKE      0x00000000
+/**
+ * This is based on some quick but sound experiments on PP5022C.
+ * CPU/COP_CTL bitmap:
+ *   [31] - sleep until an interrupt occurs
+ *   [30] - wait for cycle countdown to 0
+ *   [29] - wait for cycle countdown to 0
+ *          behaves identically to bit 30 unless bit 30 is set as well
+ *          in which case this bit is cleared at the end of the count
+ *   [28] - unknown - no execution effect observed yet
+ *   [27] - begin cycle countdown
+ * [26:8] - semaphore flags for core communication ?
+ *          no execution effect observed yet
+ *          [11:8] seem to often be set to the core's own ID
+ *                 nybble when sleeping - 0x5 or 0xa.
+ *  [7:0] - W: number of cycles to skip on next instruction
+ *          R: cycles remaining
+ * Executing on CPU
+ *   CPU_CTL = 0x68000080
+ *   nop
+ * stalls the nop for 128 cycles
+ * Reading CPU_CTL after the nop will return 0x48000000
+ */
+
+/* Cache Control */
+#define CACHE_PRIORITY   (*(volatile unsigned long *)(0x60006044))
+#define CACHE_CTL        (*(volatile unsigned long *)(0x6000c000))
+#define CACHE_MASK       (*(volatile unsigned long *)(0xf000f040))
+#define CACHE_OPERATION  (*(volatile unsigned long *)(0xf000f044))
+#define CACHE_FLUSH_MASK (*(volatile unsigned long *)(0xf000f048))
+
+/* CACHE_CTL bits */
+#define CACHE_CTL_DISABLE    0x0000
+#define CACHE_CTL_ENABLE     0x0001
+#define CACHE_CTL_RUN        0x0002
+#define CACHE_CTL_INIT       0x0004
+#define CACHE_CTL_VECT_REMAP 0x0010
+#define CACHE_CTL_READY      0x4000
+#define CACHE_CTL_BUSY       0x8000
+/* CACHE_OPERATION bits */
+#define CACHE_OP_FLUSH       0x0002
+#define CACHE_OP_INVALIDATE  0x0004
+
+/* GPIO Ports */
+#define GPIOA_ENABLE     (*(volatile unsigned long *)(0x6000d000))
+#define GPIOB_ENABLE     (*(volatile unsigned long *)(0x6000d004))
+#define GPIOC_ENABLE     (*(volatile unsigned long *)(0x6000d008))
+#define GPIOD_ENABLE     (*(volatile unsigned long *)(0x6000d00c))
+#define GPIOA_OUTPUT_EN  (*(volatile unsigned long *)(0x6000d010))
+#define GPIOB_OUTPUT_EN  (*(volatile unsigned long *)(0x6000d014))
+#define GPIOC_OUTPUT_EN  (*(volatile unsigned long *)(0x6000d018))
+#define GPIOD_OUTPUT_EN  (*(volatile unsigned long *)(0x6000d01c))
+#define GPIOA_OUTPUT_VAL (*(volatile unsigned long *)(0x6000d020))
+#define GPIOB_OUTPUT_VAL (*(volatile unsigned long *)(0x6000d024))
+#define GPIOC_OUTPUT_VAL (*(volatile unsigned long *)(0x6000d028))
+#define GPIOD_OUTPUT_VAL (*(volatile unsigned long *)(0x6000d02c))
+#define GPIOA_INPUT_VAL  (*(volatile unsigned long *)(0x6000d030))
+#define GPIOB_INPUT_VAL  (*(volatile unsigned long *)(0x6000d034))
+#define GPIOC_INPUT_VAL  (*(volatile unsigned long *)(0x6000d038))
+#define GPIOD_INPUT_VAL  (*(volatile unsigned long *)(0x6000d03c))
+#define GPIOA_INT_STAT   (*(volatile unsigned long *)(0x6000d040))
+#define GPIOB_INT_STAT   (*(volatile unsigned long *)(0x6000d044))
+#define GPIOC_INT_STAT   (*(volatile unsigned long *)(0x6000d048))
+#define GPIOD_INT_STAT   (*(volatile unsigned long *)(0x6000d04c))
+#define GPIOA_INT_EN     (*(volatile unsigned long *)(0x6000d050))
+#define GPIOB_INT_EN     (*(volatile unsigned long *)(0x6000d054))
+#define GPIOC_INT_EN     (*(volatile unsigned long *)(0x6000d058))
+#define GPIOD_INT_EN     (*(volatile unsigned long *)(0x6000d05c))
+#define GPIOA_INT_LEV    (*(volatile unsigned long *)(0x6000d060))
+#define GPIOB_INT_LEV    (*(volatile unsigned long *)(0x6000d064))
+#define GPIOC_INT_LEV    (*(volatile unsigned long *)(0x6000d068))
+#define GPIOD_INT_LEV    (*(volatile unsigned long *)(0x6000d06c))
+#define GPIOA_INT_CLR    (*(volatile unsigned long *)(0x6000d070))
+#define GPIOB_INT_CLR    (*(volatile unsigned long *)(0x6000d074))
+#define GPIOC_INT_CLR    (*(volatile unsigned long *)(0x6000d078))
+#define GPIOD_INT_CLR    (*(volatile unsigned long *)(0x6000d07c))
+
+#define GPIOE_ENABLE     (*(volatile unsigned long *)(0x6000d080))
+#define GPIOF_ENABLE     (*(volatile unsigned long *)(0x6000d084))
+#define GPIOG_ENABLE     (*(volatile unsigned long *)(0x6000d088))
+#define GPIOH_ENABLE     (*(volatile unsigned long *)(0x6000d08c))
+#define GPIOE_OUTPUT_EN  (*(volatile unsigned long *)(0x6000d090))
+#define GPIOF_OUTPUT_EN  (*(volatile unsigned long *)(0x6000d094))
+#define GPIOG_OUTPUT_EN  (*(volatile unsigned long *)(0x6000d098))
+#define GPIOH_OUTPUT_EN  (*(volatile unsigned long *)(0x6000d09c))
+#define GPIOE_OUTPUT_VAL (*(volatile unsigned long *)(0x6000d0a0))
+#define GPIOF_OUTPUT_VAL (*(volatile unsigned long *)(0x6000d0a4))
+#define GPIOG_OUTPUT_VAL (*(volatile unsigned long *)(0x6000d0a8))
+#define GPIOH_OUTPUT_VAL (*(volatile unsigned long *)(0x6000d0ac))
+#define GPIOE_INPUT_VAL  (*(volatile unsigned long *)(0x6000d0b0))
+#define GPIOF_INPUT_VAL  (*(volatile unsigned long *)(0x6000d0b4))
+#define GPIOG_INPUT_VAL  (*(volatile unsigned long *)(0x6000d0b8))
+#define GPIOH_INPUT_VAL  (*(volatile unsigned long *)(0x6000d0bc))
+#define GPIOE_INT_STAT   (*(volatile unsigned long *)(0x6000d0c0))
+#define GPIOF_INT_STAT   (*(volatile unsigned long *)(0x6000d0c4))
+#define GPIOG_INT_STAT   (*(volatile unsigned long *)(0x6000d0c8))
+#define GPIOH_INT_STAT   (*(volatile unsigned long *)(0x6000d0cc))
+#define GPIOE_INT_EN     (*(volatile unsigned long *)(0x6000d0d0))
+#define GPIOF_INT_EN     (*(volatile unsigned long *)(0x6000d0d4))
+#define GPIOG_INT_EN     (*(volatile unsigned long *)(0x6000d0d8))
+#define GPIOH_INT_EN     (*(volatile unsigned long *)(0x6000d0dc))
+#define GPIOE_INT_LEV    (*(volatile unsigned long *)(0x6000d0e0))
+#define GPIOF_INT_LEV    (*(volatile unsigned long *)(0x6000d0e4))
+#define GPIOG_INT_LEV    (*(volatile unsigned long *)(0x6000d0e8))
+#define GPIOH_INT_LEV    (*(volatile unsigned long *)(0x6000d0ec))
+#define GPIOE_INT_CLR    (*(volatile unsigned long *)(0x6000d0f0))
+#define GPIOF_INT_CLR    (*(volatile unsigned long *)(0x6000d0f4))
+#define GPIOG_INT_CLR    (*(volatile unsigned long *)(0x6000d0f8))
+#define GPIOH_INT_CLR    (*(volatile unsigned long *)(0x6000d0fc))
+
+#define GPIOI_ENABLE     (*(volatile unsigned long *)(0x6000d100))
+#define GPIOJ_ENABLE     (*(volatile unsigned long *)(0x6000d104))
+#define GPIOK_ENABLE     (*(volatile unsigned long *)(0x6000d108))
+#define GPIOL_ENABLE     (*(volatile unsigned long *)(0x6000d10c))
+#define GPIOI_OUTPUT_EN  (*(volatile unsigned long *)(0x6000d110))
+#define GPIOJ_OUTPUT_EN  (*(volatile unsigned long *)(0x6000d114))
+#define GPIOK_OUTPUT_EN  (*(volatile unsigned long *)(0x6000d118))
+#define GPIOL_OUTPUT_EN  (*(volatile unsigned long *)(0x6000d11c))
+#define GPIOI_OUTPUT_VAL (*(volatile unsigned long *)(0x6000d120))
+#define GPIOJ_OUTPUT_VAL (*(volatile unsigned long *)(0x6000d124))
+#define GPIOK_OUTPUT_VAL (*(volatile unsigned long *)(0x6000d128))
+#define GPIOL_OUTPUT_VAL (*(volatile unsigned long *)(0x6000d12c))
+#define GPIOI_INPUT_VAL  (*(volatile unsigned long *)(0x6000d130))
+#define GPIOJ_INPUT_VAL  (*(volatile unsigned long *)(0x6000d134))
+#define GPIOK_INPUT_VAL  (*(volatile unsigned long *)(0x6000d138))
+#define GPIOL_INPUT_VAL  (*(volatile unsigned long *)(0x6000d13c))
+#define GPIOI_INT_STAT   (*(volatile unsigned long *)(0x6000d140))
+#define GPIOJ_INT_STAT   (*(volatile unsigned long *)(0x6000d144))
+#define GPIOK_INT_STAT   (*(volatile unsigned long *)(0x6000d148))
+#define GPIOL_INT_STAT   (*(volatile unsigned long *)(0x6000d14c))
+#define GPIOI_INT_EN     (*(volatile unsigned long *)(0x6000d150))
+#define GPIOJ_INT_EN     (*(volatile unsigned long *)(0x6000d154))
+#define GPIOK_INT_EN     (*(volatile unsigned long *)(0x6000d158))
+#define GPIOL_INT_EN     (*(volatile unsigned long *)(0x6000d15c))
+#define GPIOI_INT_LEV    (*(volatile unsigned long *)(0x6000d160))
+#define GPIOJ_INT_LEV    (*(volatile unsigned long *)(0x6000d164))
+#define GPIOK_INT_LEV    (*(volatile unsigned long *)(0x6000d168))
+#define GPIOL_INT_LEV    (*(volatile unsigned long *)(0x6000d16c))
+#define GPIOI_INT_CLR    (*(volatile unsigned long *)(0x6000d170))
+#define GPIOJ_INT_CLR    (*(volatile unsigned long *)(0x6000d174))
+#define GPIOK_INT_CLR    (*(volatile unsigned long *)(0x6000d178))
+#define GPIOL_INT_CLR    (*(volatile unsigned long *)(0x6000d17c))
+
+/* Standard GPIO addresses + 0x800 allow atomic port manipulation on PP502x.
+ * Bits 8..15 of the written word define which bits are changed, bits 0..7
+ * define the value of those bits. */
+
+#define GPIO_SET_BITWISE(port, mask) \
+        do { *(&port + (0x800/sizeof(long))) = (mask << 8) | mask; } while(0)
+
+#define GPIO_CLEAR_BITWISE(port, mask) \
+        do { *(&port + (0x800/sizeof(long))) = mask << 8; } while(0)
+
+/* Device initialization */
+#define PP_VER1          (*(volatile unsigned long *)(0x70000000))
+#define PP_VER2          (*(volatile unsigned long *)(0x70000004))
+#define STRAP_OPT_A      (*(volatile unsigned long *)(0x70000008))
+#define STRAP_OPT_B      (*(volatile unsigned long *)(0x7000000c))
+#define BUS_WIDTH_MASK   0x00000010
+#define RAM_TYPE_MASK    0x000000c0
+#define ROM_TYPE_MASK    0x00000008
+
+#define DEV_INIT1        (*(volatile unsigned long *)(0x70000010))
+#define DEV_INIT2        (*(volatile unsigned long *)(0x70000020))
+/* some timing that needs to be handled during clock setup */
+#define DEV_TIMING1      (*(volatile unsigned long *)(0x70000034))
+#define XMB_NOR_CFG      (*(volatile unsigned long *)(0x70000038))
+#define XMB_RAM_CFG      (*(volatile unsigned long *)(0x7000003c))
+
+#define INIT_USB         0x80000000
+
+/* 32 bit GPO port */
+#define GPO32_VAL        (*(volatile unsigned long *)(0x70000080))
+#define GPO32_ENABLE     (*(volatile unsigned long *)(0x70000084))
+
+/* IIS */
+#define IISDIV              (*(volatile unsigned long*)(0x60006080))
+#define IISCONFIG           (*(volatile unsigned long*)(0x70002800))
+#define IISCLK              (*(volatile unsigned long*)(0x70002808))
+#define IISFIFO_CFG         (*(volatile unsigned long*)(0x7000280c))
+#define IISFIFO_WR          (*(volatile unsigned long*)(0x70002840))
+#define IISFIFO_WRH         (*(volatile unsigned short*)(0x70002840))
+#define IISFIFO_RD          (*(volatile unsigned long*)(0x70002880))
+#define IISFIFO_RDH         (*(volatile unsigned short*)(0x70002880))
+
+/**
+ * IISCONFIG bits:
+ * |   31   |   30   |   29   |   28   |   27   |   26   |   25   |   24   |
+ * | RESET  |        |TXFIFOEN|RXFIFOEN|        |  ????  |   MS   |  ????  |
+ * |   23   |   22   |   21   |   20   |   19   |   18   |   17   |   16   |
+ * |        |        |        |        |        |        |        |        |
+ * |   15   |   14   |   13   |   12   |   11   |   10   |    9   |    8   |
+ * |        |        |        |        | Bus Format[1:0] |     Size[1:0]   |
+ * |    7   |    6   |    5   |    4   |    3   |    2   |    1   |    0   |
+ * |        |     Size Format[2:0]     |  ????  |  ????  | IRQTX  | IRQRX  |
+ */
+
+/* All IIS formats send MSB first */
+#define IIS_RESET    (1 << 31)
+#define IIS_TXFIFOEN (1 << 29)
+#define IIS_RXFIFOEN (1 << 28)
+#define IIS_MASTER   (1 << 25)
+#define IIS_IRQTX    (1 << 1)
+#define IIS_IRQRX    (1 << 0)
+
+#define IIS_IRQTX_REG  IISCONFIG
+#define IIS_IRQRX_REG  IISCONFIG
+
+/* Data format on the IIS bus */
+#define IIS_FORMAT_MASK  (0x3 << 10)
+#define IIS_FORMAT_IIS   (0x0 << 10) /* Standard IIS - leading dummy bit */
+#define IIS_FORMAT_1     (0x1 << 10)
+#define IIS_FORMAT_LJUST (0x2 << 10) /* Left justified - no dummy bit */
+#define IIS_FORMAT_3     (0x3 << 10)
+/* Other formats not yet known  */
+
+/* Data size on IIS bus */
+#define IIS_SIZE_MASK   (0x3 << 8)
+#define IIS_SIZE_16BIT  (0x0 << 8)
+/* Other sizes not yet known */
+
+/* Data size/format on IIS FIFO */
+#define IIS_FIFO_FORMAT_MASK        (0x7 << 4)
+#define IIS_FIFO_FORMAT_LE_HALFWORD (0x0 << 4)
+/* Big-endian formats - data sent to the FIFO must be big endian.
+ * I forgot which is which size but did test them. */
+#define IIS_FIFO_FORMAT_1           (0x1 << 4)
+#define IIS_FIFO_FORMAT_2           (0x2 << 4)
+/* 32bit-MSB-little endian */
+#define IIS_FIFO_FORMAT_LE32        (0x3 << 4)
+/* 16bit-MSB-little endian */
+#define IIS_FIFO_FORMAT_LE16        (0x4 << 4)
+#define IIS_FIFO_FORMAT_5           (0x5 << 4)
+#define IIS_FIFO_FORMAT_6           (0x6 << 4)
+/* A second one like IIS_FIFO_FORMAT_LE16? PP5020 only? */
+#define IIS_FIFO_FORMAT_LE16_2      (0x7 << 4)
+
+/* FIFO formats 0x5 and above seem equivalent to 0x4 ?? */
+
+/**
+ * IISFIFO_CFG bits:
+ * |   31   |   30   |   29   |   28   |   27   |   26   |   25   |   24   |
+ * |        |        |                      RXFull[5:0]                    |
+ * |   23   |   22   |   21   |   20   |   19   |   18   |   17   |   16   |
+ * |        |        |                      TXFree[5:0]                    |
+ * |   15   |   14   |   13   |   12   |   11   |   10   |    9   |    8   |
+ * |        |        |        | RXCLR  |        |        |        | TXCLR  |
+ * |    7   |    6   |    5   |    4   |    3   |    2   |    1   |    0   |
+ * |        |        |   RX_FULL_LVL   |        |        |  TX_EMPTY_LVL   |
+ */
+
+/* handy macros to extract the FIFO counts */
+#define IIS_RX_FULL_MASK (0x3f << 24)
+#define IIS_RX_FULL_COUNT \
+    ((IISFIFO_CFG & IIS_RX_FULL_MASK) >> 24)
+
+#define IIS_TX_FREE_MASK (0x3f << 16)
+#define IIS_TX_FREE_COUNT \
+    ((IISFIFO_CFG & IIS_TX_FREE_MASK) >> 16)
+
+#define IIS_RXCLR (1 << 12)
+#define IIS_TXCLR (1 << 8)
+/* Number of slots */
+#define IIS_RX_FULL_LVL_4  (0x1 << 4)
+#define IIS_RX_FULL_LVL_8  (0x2 << 4)
+#define IIS_RX_FULL_LVL_12 (0x3 << 4)
+
+#define IIS_TX_EMPTY_LVL_4  (0x1 << 0)
+#define IIS_TX_EMPTY_LVL_8  (0x2 << 0)
+#define IIS_TX_EMPTY_LVL_12 (0x3 << 0)
+
+/* Note: didn't bother to see of levels 0 and 16 actually work */
+
+/* First ("mono") LCD bridge */
+#define LCD1_BASE           0x70003000
+
+#define LCD1_CONTROL        (*(volatile unsigned long *)(0x70003000))
+#define LCD1_CMD            (*(volatile unsigned long *)(0x70003008))
+#define LCD1_DATA           (*(volatile unsigned long *)(0x70003010))
+
+#define LCD1_BUSY_MASK      0x8000
+
+/* Serial Controller */
+#define SERIAL0             (*(volatile unsigned long*)(0x70006000))
+#define SERIAL1             (*(volatile unsigned long*)(0x70006040))
+
+/* Second ("color") LCD bridge */
+#define LCD2_BASE           0x70008a00
+
+#define LCD2_PORT           (*(volatile unsigned long*)(0x70008a0c))
+#define LCD2_BLOCK_CTRL     (*(volatile unsigned long*)(0x70008a20))
+#define LCD2_BLOCK_CONFIG   (*(volatile unsigned long*)(0x70008a24))
+#define LCD2_BLOCK_DATA     (*(volatile unsigned long*)(0x70008b00))
+
+#define LCD2_BUSY_MASK      0x80000000
+#define LCD2_CMD_MASK       0x80000000
+#define LCD2_DATA_MASK      0x81000000
+
+#define LCD2_BLOCK_READY    0x04000000
+#define LCD2_BLOCK_TXOK     0x01000000
+
+/* I2C */
+#define I2C_BASE            0x7000c000
+
+/* EIDE Controller */
+#define IDE_BASE            0xc3000000
+
+#define IDE0_PRI_TIMING0    (*(volatile unsigned long*)(0xc3000000))
+#define IDE0_PRI_TIMING1    (*(volatile unsigned long*)(0xc3000004))
+#define IDE0_SEC_TIMING0    (*(volatile unsigned long*)(0xc3000008))
+#define IDE0_SEC_TIMING1    (*(volatile unsigned long*)(0xc300000c))
+
+#define IDE1_PRI_TIMING0    (*(volatile unsigned long*)(0xc3000010))
+#define IDE1_PRI_TIMING1    (*(volatile unsigned long*)(0xc3000014))
+#define IDE1_SEC_TIMING0    (*(volatile unsigned long*)(0xc3000018))
+#define IDE1_SEC_TIMING1    (*(volatile unsigned long*)(0xc300001c))
+
+#define IDE0_CFG            (*(volatile unsigned long*)(0xc3000028))
+#define IDE1_CFG            (*(volatile unsigned long*)(0xc300002c))
+
+#define IDE0_CNTRLR_STAT    (*(volatile unsigned long*)(0xc30001e0))
+
+/* USB controller */
+#define USB_BASE            0xc5000000
+
+/* Firewire Controller */
+#define FIREWIRE_BASE       0xc6000000
+
+/* Memory controller */
+#define CACHE_BASE              (*(volatile unsigned long*)(0xf0000000))
+/* 0xf0000000-0xf0001fff */
+#define CACHE_DATA_BASE         (*(volatile unsigned long*)(0xf0000000))
+/* 0xf0002000-0xf0003fff */
+#define CACHE_DATA_MIRROR_BASE  (*(volatile unsigned long*)(0xf0002000))
+/* 0xf0004000-0xf0007fff */
+#define CACHE_STATUS_BASE       (*(volatile unsigned long*)(0xf0004000))
+#define CACHE_FLUSH_BASE        (*(volatile unsigned long*)(0xf0008000))
+#define CACHE_INVALID_BASE      (*(volatile unsigned long*)(0xf000c000))
+#define MMAP_PHYS_READ_MASK     0x0100
+#define MMAP_PHYS_WRITE_MASK    0x0200
+#define MMAP_PHYS_DATA_MASK     0x0400
+#define MMAP_PHYS_CODE_MASK     0x0800
+#define MMAP_FIRST              (*(volatile unsigned long*)(0xf000f000))
+#define MMAP_LAST               (*(volatile unsigned long*)(0xf000f03c))
+#define MMAP0_LOGICAL           (*(volatile unsigned long*)(0xf000f000))
+#define MMAP0_PHYSICAL          (*(volatile unsigned long*)(0xf000f004))
+#define MMAP1_LOGICAL           (*(volatile unsigned long*)(0xf000f008))
+#define MMAP1_PHYSICAL          (*(volatile unsigned long*)(0xf000f00c))
+#define MMAP2_LOGICAL           (*(volatile unsigned long*)(0xf000f010))
+#define MMAP2_PHYSICAL          (*(volatile unsigned long*)(0xf000f014))
+#define MMAP3_LOGICAL           (*(volatile unsigned long*)(0xf000f018))
+#define MMAP3_PHYSICAL          (*(volatile unsigned long*)(0xf000f01c))
+#define MMAP4_LOGICAL           (*(volatile unsigned long*)(0xf000f020))
+#define MMAP4_PHYSICAL          (*(volatile unsigned long*)(0xf000f024))
+#define MMAP5_LOGICAL           (*(volatile unsigned long*)(0xf000f028))
+#define MMAP5_PHYSICAL          (*(volatile unsigned long*)(0xf000f02c))
+#define MMAP6_LOGICAL           (*(volatile unsigned long*)(0xf000f030))
+#define MMAP6_PHYSICAL          (*(volatile unsigned long*)(0xf000f034))
+#define MMAP7_LOGICAL           (*(volatile unsigned long*)(0xf000f038))
+#define MMAP7_PHYSICAL          (*(volatile unsigned long*)(0xf000f03c))
+
+#endif /* __PP5020_H__ */
diff -urN arch/armnommu/mach-ipod/rtc.c arch/armnommu/mach-ipod/rtc.c
--- arch/armnommu/mach-ipod/rtc.c	1969-12-31 19:00:00.000000000 -0500
+++ arch/armnommu/mach-ipod/rtc.c	2008-10-10 03:43:42.000000000 -0400
@@ -0,0 +1,188 @@
+/*
+ * rtc.c - RTC driver for iPod
+ *
+ * Copyright (c) 2008 Bernard Leach (Sebastian.Duell@iPodLinux.org)
+ *
+ * Routines mostly from Rockbox and iPodLinux
+ */
+
+#include <linux/module.h>
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/major.h>
+#include <linux/miscdevice.h>
+#include <linux/fcntl.h>
+#include <linux/rtc.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+
+#include <linux/devfs_fs_kernel.h>
+
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+#include <asm/hardware.h>
+
+#include "as3514.h"
+
+#define MINUTE_SECONDS      60
+#define HOUR_SECONDS        3600
+#define DAY_SECONDS         86400
+#define WEEK_SECONDS        604800
+#define YEAR_SECONDS        31536000
+#define LEAP_YEAR_SECONDS   31622400
+
+static devfs_handle_t rtc_devfs_handle;
+static int pcf_rtc_isopen;
+/* Days in each month */
+static unsigned int days_in_month[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
+
+extern int i2c_readbyte(unsigned int dev_addr, int addr);
+
+static inline bool is_leapyear(int year)
+{
+   if( ((year%4)==0) && (((year%100)!=0) || ((year%400)==0)) )
+      return true;
+   else
+      return false;
+}
+
+static void as_rtc_read(struct rtc_time *tm)
+{
+    char tmp[4];
+    int year;
+    int i;
+    unsigned int seconds;
+    
+    ipod_i2c_lock();
+    /* RTC_AS3514's slave address is 0x46*/
+    for (i=0;i<4;i++){
+        tmp[i] = i2c_readbyte(AS3514_I2C_ADDR, RTC_0 + i);
+    }
+    ipod_i2c_unlock();
+    seconds = tmp[0] + (tmp[1]<<8) + (tmp[2]<<16) + (tmp[3]<<24);
+    
+    /* Convert seconds since Jan-1-1980 */
+      
+    /* Year */
+    year = 80;
+    while(seconds>=LEAP_YEAR_SECONDS)
+    {
+        if(is_leapyear(year)){
+            seconds -= LEAP_YEAR_SECONDS;
+        } else {
+            seconds -= YEAR_SECONDS;
+        }
+
+        year++;
+    }
+    
+    if(is_leapyear(year)) {
+        days_in_month[1] = 29;
+    } else {
+        days_in_month[1] = 28;
+        if(seconds>YEAR_SECONDS){
+            year++;
+            seconds -= YEAR_SECONDS;
+        }
+    }
+    tm->tm_year = year;
+    
+    /* Month */
+    for(i=0; i<12; i++)
+    {
+        if(seconds < days_in_month[i]*DAY_SECONDS){
+            tm->tm_mon = i;
+            break;
+        }
+        
+        seconds -= days_in_month[i]*DAY_SECONDS;
+    }
+    
+    /* Month Day */
+    tm->tm_mday = seconds/DAY_SECONDS;
+    seconds -= tm->tm_mday*DAY_SECONDS;
+
+    /* Hour */
+    tm->tm_hour = seconds/HOUR_SECONDS;
+    seconds -= tm->tm_hour*HOUR_SECONDS;
+    
+    /* Minute */
+    tm->tm_min = seconds/MINUTE_SECONDS;
+    seconds -= tm->tm_min*MINUTE_SECONDS;
+    
+    /* Second */
+    tm->tm_sec = seconds;
+}
+
+static int as_rtc_open(struct inode *inode, struct file *file)
+{
+	if (pcf_rtc_isopen) {
+		return -EBUSY;
+	}
+
+	pcf_rtc_isopen = 1;
+	return 0;
+}
+
+static int as_rtc_close(struct inode *inode, struct file *file)
+{
+	pcf_rtc_isopen = 0;
+
+	return 0;
+}
+
+static int as_rtc_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	struct rtc_time now;
+
+	switch (cmd) {
+	case RTC_RD_TIME:
+		memset(&now, 0x0, sizeof(now));
+		as_rtc_read(&now);
+		return copy_to_user((void *)arg, &now, sizeof(now)) ? -EFAULT : 0;
+
+	// case RTC_SET_TIME:
+	}
+
+	return -EINVAL;
+}
+
+static struct file_operations as_rtc_fops = {
+	owner: THIS_MODULE,
+	open: as_rtc_open,
+	release: as_rtc_close,
+	ioctl: as_rtc_ioctl,
+};
+
+
+static int __init as3514_init(void)
+{
+   ipod_i2c_init();
+
+	rtc_devfs_handle = devfs_register(NULL, "rtc", DEVFS_FL_DEFAULT,
+		MISC_MAJOR, RTC_MINOR,
+		S_IFCHR | S_IWUSR | S_IRUSR,
+		&as_rtc_fops, NULL);
+        if (rtc_devfs_handle < 0) {
+                printk(KERN_WARNING "rtc: failed to register major %d, minor %d\n",
+                        MISC_MAJOR, RTC_MINOR);
+                return 0;
+        }
+
+	return 0;
+}
+
+static void __exit as3514_exit(void)
+{
+	devfs_unregister_chrdev(MISC_MAJOR, "rtc");
+	devfs_unregister(rtc_devfs_handle);
+}
+
+module_init(as3514_init);
+module_exit(as3514_exit);
+
+MODULE_AUTHOR("Bernard Leach (Sebastian.Duell@iPodLinux.org)");
+MODULE_DESCRIPTION("RTC driver for as3514");
+MODULE_LICENSE("GPL");
+
diff -urN arch/armnommu/mach-ipod/sd.c arch/armnommu/mach-ipod/sd.c
--- arch/armnommu/mach-ipod/sd.c	1969-12-31 19:00:00.000000000 -0500
+++ arch/armnommu/mach-ipod/sd.c	2008-10-10 03:43:42.000000000 -0400
@@ -0,0 +1,1530 @@
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/blkpg.h>
+#include <linux/hdreg.h>
+#include <linux/major.h>
+#include <linux/delay.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+#define DEVICE_NAME "sd"
+#define DEVICE_NR(device) (MINOR(device))
+#define DEVICE_ON(device)
+#define DEVICE_OFF(device)
+static int nr_major = 0;
+#define MAJOR_NR nr_major
+//#define MAJOR_NR 121
+
+#include <linux/blk.h>
+#include <linux/kmod.h>
+
+#define IPOD_E200
+#include "pp5020.h"
+
+
+#define SD_BLOCK_SIZE      (512)
+#define SD_SECTOR_SIZE     (512)
+#define BLOCKS_PER_BANK 0x7a7800
+
+#define STATUS_REG      (*(volatile unsigned int *)(0x70008204))
+#define REG_1           (*(volatile unsigned int *)(0x70008208))
+#define UNKNOWN         (*(volatile unsigned int *)(0x70008210))
+#define BLOCK_SIZE_REG  (*(volatile unsigned int *)(0x7000821c))
+#define BLOCK_COUNT_REG (*(volatile unsigned int *)(0x70008220))
+#define REG_5           (*(volatile unsigned int *)(0x70008224))
+#define CMD_REG0        (*(volatile unsigned int *)(0x70008228))
+#define CMD_REG1        (*(volatile unsigned int *)(0x7000822c))
+#define CMD_REG2        (*(volatile unsigned int *)(0x70008230))
+#define RESPONSE_REG    (*(volatile unsigned int *)(0x70008234))
+#define SD_STATE_REG    (*(volatile unsigned int *)(0x70008238))
+#define REG_11          (*(volatile unsigned int *)(0x70008240))
+#define REG_12          (*(volatile unsigned int *)(0x70008244))
+#define DATA_REG        (*(volatile unsigned int *)(0x70008280))
+
+/* STATUS_REG bits */
+#define DATA_DONE       (1 << 12)
+#define CMD_DONE        (1 << 13)
+#define ERROR_BITS      (0x3f)
+#define READY_FOR_DATA  (1 << 8)
+#define FIFO_FULL       (1 << 7)
+#define FIFO_EMPTY      (1 << 6)
+
+#define CMD_OK          0x0 /* Command was successful */
+#define CMD_ERROR_2     0x2 /* SD did not respond to command (either it doesn't
+                               understand the command or is not inserted) */
+
+/* SD States */
+#define IDLE            0
+#define READY           1
+#define IDENT           2
+#define STBY            3
+#define TRAN            4
+#define DATA            5
+#define RCV             6
+#define PRG             7
+#define DIS             8
+
+#define FIFO_LEN        16          /* FIFO is 16 words deep */
+
+/* SD Commands */
+#define GO_IDLE_STATE         0
+#define ALL_SEND_CID          2
+#define SEND_RELATIVE_ADDR    3
+#define SET_DSR               4
+#define SWITCH_FUNC           6
+#define SELECT_CARD           7
+#define DESELECT_CARD         7
+#define SEND_IF_COND          8
+#define SEND_CSD              9
+#define SEND_CID             10
+#define STOP_TRANSMISSION    12
+#define SEND_STATUS          13
+#define GO_INACTIVE_STATE    15
+#define SET_BLOCKLEN         16
+#define READ_SINGLE_BLOCK    17
+#define READ_MULTIPLE_BLOCK  18
+#define SEND_NUM_WR_BLOCKS   22
+#define WRITE_BLOCK          24
+#define WRITE_MULTIPLE_BLOCK 25
+#define ERASE_WR_BLK_START   32
+#define ERASE_WR_BLK_END     33
+#define ERASE                38
+#define APP_CMD              55
+
+#define EC_OK                    0
+#define EC_FAILED                1
+#define EC_NOCARD                2
+#define EC_WAIT_STATE_FAILED     3
+#define EC_CHECK_TIMEOUT_FAILED  4
+#define EC_POWER_UP              5
+#define EC_READ_TIMEOUT          6
+#define EC_WRITE_TIMEOUT         7
+#define EC_TRAN_SEL_BANK         8
+#define EC_TRAN_READ_ENTRY       9
+#define EC_TRAN_READ_EXIT       10
+#define EC_TRAN_WRITE_ENTRY     11
+#define EC_TRAN_WRITE_EXIT      12
+#define EC_FIFO_SEL_BANK_EMPTY  13
+#define EC_FIFO_SEL_BANK_DONE   14
+#define EC_FIFO_ENA_BANK_EMPTY  15
+#define EC_FIFO_READ_FULL       16
+#define EC_FIFO_WR_EMPTY        17
+#define EC_FIFO_WR_DONE         18
+#define EC_COMMAND              19
+#define NUM_EC                  20
+
+/* Application Specific commands */
+#define SET_BUS_WIDTH   6
+#define SD_APP_OP_COND  41
+
+/** global, exported variables **/
+#ifdef HAVE_HOTSWAP
+#define NUM_VOLUMES 2
+#else
+#define NUM_VOLUMES 1
+#endif
+
+/* for compatibility */
+int ata_spinup_time = 0;
+
+//long last_disk_activity = -1;
+
+#define intptr_t    long
+
+typedef int bool;
+#define false 0
+#define true 1
+
+/** static, private data **/ 
+static bool initialized = false;
+
+static long next_yield = 0;
+#define MIN_YIELD_PERIOD 1000
+
+#define TIME_AFTER(a,b)         ((long)(b) - (long)(a) < 0)
+
+typedef struct
+{
+   int initialized;
+   
+   unsigned int ocr;            /* OCR register */
+   unsigned int csd[4];         /* CSD register */
+   unsigned int cid[4];         /* CID register */
+   unsigned int rca;
+   
+   uint64_t capacity;           /* size in bytes */
+   unsigned long numblocks;     /* size in flash blocks */
+   unsigned int block_size;     /* block size in bytes */
+   unsigned int max_read_bl_len;/* max read data block length */
+   unsigned int block_exp;      /* block size exponent */
+   unsigned char current_bank;  /* The bank that we are working with */
+} tSDCardInfo;
+
+static tSDCardInfo card_info[2];
+static tSDCardInfo *currcard = NULL; /* current active card */
+
+static int hd_sizes[1<<6];
+static int hd_blocksizes[1<<6];
+static int hd_hardsectsizes[1<<6];
+static int hd_maxsect[1<<6];
+
+static struct hd_struct hd[1<<6];
+
+struct sd_card_status
+{
+    int retry;
+    int retry_max;
+};
+
+static struct sd_card_status sd_status[NUM_VOLUMES] =
+{
+    { 0, 1  },
+#ifdef HAVE_HOTSWAP
+    { 0, 10 }
+#endif
+};
+
+/* Shoot for around 75% usage */
+//static long sd_stack [(DEFAULT_STACK_SIZE*2 + 0x1c0)/sizeof(long)];
+spinlock_t    sd_spin = SPIN_LOCK_UNLOCKED;
+//static struct event_queue sd_queue;
+
+/* Posted when card plugged status has changed */
+#define SD_HOTSWAP    1
+/* Actions taken by sd_thread when card status has changed */
+enum sd_thread_actions
+{
+    SDA_NONE      = 0x0,
+    SDA_UNMOUNTED = 0x1,
+    SDA_MOUNTED   = 0x2
+};
+
+/* Private Functions */
+
+static unsigned int check_time[NUM_EC];
+
+static inline bool sd_check_timeout(long timeout, int id)
+{
+    return !TIME_AFTER(USEC_TIMER, check_time[id] + timeout);
+}
+
+static bool sd_poll_status(unsigned int trigger, long timeout)
+{
+    long t = USEC_TIMER;
+
+    while ((STATUS_REG & trigger) == 0)
+    {
+        long time = USEC_TIMER;
+
+        if (TIME_AFTER(time, next_yield))
+        {
+            long ty = USEC_TIMER;
+ //           priority_yield();
+            timeout += USEC_TIMER - ty;
+            next_yield = ty + MIN_YIELD_PERIOD;
+        }
+
+        if (TIME_AFTER(time, t + timeout))
+            return false;
+    }
+
+    return true;
+}
+
+static int sd_command(unsigned int cmd, unsigned long arg1,
+                      unsigned int *response, unsigned int type)
+{
+    int i, words; /* Number of 16 bit words to read from RESPONSE_REG */
+    unsigned int data[9];
+
+    CMD_REG0 = cmd;
+    CMD_REG1 = (unsigned int)((arg1 & 0xffff0000) >> 16);
+    CMD_REG2 = (unsigned int)((arg1 & 0xffff));
+    UNKNOWN  = type;
+
+    if (!sd_poll_status(CMD_DONE, 100000))
+        return -EC_COMMAND;
+
+    if ((STATUS_REG & ERROR_BITS) != CMD_OK)
+        /* Error sending command */
+        return -EC_COMMAND - (STATUS_REG & ERROR_BITS)*100;
+
+    if (cmd == GO_IDLE_STATE)
+        return 0; /* no response here */
+
+    words = (type == 2) ? 9 : 3;
+
+    for (i = 0; i < words; i++) /* RESPONSE_REG is read MSB first */
+        data[i] = RESPONSE_REG; /* Read most significant 16-bit word */
+
+    if (response == NULL)
+    {
+        /* response discarded */
+    }
+    else if (type == 2)
+    {
+        /* Response type 2 has the following structure:
+         * [135:135] Start Bit - '0'
+         * [134:134] Transmission bit - '0'
+         * [133:128] Reserved - '111111'
+         * [127:001] CID or CSD register including internal CRC7
+         * [000:000] End Bit - '1'
+         */
+        response[3] = (data[0]<<24) + (data[1]<<8) + (data[2]>>8);
+        response[2] = (data[2]<<24) + (data[3]<<8) + (data[4]>>8);
+        response[1] = (data[4]<<24) + (data[5]<<8) + (data[6]>>8);
+        response[0] = (data[6]<<24) + (data[7]<<8) + (data[8]>>8);
+    }
+    else
+    {
+        /* Response types 1, 1b, 3, 6, 7 have the following structure:
+         * Types 4 and 5 are not supported.
+         *
+         *     [47] Start bit - '0'
+         *     [46] Transmission bit - '0'
+         *  [45:40] R1, R1b, R6, R7: Command index
+         *          R3: Reserved - '111111'
+         *   [39:8] R1, R1b: Card Status
+         *          R3: OCR Register
+         *          R6: [31:16] RCA
+         *              [15: 0] Card Status Bits 23, 22, 19, 12:0
+         *                     [23] COM_CRC_ERROR
+         *                     [22] ILLEGAL_COMMAND
+         *                     [19] ERROR
+         *                   [12:9] CURRENT_STATE
+         *                      [8] READY_FOR_DATA
+         *                    [7:6]
+         *                      [5] APP_CMD
+         *                      [4]
+         *                      [3] AKE_SEQ_ERROR
+         *                      [2] Reserved
+         *                    [1:0] Reserved for test mode
+         *          R7: [19:16] Voltage accepted
+         *              [15:8]  echo-back of check pattern
+         *    [7:1] R1, R1b: CRC7
+         *          R3: Reserved - '1111111'
+         *      [0] End Bit - '1'
+         */
+        response[0] = (data[0]<<24) + (data[1]<<8) + (data[2]>>8);
+    }
+
+    return 0;
+}
+
+static int sd_wait_for_state(unsigned int state, int id)
+{
+    unsigned int response = 0;
+    unsigned int timeout = 0x80000;
+
+    check_time[id] = USEC_TIMER;
+
+    while (1)
+    {
+        int ret = sd_command(SEND_STATUS, currcard->rca, &response, 1);
+        long us;
+
+        if (ret < 0)
+            return ret*100 - id;
+
+        if (((response >> 9) & 0xf) == state)
+        {
+            SD_STATE_REG = state;
+            return 0;
+        }
+
+        if (!sd_check_timeout(timeout, id))
+            return -EC_WAIT_STATE_FAILED*100 - id;
+
+ //       mdelay(10);
+
+        us = USEC_TIMER;
+        if (TIME_AFTER(us, next_yield))
+        {
+   //         priority_yield();
+            timeout += USEC_TIMER - us;
+            next_yield = us + MIN_YIELD_PERIOD;
+        }
+    }
+}
+
+static inline void copy_read_sectors_fast(unsigned char **buf)
+{
+    /* Copy one chunk of 16 words using best method for start alignment */
+    switch ( (intptr_t)*buf & 3 )
+    {
+    case 0:
+        asm volatile (
+            "ldmia  %1, { r2-r9 }          \r\n"
+            "orr    r2, r2, r3, lsl #16         \r\n"
+            "orr    r4, r4, r5, lsl #16         \r\n"
+            "orr    r6, r6, r7, lsl #16         \r\n"
+            "orr    r8, r8, r9, lsl #16         \r\n"
+            "stmia  %0!, { r2, r4, r6, r8 } \r\n"
+            "ldmia  %1, { r2-r9 }          \r\n"
+            "orr    r2, r2, r3, lsl #16         \r\n"
+            "orr    r4, r4, r5, lsl #16         \r\n"
+            "orr    r6, r6, r7, lsl #16         \r\n"
+            "orr    r8, r8, r9, lsl #16         \r\n"
+            "stmia  %0!, { r2, r4, r6, r8 } \r\n"
+            : "+&r"(*buf)
+            : "r"(&DATA_REG)
+            : "r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9"
+        );
+        break;
+    case 1:
+        asm volatile (
+            "ldmia  %1, { r2-r9 }          \r\n"
+            "orr    r3, r2, r3, lsl #16         \r\n"
+            "strb   r3, [%0], #1            \r\n"
+            "mov    r3, r3, lsr #8              \r\n"
+            "strh   r3, [%0], #2            \r\n"
+            "mov    r3, r3, lsr #16             \r\n"
+            "orr    r3, r3, r4, lsl #8          \r\n"
+            "orr    r3, r3, r5, lsl #24         \r\n"
+            "mov    r5, r5, lsr #8              \r\n"
+            "orr    r5, r5, r6, lsl #8          \r\n"
+            "orr    r5, r5, r7, lsl #24         \r\n"
+            "mov    r7, r7, lsr #8              \r\n"
+            "orr    r7, r7, r8, lsl #8          \r\n"
+            "orr    r7, r7, r9, lsl #24         \r\n"
+            "mov    r2, r9, lsr #8              \r\n"
+            "stmia  %0!, { r3, r5, r7 }     \r\n"
+            "ldmia  %1, { r3-r10 }         \r\n"
+            "orr    r2, r2, r3, lsl #8          \r\n"
+            "orr    r2, r2, r4, lsl #24         \r\n"
+            "mov    r4, r4, lsr #8              \r\n"
+            "orr    r4, r4, r5, lsl #8          \r\n"
+            "orr    r4, r4, r6, lsl #24         \r\n"
+            "mov    r6, r6, lsr #8              \r\n"
+            "orr    r6, r6, r7, lsl #8          \r\n"
+            "orr    r6, r6, r8, lsl #24         \r\n"
+            "mov    r8, r8, lsr #8              \r\n"
+            "orr    r8, r8, r9, lsl #8          \r\n"
+            "orr    r8, r8, r10, lsl #24        \r\n"
+            "mov    r10, r10, lsr #8            \r\n"
+            "stmia  %0!, { r2, r4, r6, r8 } \r\n"
+            "strb   r10, [%0], #1           \r\n"
+            : "+&r"(*buf)
+            : "r"(&DATA_REG)
+            : "r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "r10"
+        );
+        break;
+    case 2:
+        asm volatile (
+            "ldmia  %1, { r2-r9 }          \r\n"
+            "strh   r2, [%0], #2            \r\n"
+            "orr    r3, r3, r4, lsl #16         \r\n"
+            "orr    r5, r5, r6, lsl #16         \r\n"
+            "orr    r7, r7, r8, lsl #16         \r\n"
+            "stmia  %0!, { r3, r5, r7 }     \r\n"
+            "ldmia  %1, { r2-r8, r10 }     \r\n"
+            "orr    r2, r9, r2, lsl #16         \r\n"
+            "orr    r3, r3, r4, lsl #16         \r\n"
+            "orr    r5, r5, r6, lsl #16         \r\n"
+            "orr    r7, r7, r8, lsl #16         \r\n"
+            "stmia  %0!, { r2, r3, r5, r7 } \r\n"
+            "strh   r10, [%0], #2           \r\n"
+            : "+&r"(*buf)
+            : "r"(&DATA_REG)
+            : "r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "r10"
+        );
+        break;
+    case 3:
+        asm volatile (
+            "ldmia  %1, { r2-r9 }          \r\n"
+            "orr    r3, r2, r3, lsl #16         \r\n"
+            "strb   r3, [%0], #1            \r\n"
+            "mov    r3, r3, lsr #8              \r\n"
+            "orr    r3, r3, r4, lsl #24         \r\n"
+            "mov    r4, r4, lsr #8              \r\n"
+            "orr    r5, r4, r5, lsl #8          \r\n"
+            "orr    r5, r5, r6, lsl #24         \r\n"
+            "mov    r6, r6, lsr #8              \r\n"
+            "orr    r7, r6, r7, lsl #8          \r\n"
+            "orr    r7, r7, r8, lsl #24         \r\n"
+            "mov    r8, r8, lsr #8              \r\n"
+            "orr    r2, r8, r9, lsl #8          \r\n"
+            "stmia  %0!, { r3, r5, r7 }     \r\n"
+            "ldmia  %1, { r3-r10 }         \r\n"
+            "orr    r2, r2, r3, lsl #24         \r\n"
+            "mov    r3, r3, lsr #8              \r\n"
+            "orr    r4, r3, r4, lsl #8          \r\n"
+            "orr    r4, r4, r5, lsl #24         \r\n"
+            "mov    r5, r5, lsr #8              \r\n"
+            "orr    r6, r5, r6, lsl #8          \r\n"
+            "orr    r6, r6, r7, lsl #24         \r\n"
+            "mov    r7, r7, lsr #8              \r\n"
+            "orr    r8, r7, r8, lsl #8          \r\n"
+            "orr    r8, r8, r9, lsl #24         \r\n"
+            "mov    r9, r9, lsr #8              \r\n"
+            "orr    r10, r9, r10, lsl #8        \r\n"
+            "stmia  %0!, { r2, r4, r6, r8 } \r\n"
+            "strh   r10, [%0], #2           \r\n"
+            "mov    r10, r10, lsr #16           \r\n"
+            "strb   r10, [%0], #1           \r\n"
+            : "+&r"(*buf)
+            : "r"(&DATA_REG)
+            : "r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "r10"
+        );
+        break;
+    }
+}
+
+static inline void copy_read_sectors_slow(unsigned char** buf)
+{
+   int cnt = FIFO_LEN;
+   /* Copy one chunk of 16 words */
+   asm volatile (
+      "mov r1, %2              \r\n"
+      "1:                                     \r\n"
+      "ldrh   r0, [%1]             \r\n"
+      "strb   r0, [%0], #1          \r\n"
+      "mov    r0, r0, lsr #8          \r\n"
+      "strb   r0, [%0], #1          \r\n"
+      "subs   r1, r1, #1          \r\n"
+      "bgt    1b                          \r\n"
+      :"+&r"(*buf)  //out
+      :"r"(&DATA_REG), "r"(cnt) //in
+      );
+}
+
+/* Writes have to be kept slow for now */
+static inline void copy_write_sectors(const unsigned char** buf)
+{
+    int cnt = FIFO_LEN;
+    unsigned t;
+
+    do
+    {
+        t  = *(*buf)++;
+        t |= *(*buf)++ << 8;
+        DATA_REG = t;
+    } while (--cnt > 0); /* tail loop is faster */
+}
+
+static int sd_select_bank(unsigned char bank)
+{
+    unsigned char card_data[512];
+    const unsigned char* write_buf;
+    int i, ret;
+
+    memset(card_data, 0, 512);
+    ret = sd_wait_for_state(TRAN, EC_TRAN_SEL_BANK);
+    if (ret < 0)
+        return ret;
+
+    BLOCK_SIZE_REG = 512;
+    BLOCK_COUNT_REG = 1;
+
+    ret = sd_command(35, 0, NULL, 0x1c0d); /* CMD35 is vendor specific */
+    if (ret < 0)
+    {
+        return ret;
+    }
+
+    SD_STATE_REG = PRG;
+
+    card_data[0] = bank;
+
+    /* Write the card data */
+    write_buf = card_data;
+    for (i = 0; i < SD_BLOCK_SIZE/2; i += FIFO_LEN)
+    {
+        /* Wait for the FIFO to empty */
+        if (sd_poll_status(FIFO_EMPTY, 10000))
+        {
+            copy_write_sectors(&write_buf); /* Copy one chunk of 16 words */
+            continue;
+        }
+
+       return -EC_FIFO_SEL_BANK_EMPTY;
+    }
+
+    if (!sd_poll_status(DATA_DONE, 10000))
+    {
+        return -EC_FIFO_SEL_BANK_DONE;
+    }
+    currcard->current_bank = bank;
+
+    return 0;
+}
+
+static void sd_card_mux(int card_no)
+{
+/* Set the current card mux */
+#ifdef IPOD_E200
+    if (card_no == 0)
+    {
+        GPO32_VAL |= 0x4;
+
+        GPIOA_ENABLE     &= ~0x7a;
+        GPIOA_OUTPUT_EN  &= ~0x7a;
+        GPIOD_ENABLE     |=  0x1f;
+        GPIOD_OUTPUT_VAL |=  0x1f;
+        GPIOD_OUTPUT_EN  |=  0x1f;
+
+        outl((inl(0x70000014) & ~(0x3ffff)) | 0x255aa, 0x70000014);
+    }
+    else
+    {
+        GPO32_VAL &= ~0x4;
+
+        GPIOD_ENABLE     &= ~0x1f;
+        GPIOD_OUTPUT_EN  &= ~0x1f;
+        GPIOA_ENABLE     |=  0x7a;
+        GPIOA_OUTPUT_VAL |=  0x7a;
+        GPIOA_OUTPUT_EN  |=  0x7a;
+
+        outl(inl(0x70000014) & ~(0x3ffff), 0x70000014);
+    }
+#else /* IPOD_C200 */
+    if (card_no == 0)
+    {
+        GPO32_VAL |= 0x4;
+
+        GPIOD_ENABLE     &= ~0x1f;
+        GPIOD_OUTPUT_EN  &= ~0x1f;
+        GPIOA_ENABLE     |=  0x7a;
+        GPIOA_OUTPUT_VAL |=  0x7a;
+        GPIOA_OUTPUT_EN  |=  0x7a;
+
+        outl(inl(0x70000014) & ~(0x3ffff), 0x70000014);
+    }
+    else
+    {
+        GPO32_VAL &= ~0x4;
+
+        GPIOA_ENABLE     &= ~0x7a;
+        GPIOA_OUTPUT_EN  &= ~0x7a;
+        GPIOD_ENABLE     |=  0x1f;
+        GPIOD_OUTPUT_VAL |=  0x1f;
+        GPIOD_OUTPUT_EN  |=  0x1f;
+
+        outl((inl(0x70000014) & ~(0x3ffff)) | 0x255aa, 0x70000014);
+    }
+#endif
+}
+
+bool card_detect_target(void)
+{
+#ifdef IPOD_E200
+   return (GPIOA_INPUT_VAL & 0x80) == 0; /* low active */
+#elif defined IPOD_C200
+   return (GPIOL_INPUT_VAL & 0x08) != 0; /* high active */
+#endif
+}
+
+static void sd_init_device(int card_no)
+{
+/* SD Protocol registers */
+#ifdef HAVE_HOTSWAP
+    unsigned int response = 0;
+#endif
+    unsigned int  i;
+    unsigned int  c_size;
+    unsigned long c_mult;
+    unsigned char carddata[512];
+    unsigned char *dataptr;
+    int ret;
+
+/* Enable and initialise controller */
+    REG_1 = 6;
+
+/* Initialise card data as blank */
+    memset(currcard, 0, sizeof(*currcard));
+
+/* Switch card mux to card to initialize */
+    sd_card_mux(card_no);
+
+/* Init NAND */
+    REG_11 |=  (1 << 15);
+    REG_12 |=  (1 << 15);
+    REG_12 &= ~(3 << 12);
+    REG_12 |=  (1 << 13);
+    REG_11 &= ~(3 << 12);
+    REG_11 |=  (1 << 13);
+
+    DEV_EN |= DEV_ATA; /* Enable controller */
+    DEV_RS |= DEV_ATA; /* Reset controller */
+    DEV_RS &=~DEV_ATA; /* Clear Reset */
+
+    SD_STATE_REG = TRAN;
+
+    REG_5 = 0xf;
+
+    ret = sd_command(GO_IDLE_STATE, 0, NULL, 256);
+    if (ret < 0)
+        goto card_init_error;
+
+    check_time[EC_POWER_UP] = USEC_TIMER;
+
+#ifdef HAVE_HOTSWAP
+    /* Check for SDHC:
+       - non-SDHC cards simply ignore SEND_IF_COND (CMD8) and we get error -219,
+         which we can just ignore and assume we're dealing with standard SD.
+       - SDHC cards echo back the argument into the response. This is how we
+         tell if the card is SDHC.
+     */
+    ret = sd_command(SEND_IF_COND,0x1aa, &response,7);
+    if ( (ret < 0) && (ret!=-219) )
+            goto card_init_error;
+#endif
+
+    while ((currcard->ocr & (1 << 31)) == 0) /* until card is powered up */
+    {
+        ret = sd_command(APP_CMD, currcard->rca, NULL, 1);
+        if (ret < 0)
+            goto card_init_error;
+
+#ifdef HAVE_HOTSWAP
+        if(response == 0x1aa)
+        {
+            /* SDHC */
+            ret = sd_command(SD_APP_OP_COND, (1<<30)|0x100000,
+                             &currcard->ocr, 3);
+        }
+        else
+#endif /* HAVE_HOTSWAP */
+        {
+            /* SD Standard */
+            ret = sd_command(SD_APP_OP_COND, 0x100000, &currcard->ocr, 3);
+        }
+
+        if (ret < 0)
+            goto card_init_error;
+
+        if (!sd_check_timeout(5000000, EC_POWER_UP))
+        {
+            ret = -EC_POWER_UP;
+            goto card_init_error;
+        }
+    }
+
+    ret = sd_command(ALL_SEND_CID, 0, currcard->cid, 2);
+    if (ret < 0)
+        goto card_init_error;
+
+    ret = sd_command(SEND_RELATIVE_ADDR, 0, &currcard->rca, 1);
+    if (ret < 0)
+        goto card_init_error;
+
+    ret = sd_command(SEND_CSD, currcard->rca, currcard->csd, 2);
+    if (ret < 0)
+        goto card_init_error;
+
+
+    /* These calculations come from the Sandisk SD card product manual */
+    if( (currcard->csd[3]>>30) == 0)
+    {
+        /* CSD version 1.0 */
+        c_size = ((currcard->csd[2] & 0x3ff) << 2) + (currcard->csd[1]>>30) + 1;
+        c_mult = 4 << ((currcard->csd[1] >> 15) & 7);
+        currcard->max_read_bl_len = 1 << ((currcard->csd[2] >> 16) & 15);
+        currcard->block_size = SD_BLOCK_SIZE;     /* Always use 512 byte blocks */
+        currcard->numblocks = c_size * c_mult * (currcard->max_read_bl_len/512);
+        currcard->capacity = (uint64_t)currcard->numblocks * (uint64_t)currcard->block_size;
+    }
+#ifdef HAVE_HOTSWAP
+    else if( (currcard->csd[3]>>30) == 1)
+    {
+        /* CSD version 2.0 */
+        c_size = ((currcard->csd[2] & 0x3f) << 16) + (currcard->csd[1]>>16) + 1;
+        currcard->max_read_bl_len = 1 << ((currcard->csd[2] >> 16) & 0xf);
+        currcard->block_size = SD_BLOCK_SIZE;     /* Always use 512 byte blocks */
+        currcard->numblocks = c_size;
+        currcard->capacity = currcard->numblocks * currcard->block_size;
+    }
+#endif /* HAVE_HOTSWAP */
+    
+    REG_1 = 0;
+
+    ret = sd_command(SELECT_CARD, currcard->rca, NULL, 129);
+    if (ret < 0)
+        goto card_init_error;
+
+    ret = sd_command(APP_CMD, currcard->rca, NULL, 1);
+    if (ret < 0)
+        goto card_init_error;
+
+    ret = sd_command(SET_BUS_WIDTH, currcard->rca | 2, NULL, 1); /* 4 bit */
+    if (ret < 0)
+        goto card_init_error;
+
+    ret = sd_command(SET_BLOCKLEN, currcard->block_size, NULL, 1);
+    if (ret < 0)
+        goto card_init_error;
+
+    BLOCK_SIZE_REG = currcard->block_size;
+
+    /* If this card is >4GB & not SDHC, then we need to enable bank switching */
+    if( (currcard->numblocks >= BLOCKS_PER_BANK) &&
+        ((currcard->ocr & (1<<30)) == 0) )
+    {
+        SD_STATE_REG = TRAN;
+        BLOCK_COUNT_REG = 1;
+
+        ret = sd_command(SWITCH_FUNC, 0x80ffffef, NULL, 0x1c05);
+        if (ret < 0)
+            goto card_init_error;
+
+        /* Read 512 bytes from the card.
+        The first 512 bits contain the status information
+        TODO: Do something useful with this! */
+        dataptr = carddata;
+        for (i = 0; i < SD_BLOCK_SIZE/2; i += FIFO_LEN)
+        {
+            /* Wait for the FIFO to be full */
+            if (sd_poll_status(FIFO_FULL, 100000))
+            {
+                copy_read_sectors_slow(&dataptr);
+                continue;
+            }
+
+            ret = -EC_FIFO_ENA_BANK_EMPTY;
+            goto card_init_error;
+        }
+    }
+    
+/*    hd_sizes[card_no] = currcard->capacity;
+    hd_blocksizes[card_no] = currcard->block_size;
+    hd[card_no].nr_sects = currcard->numblocks;
+    
+    hd_hardsectsizes = 
+       hd_maxsect =    
+       //    hardsect_size[MAJOR_NR] = hd_hardsectsizes;
+       //    max_sectors[MAJOR_NR] = hd_maxsect;
+*/
+    currcard->initialized = 1;
+    return;
+
+    /* Card failed to initialize so disable it */
+card_init_error:
+    currcard->initialized = ret;
+}
+
+/* lock must already be aquired */
+static void sd_select_device(int card_no)
+{
+    currcard = &card_info[card_no];
+
+    if (card_no == 0)
+    {
+        /* Main card always gets a chance */
+        sd_status[0].retry = 0;
+    }
+
+    if (currcard->initialized > 0)
+    {
+        /* This card is already initialized - switch to it */
+        sd_card_mux(card_no);
+        return;
+    }
+
+    if (currcard->initialized == 0)
+    {
+        /* Card needs (re)init */
+        sd_init_device(card_no);
+    }
+}
+
+
+int sd_read_sectors(int drive, unsigned long start, int incount,
+                     void* inbuf)
+{
+    int ret;
+    unsigned char *buf, *buf_end;
+    int bank;
+
+    /* TODO: Add DMA support. */
+
+    spin_lock(&sd_spin);
+ata_read_retry:
+    if (drive != 0 && !card_detect_target())
+    {
+        /* no external sd-card inserted */
+        ret = -EC_NOCARD;
+        goto ata_read_error;
+    }
+
+    sd_select_device(drive);
+
+    if (currcard->initialized < 0)
+    {
+        ret = currcard->initialized;
+        goto ata_read_error;
+    }
+
+//    last_disk_activity = current_tick;
+
+    /* Only switch banks with non-SDHC cards */
+    if((currcard->ocr & (1<<30))==0)
+    {
+        bank = start / BLOCKS_PER_BANK;
+
+        if (currcard->current_bank != bank)
+        {
+            ret = sd_select_bank(bank);
+            if (ret < 0)
+                goto ata_read_error;
+        }
+    
+        start -= bank * BLOCKS_PER_BANK;
+    }
+
+    ret = sd_wait_for_state(TRAN, EC_TRAN_READ_ENTRY);
+    if (ret < 0)
+        goto ata_read_error;
+
+    BLOCK_COUNT_REG = incount;
+
+#ifdef HAVE_HOTSWAP
+    if(currcard->ocr & (1<<30) )
+    {
+        /* SDHC */
+        ret = sd_command(READ_MULTIPLE_BLOCK, start, NULL, 0x1c25);
+    }
+    else
+#endif
+    {
+        ret = sd_command(READ_MULTIPLE_BLOCK, start * SD_BLOCK_SIZE, NULL, 0x1c25);
+    }
+    if (ret < 0)
+        goto ata_read_error;
+
+    /* TODO: Don't assume BLOCK_SIZE == SECTOR_SIZE */
+
+    buf_end = (unsigned char *)inbuf + incount * currcard->block_size;
+    for (buf = inbuf; buf < buf_end;)
+    {
+        /* Wait for the FIFO to be full */
+        if (sd_poll_status(FIFO_FULL, 0x80000))
+        {
+            copy_read_sectors_fast(&buf); /* Copy one chunk of 16 words */
+            /* TODO: Switch bank if necessary */
+            continue;
+        }
+
+        ret = -EC_FIFO_READ_FULL;
+        goto ata_read_error;
+    }
+
+//    last_disk_activity = current_tick;
+
+    ret = sd_command(STOP_TRANSMISSION, 0, NULL, 1);
+    if (ret < 0)
+        goto ata_read_error;
+
+    ret = sd_wait_for_state(TRAN, EC_TRAN_READ_EXIT);
+    if (ret < 0)
+        goto ata_read_error;
+
+    while (1)
+    {
+        spin_unlock(&sd_spin);
+
+        return ret;
+
+ata_read_error:
+        if (sd_status[drive].retry < sd_status[drive].retry_max
+            && ret != -EC_NOCARD)
+        {
+            sd_status[drive].retry++;
+            currcard->initialized = 0;
+            goto ata_read_retry;
+        }
+    }
+}
+
+int sd_write_sectors(int drive, unsigned long start, int count,
+                      const void* outbuf)
+{
+/* Write support is not finished yet */
+/* TODO: The standard suggests using ACMD23 prior to writing multiple blocks
+   to improve performance */
+    int ret;
+    const unsigned char *buf, *buf_end;
+    int bank;
+
+    spin_lock(&sd_spin);
+
+ata_write_retry:
+    if (drive != 0 && !card_detect_target())
+    {
+        /* no external sd-card inserted */
+        ret = -EC_NOCARD;
+        goto ata_write_error;
+    }
+
+    sd_select_device(drive);
+
+    if (currcard->initialized < 0)
+    {
+        ret = currcard->initialized;
+        goto ata_write_error;
+    }
+
+    /* Only switch banks with non-SDHC cards */
+    if((currcard->ocr & (1<<30))==0)
+    {
+        bank = start / BLOCKS_PER_BANK;
+
+        if (currcard->current_bank != bank)
+        {
+            ret = sd_select_bank(bank);
+            if (ret < 0)
+                goto ata_write_error;
+        }
+    
+        start -= bank * BLOCKS_PER_BANK;
+    }
+
+    check_time[EC_WRITE_TIMEOUT] = USEC_TIMER;
+
+    ret = sd_wait_for_state(TRAN, EC_TRAN_WRITE_ENTRY);
+    if (ret < 0)
+        goto ata_write_error;
+
+    BLOCK_COUNT_REG = count;
+
+#ifdef HAVE_HOTSWAP
+    if(currcard->ocr & (1<<30) )
+    {
+        /* SDHC */
+        ret = sd_command(WRITE_MULTIPLE_BLOCK, start, NULL, 0x1c2d);
+    }
+    else
+#endif
+    {
+        ret = sd_command(WRITE_MULTIPLE_BLOCK, start*SD_BLOCK_SIZE, NULL, 0x1c2d);
+    }
+    if (ret < 0)
+        goto ata_write_error;
+
+    buf_end = outbuf + count * currcard->block_size - 2*FIFO_LEN;
+
+    for (buf = outbuf; buf <= buf_end;)
+    {
+        if (buf == buf_end)
+        {
+            /* Set SD_STATE_REG to PRG for the last buffer fill */
+            SD_STATE_REG = PRG;
+        }
+
+        udelay(2); /* needed here (loop is too fast :-) */
+
+        /* Wait for the FIFO to empty */
+        if (sd_poll_status(FIFO_EMPTY, 0x80000))
+        {
+            copy_write_sectors(&buf); /* Copy one chunk of 16 words */
+            /* TODO: Switch bank if necessary */
+            continue;
+        }
+
+        ret = -EC_FIFO_WR_EMPTY;
+        goto ata_write_error;
+    }
+
+//    last_disk_activity = current_tick;
+
+    if (!sd_poll_status(DATA_DONE, 0x80000))
+    {
+        ret = -EC_FIFO_WR_DONE;
+        goto ata_write_error;
+    }
+
+    ret = sd_command(STOP_TRANSMISSION, 0, NULL, 1);
+    if (ret < 0)
+        goto ata_write_error;
+
+    ret = sd_wait_for_state(TRAN, EC_TRAN_WRITE_EXIT);
+    if (ret < 0)
+        goto ata_write_error;
+
+    while (1)
+    {
+        spin_unlock(&sd_spin);
+
+        return ret;
+
+ata_write_error:
+        if (sd_status[drive].retry < sd_status[drive].retry_max
+            && ret != -EC_NOCARD)
+        {
+            sd_status[drive].retry++;
+            currcard->initialized = 0;
+            goto ata_write_retry;
+        }
+    }
+}
+#if 0
+static void sd_thread(void) __attribute__((noreturn));
+static void sd_thread(void)
+{
+    struct queue_event ev;
+    bool idle_notified = false;
+    
+    while (1)
+    {
+        queue_wait_w_tmo(&sd_queue, &ev, HZ);
+
+        switch ( ev.id ) 
+        {
+#ifdef HAVE_HOTSWAP
+        case SD_HOTSWAP:
+        {
+            int action = SDA_NONE;
+
+            /* Lock to keep us from messing with this variable while an init
+               may be in progress */
+            spin_lock(&sd_spin);
+            card_info[1].initialized = 0;
+            sd_status[1].retry = 0;
+
+            /* Either unmount because the card was pulled or unmount and
+               remount if already mounted since multiple messages may be
+               generated for the same event - like someone inserting a new
+               card before anything detects the old one pulled :) */
+            if (disk_unmount(1) != 0)  /* release "by force" */
+                action |= SDA_UNMOUNTED;
+
+            if (ev.data != 0 && disk_mount(1) != 0) /* mount SD-CARD */
+                action |= SDA_MOUNTED;
+
+            if (action & SDA_UNMOUNTED)
+                queue_broadcast(SYS_HOTSWAP_EXTRACTED, 0);
+
+            if (action & SDA_MOUNTED)
+                queue_broadcast(SYS_HOTSWAP_INSERTED, 0);
+
+            if (action != SDA_NONE)
+                queue_broadcast(SYS_FS_CHANGED, 0);
+
+            spin_unlock(&sd_spin);
+            break;
+            } /* SD_HOTSWAP */
+#endif /* HAVE_HOTSWAP */
+        case SYS_TIMEOUT:
+            if (TIME_BEFORE(current_tick, last_disk_activity+(3*HZ)))
+            {
+                idle_notified = false;
+            }
+            else
+            {
+                /* never let a timer wrap confuse us */
+                next_yield = USEC_TIMER;
+
+                if (!idle_notified)
+                {
+                    call_ata_idle_notifys(false);
+                    idle_notified = true;
+                }
+            }
+            break;
+        case SYS_USB_CONNECTED:
+            usb_acknowledge(SYS_USB_CONNECTED_ACK);
+            /* Wait until the USB cable is extracted again */
+            usb_wait_for_disconnect(&sd_queue);
+            break;
+        }
+    }
+}
+#endif
+void sd_enable(bool on)
+{
+    if(on)
+    {
+        DEV_EN |= DEV_ATA; /* Enable controller */
+    }
+    else
+    {
+        DEV_EN &= ~DEV_ATA; /* Disable controller */
+    }
+}
+
+
+int sd_HwInit(void)
+{
+    int ret = 0;
+
+    /* NOTE: This init isn't dual core safe */
+    if (!initialized)
+    {
+        initialized = true;
+
+        spin_lock_init(&sd_spin);// IF_COP(, SPINLOCK_TASK_SWITCH));
+
+        spin_lock(&sd_spin);
+
+        sd_enable(true);
+        /* init controller */
+        outl(inl(0x70000088) & ~(0x4), 0x70000088);
+        outl(inl(0x7000008c) & ~(0x4), 0x7000008c);
+        GPO32_ENABLE |= 0x4;
+
+        GPIOG_ENABLE     |= (0x3 << 5);
+        GPIOG_OUTPUT_EN  |= (0x3 << 5);
+        GPIOG_OUTPUT_VAL |= (0x3 << 5);
+
+#ifdef HAVE_HOTSWAP
+        /* enable card detection port - mask interrupt first */
+#ifdef IPOD_E200
+        GPIOA_INT_EN     &= ~0x80;
+
+        GPIOA_OUTPUT_EN  &= ~0x80;
+        GPIOA_ENABLE     |=  0x80;
+#elif defined IPOD_C200
+        GPIOL_INT_EN     &= ~0x08;
+
+        GPIOL_OUTPUT_EN  &= ~0x08;
+        GPIOL_ENABLE     |=  0x08;
+#endif
+#endif
+        sd_select_device(0);
+
+        if (currcard->initialized < 0)
+            ret = currcard->initialized;
+
+ //       queue_init(&sd_queue, true);
+ //       create_thread(sd_thread, sd_stack, sizeof(sd_stack), 0,
+//            sd_thread_name IF_PRIO(, PRIORITY_SYSTEM) IF_COP(, CPU));
+
+        /* enable interupt for the mSD card */
+        mdelay(100);
+#ifdef HAVE_HOTSWAP
+#ifdef IPOD_E200
+        CPU_INT_EN = HI_MASK;
+        CPU_HI_INT_EN = GPIO0_MASK;
+
+        GPIOA_INT_LEV = (GPIOA_INT_LEV & ~0x80) | (~GPIOA_INPUT_VAL & 0x80);
+
+        GPIOA_INT_CLR = 0x80;
+        GPIOA_INT_EN |= 0x80;
+#elif defined IPOD_C200
+        CPU_INT_EN = HI_MASK;
+        CPU_HI_INT_EN = GPIO2_MASK;
+
+        GPIOL_INT_LEV = (GPIOL_INT_LEV & ~0x08) | (~GPIOL_INPUT_VAL & 0x08);
+
+        GPIOL_INT_CLR = 0x08;
+        GPIOL_INT_EN |= 0x08;
+#endif
+#endif
+        spin_unlock(&sd_spin);
+    }
+
+    return ret;
+}
+#if 0
+/* move the sd-card info to mmc struct */
+tCardInfo *card_get_info_target(int card_no)
+{
+    int i, temp;
+    static tCardInfo card;
+    static const char mantissa[] = {  /* *10 */
+        0,  10, 12, 13, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 70, 80 };
+    static const int exponent[] = {  /* use varies */
+      1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000 };
+
+    card.initialized  = card_info[card_no].initialized;
+    card.ocr          = card_info[card_no].ocr;
+    for(i=0; i<4; i++)  card.csd[i] = card_info[card_no].csd[3-i];
+    for(i=0; i<4; i++)  card.cid[i] = card_info[card_no].cid[3-i];
+    card.numblocks    = card_info[card_no].numblocks;
+    card.blocksize    = card_info[card_no].block_size;
+    card.size         = card_info[card_no].capacity < 0xffffffff ?
+                        card_info[card_no].capacity : 0xffffffff;
+    card.block_exp    = card_info[card_no].block_exp;
+    temp              = card_extract_bits(card.csd, 29, 3);
+    card.speed        = mantissa[card_extract_bits(card.csd, 25, 4)]
+                      * exponent[temp > 2 ? 7 : temp + 4];
+    card.nsac         = 100 * card_extract_bits(card.csd, 16, 8);
+    temp              = card_extract_bits(card.csd, 13, 3);
+    card.tsac         = mantissa[card_extract_bits(card.csd, 9, 4)]
+                      * exponent[temp] / 10;
+    card.cid[0]       = htobe32(card.cid[0]); /* ascii chars here */
+    card.cid[1]       = htobe32(card.cid[1]); /* ascii chars here */
+    temp = *((char*)card.cid+13); /* adjust year<=>month, 1997 <=> 2000 */
+    *((char*)card.cid+13) = (unsigned char)((temp >> 4) | (temp << 4)) + 3;
+
+    return &card;
+}
+#endif
+
+#ifdef HAVE_HOTSWAP
+static bool sd1_oneshot_callback(struct timeout *tmo)
+{
+    /* Take final state only - insert/remove is bouncy */
+    queue_remove_from_head(&sd_queue, SD_HOTSWAP);
+    queue_post(&sd_queue, SD_HOTSWAP, tmo->data);
+    return false;
+}
+
+/* called on insertion/removal interrupt */
+void microsd_int(void)
+{
+    static struct timeout sd1_oneshot;
+
+#ifdef IPOD_E200
+    int detect = GPIOA_INPUT_VAL & 0x80;
+
+    GPIOA_INT_LEV = (GPIOA_INT_LEV & ~0x80) | (detect ^ 0x80);
+    GPIOA_INT_CLR = 0x80;
+
+    timeout_register(&sd1_oneshot, sd1_oneshot_callback,
+                     detect ? 1 : HZ/2, detect == 0);
+#elif defined IPOD_C200
+    int detect = GPIOL_INPUT_VAL & 0x08;
+
+    GPIOL_INT_LEV = (GPIOL_INT_LEV & ~0x08) | (detect ^ 0x08);
+    GPIOL_INT_CLR = 0x08;
+
+    timeout_register(&sd1_oneshot, sd1_oneshot_callback,
+                     detect ? HZ/2 : 1, detect != 0);
+#endif
+
+}
+#endif /* HAVE_HOTSWAP */
+
+static void sd_request(request_queue_t *q)
+{
+   unsigned int sd_address;
+   unsigned char *buffer_address;
+   unsigned int dev;
+   int nr_sectors;
+   int cmd;
+   int code;
+   
+   (void)q;
+   while (1)
+   {
+      code = 1; // Default is success
+      INIT_REQUEST;
+      sd_address = (CURRENT->sector + hd[MINOR(CURRENT->rq_dev)].start_sect);// * hd_hardsectsizes[0];
+      buffer_address = CURRENT->buffer;
+      nr_sectors = CURRENT->current_nr_sectors;
+      cmd = CURRENT->cmd;
+
+      
+      dev = MINOR(CURRENT->rq_dev);
+      if( CURRENT->sector >= hd[dev].nr_sects || ((CURRENT->sector+CURRENT->nr_sectors) > hd[dev].nr_sects))
+//      if (((CURRENT->sector + CURRENT->current_nr_sectors + hd[MINOR(CURRENT->rq_dev)].start_sect) > hd[0].nr_sects))
+      {
+         code = 0;
+      }
+      else if (cmd == READ)
+      {
+         spin_unlock_irq(&io_request_lock);
+         if(sd_read_sectors(0, sd_address, nr_sectors, buffer_address) != 0)
+            code = 0;
+         spin_lock_irq(&io_request_lock);
+      }
+      else if (cmd == WRITE)
+      {
+         spin_unlock_irq(&io_request_lock);
+         if(sd_write_sectors(0, sd_address, nr_sectors, buffer_address) != 0)
+            code = 0;
+         spin_lock_irq(&io_request_lock);
+      }
+      else
+      {
+         code = 0;
+      }
+      end_request(code);
+   }
+}
+
+extern struct gendisk hd_gendisk;
+static int sd_revalidate(kdev_t dev)
+{
+   int target, max_p, start, i;
+//   if (mmc_media_detect == 0) return -ENODEV;
+   
+   target = DEVICE_NR(dev);
+   
+   max_p = hd_gendisk.max_p;
+   start = target << 6;
+   for (i = max_p - 1; i >= 0; i--) {
+      int minor = start + i;
+      invalidate_device(MKDEV(MAJOR_NR, minor), 1);
+      hd_gendisk.part[minor].start_sect = 0;
+      hd_gendisk.part[minor].nr_sects = 0;
+   }
+   
+   grok_partitions(&hd_gendisk, target, 1 << 6,
+      hd_sizes[0]);
+   
+   return 0;
+}
+
+
+static int sd_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
+{
+   if (!inode || !inode->i_rdev)
+      return -EINVAL;
+   
+   switch(cmd) {
+   case BLKGETSIZE:
+      return put_user(hd[MINOR(inode->i_rdev)].nr_sects, (unsigned long *)arg);
+   case BLKGETSIZE64:
+      return put_user((u64)hd[MINOR(inode->i_rdev)].
+         nr_sects, (u64 *) arg);
+   case BLKRRPART:
+      if (!capable(CAP_SYS_ADMIN))
+         return -EACCES;
+      
+      return sd_revalidate(inode->i_rdev);
+   case HDIO_GETGEO:
+      {
+         struct hd_geometry *loc, g;
+         loc = (struct hd_geometry *) arg;
+         if (!loc)
+            return -EINVAL;
+         g.heads = 4;
+         g.sectors = 16;
+         g.cylinders = hd[0].nr_sects / (4 * 16);
+         g.start = hd[MINOR(inode->i_rdev)].start_sect;
+         return copy_to_user(loc, &g, sizeof(g)) ? -EFAULT : 0;
+      }
+   default:
+      return blk_ioctl(inode->i_rdev, cmd, arg);
+      return -1;
+   }
+}
+
+static int sd_open(struct inode *inode, struct file *filp)
+{
+#if defined(MODULE)
+   MOD_INC_USE_COUNT;
+#endif
+   return 0;
+}
+
+static int sd_release(struct inode *inode, struct file *filp)
+{
+#if defined(MODULE)
+   MOD_DEC_USE_COUNT;
+#endif
+   return 0;
+}
+
+static struct block_device_operations sd_bdops = 
+{
+   open: sd_open,
+   release: sd_release,
+   ioctl: sd_ioctl
+};
+
+static struct gendisk hd_gendisk = 
+{
+//   major:		MAJOR_NR,
+   major_name:	DEVICE_NAME,
+   minor_shift:	6,
+   max_p:		1 << 6,
+   part:		hd,
+   sizes:		hd_sizes,
+   fops:		&sd_bdops,
+};
+
+
+static void sd_initDisk()
+{
+   int i;
+   memset(hd_sizes, 0, sizeof(hd_sizes));
+   
+   hd_sizes[0] = (int)(currcard->capacity/1024);
+  
+   for(i=0; i<(1<<6); i++) {
+      hd_blocksizes[i] = SD_BLOCK_SIZE;
+      hd_hardsectsizes[i] = SD_SECTOR_SIZE;
+      hd_maxsect[i] = currcard->max_read_bl_len;
+   }
+
+   blk_size[MAJOR_NR] = hd_sizes;
+   blksize_size[MAJOR_NR] = hd_blocksizes;
+   hardsect_size[MAJOR_NR] = hd_hardsectsizes;
+   max_sectors[MAJOR_NR] = hd_maxsect;
+   
+//   blksize_size[MAJOR_NR][DEVICE_NR(0)] = SD_BLOCK_SIZE;
+//   hardsect_size[MAJOR_NR][DEVICE_NR(0)] = SD_SECTOR_SIZE;
+//   max_sectors[MAJOR_NR][DEVICE_NR(0)] = currcard->max_read_bl_len;
+//   blk_size[MAJOR_NR][DEVICE_NR(0)] = (int)(currcard->capacity/1024);
+   
+   memset(hd, 0, sizeof(hd));
+   hd[0].nr_sects = currcard->numblocks;
+   
+   hd_gendisk.nr_real = 1;
+
+/*
+printk("hd_sizes:%u\n",hd_sizes[0]);
+printk("hd_maxsect:%u\n",hd_maxsect[0]);
+printk("hd_hardsectsizes:%u\n",hd_hardsectsizes[0]);
+printk("hd_blocksizes:%u\n",hd_blocksizes[0]);
+printk("numblocks:%u\n",currcard->numblocks);
+printk("block_size:%u\n",currcard->block_size);
+mdelay(5000);
+*/
+
+
+   register_disk(&hd_gendisk, MKDEV(MAJOR_NR,0), 1<<6,
+                 &sd_bdops, hd_sizes[0]); //*2  
+   //hd_maxsect[0]/**2*/);
+
+}
+
+
+static void sd_exit(void)
+{
+   blk_size[MAJOR_NR] = NULL;
+   blksize_size[MAJOR_NR] = NULL;
+   hardsect_size[MAJOR_NR] = NULL;
+   max_sectors[MAJOR_NR] = NULL;
+   hd[0].nr_sects = 0;
+}
+
+int __init sd_driver_init(void)
+{
+	int rc;
+   printk("iPod SD-Flash driver Copyright (C) 2006-2008 Daniel Ankers, Bernard Leach\n");   
+
+   rc = register_blkdev(MAJOR_NR, DEVICE_NAME, &sd_bdops);
+	if (rc < 0)
+	{
+		printk(KERN_WARNING "sd: can't get major %d\n", MAJOR_NR);
+		return rc;
+	}
+   nr_major = rc;
+   hd_gendisk.major = MAJOR_NR;
+
+   blk_init_queue(BLK_DEFAULT_QUEUE(MAJOR_NR), sd_request);
+   
+	read_ahead[MAJOR_NR] = 8;
+   add_gendisk(&hd_gendisk);
+   sd_HwInit();
+   sd_initDisk();
+
+	return 0;
+}
+
+void __exit sd_driver_exit(void)
+{
+	int i;
+
+	for (i = 0; i < (1 << 6); i++)
+		fsync_dev(MKDEV(MAJOR_NR, i));
+
+	blk_cleanup_queue(BLK_DEFAULT_QUEUE(MAJOR_NR));
+	del_gendisk(&hd_gendisk);
+   unregister_blkdev(MAJOR_NR, DEVICE_NAME);
+	sd_exit();
+}
+
+#ifdef MODULE
+MODULE_AUTHOR("Bernard Leach <Sebastian.Duell@ipodlinux.org>");
+MODULE_DESCRIPTION("iPod e200 Flash driver");
+MODULE_LICENSE("GPL");
+#endif
+
+module_exit(sd_driver_exit);
+
diff -urN arch/armnommu/mach-ipod/time.c arch/armnommu/mach-ipod/time.c
--- arch/armnommu/mach-ipod/time.c	2008-10-10 03:49:22.000000000 -0400
+++ arch/armnommu/mach-ipod/time.c	2008-10-10 03:43:43.000000000 -0400
@@ -1,7 +1,7 @@
 /*
  * time.c - timer support for iPod
  *
- * Copyright (c) 2003, Bernard Leach (leachbj@bouncycastle.org)
+ * Copyright (c) 2003-2005, Bernard Leach (leachbj@bouncycastle.org)
  */
 
 #include <linux/config.h>
@@ -19,13 +19,17 @@
 	return 0;
 }
 
-
 /*
  * Get the number of useconds since the last interrupt
  */
-extern unsigned long ipod_gettimeoffset(void)
+extern unsigned long pp5002_gettimeoffset(void)
+{
+	return USECS_PER_INT - (inl(PP5002_TIMER1) & 0xffff);
+}
+
+extern unsigned long pp5020_gettimeoffset(void)
 {
-	return USECS_PER_INT - (inl(IPOD_TIMER0) & 0xffff);
+	return USECS_PER_INT - (inl(PP5020_TIMER1) & 0xffff);
 }
 
 extern void ipod_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
diff -urN drivers/block/ll_rw_blk.c drivers/block/ll_rw_blk.c
--- drivers/block/ll_rw_blk.c	2003-11-28 13:26:19.000000000 -0500
+++ drivers/block/ll_rw_blk.c	2008-10-10 03:43:43.000000000 -0400
@@ -1499,6 +1499,10 @@
 		complete(waiting);
 }
 
+#ifdef CONFIG_ARCH_IPOD
+extern int sd_driver_init(void);
+#endif
+
 int __init blk_dev_init(void)
 {
 	struct blk_dev_struct *dev;
@@ -1618,6 +1622,10 @@
 #ifdef CONFIG_SUN_JSFLASH
 	jsfd_init();
 #endif
+
+#ifdef CONFIG_ARCH_IPOD
+   sd_driver_init();
+#endif
 	return 0;
 };
 
diff -urN drivers/char/serial.c drivers/char/serial.c
--- drivers/char/serial.c	2008-10-10 03:49:22.000000000 -0400
+++ drivers/char/serial.c	2008-10-10 03:30:29.000000000 -0400
@@ -5726,9 +5726,6 @@
 #ifdef CONFIG_IXP425_DTR0
 	rs_ixp425gpio();
 #endif
-#ifdef CONFIG_ARCH_IPOD
-	ipod_serial_init();
-#endif
 
 	/* Initialize the tty_driver structure */
 	
diff -urN drivers/ieee1394/Config.in drivers/ieee1394/Config.in
--- drivers/ieee1394/Config.in	2008-10-10 03:49:22.000000000 -0400
+++ drivers/ieee1394/Config.in	2003-08-25 07:44:41.000000000 -0400
@@ -1,10 +1,10 @@
 # -*- shell-script -*-
 
-if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
+if [ "$CONFIG_PCI" = "y" -a "$CONFIG_EXPERIMENTAL" = "y" ]; then
     mainmenu_option next_comment
     comment 'IEEE 1394 (FireWire) support (EXPERIMENTAL)'
 
-    tristate 'IEEE 1394 (FireWire) support (EXPERIMENTAL)' CONFIG_IEEE1394
+    dep_tristate 'IEEE 1394 (FireWire) support (EXPERIMENTAL)' CONFIG_IEEE1394 $CONFIG_PCI
 
     if [ "$CONFIG_IEEE1394" != "n" ]; then
 
@@ -13,7 +13,7 @@
 	if [ "$CONFIG_I2C" = "n" -o "$CONFIG_I2C_ALGOBIT" = "n" ]; then
 	    comment '  Texas Instruments PCILynx requires I2C bit-banging'
 	else
-	    dep_tristate '  Texas Instruments PCILynx support' CONFIG_IEEE1394_PCILYNX $CONFIG_IEEE1394 $CONFIG_I2C $CONFIG_I2C_ALGOBIT $CONFIG_PCI
+	    dep_tristate '  Texas Instruments PCILynx support' CONFIG_IEEE1394_PCILYNX $CONFIG_IEEE1394 $CONFIG_I2C $CONFIG_I2C_ALGOBIT
 	fi
 
 	# Non-maintained pcilynx options
@@ -22,8 +22,7 @@
 	#     bool '    Support for non-IEEE1394 local ports' CONFIG_IEEE1394_PCILYNX_PORTS
 	# fi
 
-	dep_tristate '  OHCI-1394 support' CONFIG_IEEE1394_OHCI1394 $CONFIG_IEEE1394 $CONFIG_PCI
-	dep_tristate '  iPod IEEE1394 support (TI TSB43AA82)' CONFIG_IEEE1394_IPOD $CONFIG_IEEE1394
+	dep_tristate '  OHCI-1394 support' CONFIG_IEEE1394_OHCI1394 $CONFIG_IEEE1394
 
 	comment "Protocol Drivers"
 	dep_tristate '  OHCI-1394 Video support' CONFIG_IEEE1394_VIDEO1394 $CONFIG_IEEE1394_OHCI1394
diff -urN drivers/ieee1394/dma.c drivers/ieee1394/dma.c
--- drivers/ieee1394/dma.c	2008-10-10 03:49:22.000000000 -0400
+++ drivers/ieee1394/dma.c	2003-08-25 07:44:41.000000000 -0400
@@ -184,8 +184,6 @@
 	pci_dma_sync_sg(dma->dev, &dma->sglist[first], last - first + 1, dma->direction);
 }
 
-#ifndef CONFIG_ARCH_IPOD
-
 /* nopage() handler for mmap access */
 
 static struct page*
@@ -239,5 +237,3 @@
 
 	return 0;
 }
-
-#endif /* CONFIG_ARCH_IPOD */
diff -urN drivers/ieee1394/eth1394.c drivers/ieee1394/eth1394.c
--- drivers/ieee1394/eth1394.c	2008-10-10 03:49:22.000000000 -0400
+++ drivers/ieee1394/eth1394.c	2003-11-28 13:26:20.000000000 -0500
@@ -1,8 +1,9 @@
 /*
  * eth1394.c -- Ethernet driver for Linux IEEE-1394 Subsystem
  * 
- * Copyright (C) 2001 Ben Collins <bcollins@debian.org>
+ * Copyright (C) 2001-2003 Ben Collins <bcollins@debian.org>
  *               2000 Bonin Franck <boninf@free.fr>
+ *               2003 Steve Kinneberg <kinnebergsteve@acmsystems.com>
  *
  * Mainly based on work by Emanuel Pirker and Andreas E. Bombe
  *
@@ -21,22 +22,27 @@
  * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* State of this driver:
- *
- * This driver intends to support RFC 2734, which describes a method for
+/* This driver intends to support RFC 2734, which describes a method for
  * transporting IPv4 datagrams over IEEE-1394 serial busses. This driver
  * will ultimately support that method, but currently falls short in
- * several areas. A few issues are:
+ * several areas.
+ *
+ * TODO:
+ * RFC 2734 related:
+ * - Add Config ROM entry
+ * - Add MCAP. Limited Multicast exists only to 224.0.0.1 and 224.0.0.2.
  *
- *   - Does not support send/recv over Async streams using GASP
- *     packet formats, as per the RFC for ARP requests.
- *   - Does not yet support fragmented packets.
- *   - Relies on hardware address being equal to the nodeid for some things.
- *   - Does not support multicast
- *   - Hardcoded address for sending packets, instead of using discovery
- *     (ARP, see first item)
+ * Non-RFC 2734 related:
+ * - Handle fragmented skb's coming from the networking layer.
+ * - Move generic GASP reception to core 1394 code
+ * - Convert kmalloc/kfree for link fragments to use kmem_cache_* instead
+ * - Stability improvements
+ * - Performance enhancements
+ * - Change hardcoded 1394 bus address region to a dynamic memory space allocation
+ * - Consider garbage collecting old partial datagrams after X amount of time
  */
 
+
 #include <linux/module.h>
 
 #include <linux/sched.h>
@@ -53,11 +59,14 @@
 #include <linux/if_arp.h>
 #include <linux/if_ether.h>
 #include <linux/ip.h>
+#include <linux/in.h>
 #include <linux/tcp.h>
 #include <linux/skbuff.h>
+#include <linux/bitops.h>
+#include <linux/ethtool.h>
+#include <asm/uaccess.h>
 #include <asm/delay.h>
 #include <asm/semaphore.h>
-#include <asm/bitops.h>
 #include <net/arp.h>
 
 #include "ieee1394_types.h"
@@ -65,82 +74,191 @@
 #include "ieee1394_transactions.h"
 #include "ieee1394.h"
 #include "highlevel.h"
+#include "iso.h"
+#include "nodemgr.h"
 #include "eth1394.h"
 
 #define ETH1394_PRINT_G(level, fmt, args...) \
-	printk(level "%s: "fmt, driver_name, ## args)
+	printk(level "%s: " fmt, driver_name, ## args)
 
 #define ETH1394_PRINT(level, dev_name, fmt, args...) \
 	printk(level "%s: %s: " fmt, driver_name, dev_name, ## args)
 
 #define DEBUG(fmt, args...) \
-	printk(KERN_ERR fmt, ## args)
+	printk(KERN_ERR "%s:%s[%d]: " fmt "\n", driver_name, __FUNCTION__, __LINE__, ## args)
+#define TRACE() printk(KERN_ERR "%s:%s[%d] ---- TRACE\n", driver_name, __FUNCTION__, __LINE__)
 
 static char version[] __devinitdata =
-	"$Rev: 546 $ Ben Collins <bcollins@debian.org>";
+	"$Rev: 1043 $ Ben Collins <bcollins@debian.org>";
+
+struct fragment_info {
+	struct list_head list;
+	int offset;
+	int len;
+};
+
+struct partial_datagram {
+	struct list_head list;
+	u16 dgl;
+	u16 dg_size;
+	u16 ether_type;
+	struct sk_buff *skb;
+	char *pbuf;
+	struct list_head frag_info;
+};
 
 /* Our ieee1394 highlevel driver */
 static const char driver_name[] = "eth1394";
 
 static kmem_cache_t *packet_task_cache;
 
-/* Card handling */
-static LIST_HEAD (host_info_list);
-static spinlock_t host_info_lock = SPIN_LOCK_UNLOCKED;
+static struct hpsb_highlevel eth1394_highlevel;
 
 /* Use common.lf to determine header len */
-static int hdr_type_len[] = {
+static const int hdr_type_len[] = {
 	sizeof (struct eth1394_uf_hdr),
 	sizeof (struct eth1394_ff_hdr),
 	sizeof (struct eth1394_sf_hdr),
 	sizeof (struct eth1394_sf_hdr)
 };
 
-MODULE_AUTHOR("Ben Collins (bcollins@debian.org)");
-MODULE_DESCRIPTION("IEEE 1394 IPv4 Driver (IPv4-over-1394 as per RFC 2734)");
-MODULE_LICENSE("GPL");
+/* Change this to IEEE1394_SPEED_S100 to make testing easier */
+#define ETH1394_SPEED_DEF	IEEE1394_SPEED_MAX
 
-/* Find our host_info struct for a given host pointer. Must be called
- * under spinlock.  */
-static inline struct host_info *find_host_info (struct hpsb_host *host)
-{
-	struct list_head *lh;
-	struct host_info *hi;
+/* For now, this needs to be 1500, so that XP works with us */
+#define ETH1394_DATA_LEN	ETH_DATA_LEN
 
-	lh = host_info_list.next;
-	while (lh != &host_info_list) {
-		hi = list_entry (lh, struct host_info, list);
+static const u16 eth1394_speedto_maxpayload[] = {
+/*     S100, S200, S400, S800, S1600, S3200 */
+	512, 1024, 2048, 4096,  4096,  4096
+};
 
-		if (hi->host == host)
-			return hi;
+MODULE_AUTHOR("Ben Collins (bcollins@debian.org)");
+MODULE_DESCRIPTION("IEEE 1394 IPv4 Driver (IPv4-over-1394 as per RFC 2734)");
+MODULE_LICENSE("GPL");
 
-		lh = lh->next;
+/* The max_partial_datagrams parameter is the maximum number of fragmented
+ * datagrams per node that eth1394 will keep in memory.  Providing an upper
+ * bound allows us to limit the amount of memory that partial datagrams
+ * consume in the event that some partial datagrams are never completed.  This
+ * should probably change to a sysctl item or the like if possible.
+ */
+MODULE_PARM(max_partial_datagrams, "i");
+MODULE_PARM_DESC(max_partial_datagrams,
+		 "Maximum number of partially received fragmented datagrams "
+		 "(default = 25).");
+static int max_partial_datagrams = 25;
+
+
+static int ether1394_header(struct sk_buff *skb, struct net_device *dev,
+			    unsigned short type, void *daddr, void *saddr,
+			    unsigned len);
+static int ether1394_rebuild_header(struct sk_buff *skb);
+static int ether1394_header_parse(struct sk_buff *skb, unsigned char *haddr);
+static int ether1394_header_cache(struct neighbour *neigh, struct hh_cache *hh);
+static void ether1394_header_cache_update(struct hh_cache *hh,
+					  struct net_device *dev,
+					  unsigned char * haddr);
+static int ether1394_mac_addr(struct net_device *dev, void *p);
+
+static inline void purge_partial_datagram(struct list_head *old);
+static int ether1394_tx(struct sk_buff *skb, struct net_device *dev);
+static void ether1394_iso(struct hpsb_iso *iso);
+
+static int ether1394_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd);
+static int ether1394_ethtool_ioctl(struct net_device *dev, void *useraddr);
+
+static void eth1394_iso_shutdown(struct eth1394_priv *priv)
+{
+	priv->bc_state = ETHER1394_BC_CLOSED;
+
+	if (priv->iso != NULL) {
+		if (!in_interrupt())
+			hpsb_iso_shutdown(priv->iso);
+		priv->iso = NULL;
 	}
-	return NULL;
 }
 
-/* Find the network device for our host */
-static inline struct net_device *ether1394_find_dev (struct hpsb_host *host)
+static int ether1394_init_bc(struct net_device *dev)
 {
-	struct host_info *hi;
-
-	spin_lock_irq (&host_info_lock);
-	hi = find_host_info (host);
-	spin_unlock_irq (&host_info_lock);
-
-	if (hi == NULL)
-		return NULL;
+	struct eth1394_priv *priv = (struct eth1394_priv *)dev->priv;
 
-	return hi->dev;
+	/* First time sending?  Need a broadcast channel for ARP and for
+	 * listening on */
+	if (priv->bc_state == ETHER1394_BC_CHECK) {
+		quadlet_t bc;
+
+		/* Get the local copy of the broadcast channel and check its
+		 * validity (the IRM should validate it for us) */
+
+		bc = priv->host->csr.broadcast_channel;
+
+		if ((bc & 0xc0000000) != 0xc0000000) {
+			/* broadcast channel not validated yet */
+			ETH1394_PRINT(KERN_WARNING, dev->name,
+				      "Error BROADCAST_CHANNEL register valid "
+				      "bit not set, can't send IP traffic\n");
+
+			eth1394_iso_shutdown(priv);
+
+			return -EAGAIN;
+		}
+		if (priv->broadcast_channel != (bc & 0x3f)) {
+			/* This really shouldn't be possible, but just in case
+			 * the IEEE 1394 spec changes regarding broadcast
+			 * channels in the future. */
+
+			eth1394_iso_shutdown(priv);
+
+			if (in_interrupt())
+				return -EAGAIN;
+
+			priv->broadcast_channel = bc & 0x3f;
+			ETH1394_PRINT(KERN_INFO, dev->name,
+				      "Changing to broadcast channel %d...\n",
+				      priv->broadcast_channel);
+
+			priv->iso = hpsb_iso_recv_init(priv->host, 16 * 4096,
+						       16, priv->broadcast_channel,
+						       1, ether1394_iso);
+			if (priv->iso == NULL) {
+				ETH1394_PRINT(KERN_ERR, dev->name,
+					      "failed to change broadcast "
+					      "channel\n");
+				return -EAGAIN;
+			}
+		}
+		if (hpsb_iso_recv_start(priv->iso, -1, (1 << 3), -1) < 0) {
+			ETH1394_PRINT(KERN_ERR, dev->name,
+				      "Could not start data stream reception\n");
+
+			eth1394_iso_shutdown(priv);
+
+			return -EAGAIN;
+		}
+		priv->bc_state = ETHER1394_BC_OPENED;
+	}
+    
+	return 0;
 }
 
 /* This is called after an "ifup" */
 static int ether1394_open (struct net_device *dev)
 {
 	struct eth1394_priv *priv = (struct eth1394_priv *)dev->priv;
+	unsigned long flags;
+	int ret;
 
-	/* Set the spinlock before grabbing IRQ! */
-	priv->lock = SPIN_LOCK_UNLOCKED;
+	/* Something bad happened, don't even try */
+	if (priv->bc_state == ETHER1394_BC_CLOSED)
+		return -EAGAIN;
+
+	spin_lock_irqsave(&priv->lock, flags);
+	ret = ether1394_init_bc(dev);
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	if (ret)
+		return ret;
 
 	netif_start_queue (dev);
 	return 0;
@@ -171,105 +289,34 @@
 	netif_wake_queue (dev);
 }
 
-/* We need to encapsulate the standard header with our own. We use the
- * ethernet header's proto for our own.
- *
- * XXX: This is where we need to create a list of skb's for fragmented
- * packets.  */
-static inline void ether1394_encapsulate (struct sk_buff *skb, struct net_device *dev,
-			    int proto)
-{
-	union eth1394_hdr *hdr =
-		(union eth1394_hdr *)skb_push (skb, hdr_type_len[ETH1394_HDR_LF_UF]);
-
-	hdr->common.lf = ETH1394_HDR_LF_UF;
-	hdr->words.word1 = htons(hdr->words.word1);
-	hdr->uf.ether_type = proto;
-
-	return;
-}
-
-/* Convert a standard ARP packet to 1394 ARP. The first 8 bytes (the
- * entire arphdr) is the same format as the ip1394 header, so they
- * overlap. The rest needs to be munged a bit. The remainder of the
- * arphdr is formatted based on hwaddr len and ipaddr len. We know what
- * they'll be, so it's easy to judge.  */
-static inline void ether1394_arp_to_1394arp (struct sk_buff *skb, struct net_device *dev)
-{
-	struct eth1394_priv *priv =
-		(struct eth1394_priv *)(dev->priv);
-	u16 phy_id = priv->host->node_id & NODE_MASK;
-
-	unsigned char *arp_ptr = (unsigned char *)skb->data;
-	struct eth1394_arp *arp1394 = (struct eth1394_arp *)skb->data;
-	unsigned char arp_data[2*(dev->addr_len+4)];
-
-	/* Copy the main data that we need */
-	memcpy (arp_data, arp_ptr + sizeof(struct arphdr), sizeof (arp_data));
-
-	/* Extend the buffer enough for our new header */
-	skb_put (skb, sizeof (struct eth1394_arp) -
-		 (sizeof (arp_data) + sizeof (struct arphdr)));
-
-#define PROCESS_MEMBER(ptr,val,len) \
-  memcpy (val, ptr, len); ptr += len
-	arp_ptr = arp_data + arp1394->hw_addr_len;
-	PROCESS_MEMBER (arp_ptr, &arp1394->sip, arp1394->ip_addr_len);
-	arp_ptr += arp1394->hw_addr_len;
-	PROCESS_MEMBER (arp_ptr, &arp1394->tip, arp1394->ip_addr_len);
-#undef PROCESS_MEMBER
-
-	/* Now add our own flavor of arp header fields to the orig one */
-	arp1394->hw_addr_len	= IP1394_HW_ADDR_LEN;
-	arp1394->hw_type	= __constant_htons (ARPHRD_IEEE1394);
-	arp1394->s_uniq_id	= cpu_to_le64 (priv->eui[phy_id]);
-	arp1394->max_rec	= priv->max_rec[phy_id];
-	arp1394->sspd		= priv->sspd[phy_id];
-	arp1394->fifo_hi	= htons (priv->fifo_hi[phy_id]);
-	arp1394->fifo_lo	= htonl (priv->fifo_lo[phy_id]);
-
-	return;
-}
-
 static int ether1394_change_mtu(struct net_device *dev, int new_mtu)
 {
-	if ((new_mtu < 68) || (new_mtu > ETHER1394_REGION_ADDR_LEN))
+	struct eth1394_priv *priv = (struct eth1394_priv *)dev->priv;
+	int phy_id = NODEID_TO_NODE(priv->host->node_id);
+
+	if ((new_mtu < 68) || (new_mtu > min(ETH1394_DATA_LEN, (int)(priv->maxpayload[phy_id] -
+					     (sizeof(union eth1394_hdr) + ETHER1394_GASP_OVERHEAD)))))
 		return -EINVAL;
 	dev->mtu = new_mtu;
 	return 0;
 }
 
-static inline void ether1394_register_limits (int nodeid, unsigned char max_rec,
-				       unsigned char sspd, u64 eui, u16 fifo_hi,
-				       u32 fifo_lo, struct eth1394_priv *priv)
+static inline void ether1394_register_limits(int nodeid, u16 maxpayload,
+					     unsigned char sspd, u64 eui, u64 fifo,
+					     struct eth1394_priv *priv)
 {
-	int i;
-
 	if (nodeid < 0 || nodeid >= ALL_NODES) {
 		ETH1394_PRINT_G (KERN_ERR, "Cannot register invalid nodeid %d\n", nodeid);
 		return;
 	}
 
-	priv->max_rec[nodeid]	= max_rec;
-	priv->sspd[nodeid]	= sspd;
-	priv->fifo_hi[nodeid]	= fifo_hi;
-	priv->fifo_lo[nodeid]	= fifo_lo;
-	priv->eui[nodeid]	= eui;
-
-	/* 63 is used for broadcasts to all hosts. It is equal to the
-	 * minimum of all registered nodes. A registered node is one with
-	 * a nonzero offset. Set the values rediculously high to start. We
-	 * know we have atleast one to change the default to.  */
-	sspd = 0xff;
-	max_rec = 0xff;
-	for (i = 0; i < ALL_NODES; i++) {
-		if (!priv->fifo_hi && !priv->fifo_lo) continue; /* Unregistered */
-		if (priv->max_rec[i] < max_rec) max_rec = priv->max_rec[i];
-		if (priv->sspd[i] < sspd) sspd = priv->sspd[i];
-	}
+	priv->maxpayload[nodeid]	= maxpayload;
+	priv->sspd[nodeid]		= sspd;
+	priv->fifo[nodeid]		= fifo;
+	priv->eui[nodeid]		= eui;
 
-	priv->max_rec[ALL_NODES] = max_rec;
-	priv->sspd[ALL_NODES] = sspd;
+	priv->maxpayload[ALL_NODES] = min(priv->maxpayload[ALL_NODES], maxpayload);
+	priv->sspd[ALL_NODES] = min(priv->sspd[ALL_NODES], sspd);
 
 	return;
 }
@@ -277,36 +324,56 @@
 static void ether1394_reset_priv (struct net_device *dev, int set_mtu)
 {
 	unsigned long flags;
+	int i;
 	struct eth1394_priv *priv = (struct eth1394_priv *)dev->priv;
-	int phy_id = priv->host->node_id & NODE_MASK;
+	struct hpsb_host *host = priv->host;
+	int phy_id = NODEID_TO_NODE(host->node_id);
+	u64 guid = *((u64*)&(host->csr.rom[3]));
+	u16 maxpayload = 1 << (((be32_to_cpu(host->csr.rom[2]) >> 12) & 0xf) + 1);
 
 	spin_lock_irqsave (&priv->lock, flags);
 
 	/* Clear the speed/payload/offset tables */
-	memset (priv->max_rec, 0, sizeof (priv->max_rec));
+	memset (priv->maxpayload, 0, sizeof (priv->maxpayload));
 	memset (priv->sspd, 0, sizeof (priv->sspd));
-	memset (priv->fifo_hi, 0, sizeof (priv->fifo_hi));
-	memset (priv->fifo_lo, 0, sizeof (priv->fifo_lo));
+	memset (priv->fifo, 0, sizeof (priv->fifo));
 
-	/* Register our limits now */
-	ether1394_register_limits (phy_id, (be32_to_cpu(priv->host->csr.rom[2]) >> 12) & 0xf,
-				   priv->host->speed_map[(phy_id << 6) + phy_id],
-				   (u64)(((u64)be32_to_cpu(priv->host->csr.rom[3]) << 32) |
-				   be32_to_cpu(priv->host->csr.rom[4])),
-				   ETHER1394_REGION_ADDR >> 32,
-				   ETHER1394_REGION_ADDR & 0xffffffff, priv);
-
-	/* We'll use our max_rec as the default mtu */
-	if (set_mtu)
-		dev->mtu = (1 << (priv->max_rec[phy_id] + 1)) - sizeof (union eth1394_hdr);
+	priv->sspd[ALL_NODES] = ETH1394_SPEED_DEF;
+	priv->maxpayload[ALL_NODES] = eth1394_speedto_maxpayload[priv->sspd[ALL_NODES]];
+
+	priv->bc_state = ETHER1394_BC_CHECK;
 
-	/* Set our hardware address while we're at it */
-	*(nodeid_t *)dev->dev_addr = htons (priv->host->node_id);
+	/* Register our limits now */
+	ether1394_register_limits(phy_id, maxpayload,
+				  host->speed_map[(phy_id << 6) + phy_id],
+				  guid, ETHER1394_REGION_ADDR, priv);
+
+	/* We'll use our maxpayload as the default mtu */
+	if (set_mtu) {
+		dev->mtu = min(ETH1394_DATA_LEN, (int)(priv->maxpayload[phy_id] -
+			       (sizeof(union eth1394_hdr) + ETHER1394_GASP_OVERHEAD)));
+
+		/* Set our hardware address while we're at it */
+		*(u64*)dev->dev_addr = guid;
+		*(u64*)dev->broadcast = ~0x0ULL;
+	}
 
 	spin_unlock_irqrestore (&priv->lock, flags);
-}
 
-static int ether1394_tx (struct sk_buff *skb, struct net_device *dev);
+	for (i = 0; i < ALL_NODES; i++) {
+		struct list_head *lh, *n;
+
+		spin_lock_irqsave(&priv->pdg[i].lock, flags);
+		if (!set_mtu) {
+			list_for_each_safe(lh, n, &priv->pdg[i].list) {
+				purge_partial_datagram(lh);
+			}
+		}
+		INIT_LIST_HEAD(&(priv->pdg[i].list));
+		priv->pdg[i].sz = 0;
+		spin_unlock_irqrestore(&priv->pdg[i].lock, flags);
+	}
+}
 
 /* This function is called by register_netdev */
 static int ether1394_init_dev (struct net_device *dev)
@@ -319,11 +386,21 @@
 	dev->tx_timeout		= ether1394_tx_timeout;
 	dev->change_mtu		= ether1394_change_mtu;
 
+	dev->hard_header	= ether1394_header;
+	dev->rebuild_header	= ether1394_rebuild_header;
+	dev->hard_header_cache	= ether1394_header_cache;
+	dev->header_cache_update= ether1394_header_cache_update;
+	dev->hard_header_parse	= ether1394_header_parse;
+	dev->set_mac_address	= ether1394_mac_addr;
+	dev->do_ioctl		= ether1394_do_ioctl;
+
 	/* Some constants */
 	dev->watchdog_timeo	= ETHER1394_TIMEOUT;
-	dev->flags		= IFF_BROADCAST; /* TODO: Support MCAP */
-	dev->features		= NETIF_F_NO_CSUM|NETIF_F_SG|NETIF_F_HIGHDMA|NETIF_F_FRAGLIST;
-	dev->addr_len		= 2;
+	dev->flags		= IFF_BROADCAST | IFF_MULTICAST;
+	dev->features		= NETIF_F_HIGHDMA;
+	dev->addr_len		= ETH1394_ALEN;
+	dev->hard_header_len 	= ETH1394_HLEN;
+	dev->type		= ARPHRD_IEEE1394;
 
 	ether1394_reset_priv (dev, 1);
 
@@ -337,6 +414,7 @@
  */
 static void ether1394_add_host (struct hpsb_host *host)
 {
+	int i;
 	struct host_info *hi = NULL;
 	struct net_device *dev = NULL;
 	struct eth1394_priv *priv;
@@ -345,10 +423,17 @@
 	if (version_printed++ == 0)
 		ETH1394_PRINT_G (KERN_INFO, "%s\n", version);
 
+	/* We should really have our own alloc_hpsbdev() function in
+	 * net_init.c instead of calling the one for ethernet then hijacking
+	 * it for ourselves.  That way we'd be a real networking device. */
 	dev = alloc_etherdev(sizeof (struct eth1394_priv));
 
-	if (dev == NULL)
+	if (dev == NULL) {
+		ETH1394_PRINT_G (KERN_ERR, "Out of memory trying to allocate "
+				 "etherdevice for IEEE 1394 device %s-%d\n",
+				 host->driver->name, host->id);
 		goto out;
+        }
 
 	SET_MODULE_OWNER(dev);
 
@@ -356,37 +441,51 @@
 
 	priv = (struct eth1394_priv *)dev->priv;
 
+	spin_lock_init(&priv->lock);
 	priv->host = host;
 
-	hi = (struct host_info *)kmalloc (sizeof (struct host_info),
-					  GFP_KERNEL);
+	for (i = 0; i < ALL_NODES; i++) {
+                spin_lock_init(&priv->pdg[i].lock);
+		INIT_LIST_HEAD(&priv->pdg[i].list);
+		priv->pdg[i].sz = 0;
+	}
 
-	if (hi == NULL)
+	hi = hpsb_create_hostinfo(&eth1394_highlevel, host, sizeof(*hi));
+
+	if (hi == NULL) {
+		ETH1394_PRINT_G (KERN_ERR, "Out of memory trying to create "
+				 "hostinfo for IEEE 1394 device %s-%d\n",
+				 host->driver->name, host->id);
 		goto out;
+        }
 
 	if (register_netdev (dev)) {
 		ETH1394_PRINT (KERN_ERR, dev->name, "Error registering network driver\n");
-		kfree (dev);
-		return;
+		goto out;
 	}
 
 	ETH1394_PRINT (KERN_ERR, dev->name, "IEEE-1394 IPv4 over 1394 Ethernet (%s)\n",
 		       host->driver->name);
 
-	INIT_LIST_HEAD (&hi->list);
 	hi->host = host;
 	hi->dev = dev;
 
-	spin_lock_irq (&host_info_lock);
-	list_add_tail (&hi->list, &host_info_list);
-	spin_unlock_irq (&host_info_lock);
-
+	/* Ignore validity in hopes that it will be set in the future.  It'll
+	 * be checked when the eth device is opened. */
+	priv->broadcast_channel = host->csr.broadcast_channel & 0x3f;
+
+	priv->iso = hpsb_iso_recv_init(host, 16 * 4096, 16, priv->broadcast_channel,
+				       1, ether1394_iso);
+	if (priv->iso == NULL) {
+		priv->bc_state = ETHER1394_BC_CLOSED;
+	}
 	return;
 
 out:
 	if (dev != NULL)
-		kfree (dev);
-	ETH1394_PRINT_G (KERN_ERR, "Out of memory\n", 0);
+		kfree(dev);
+	if (hi)
+		hpsb_destroy_hostinfo(&eth1394_highlevel, host);
 
 	return;
 }
@@ -394,17 +493,18 @@
 /* Remove a card from our list */
 static void ether1394_remove_host (struct hpsb_host *host)
 {
-	struct host_info *hi;
+	struct host_info *hi = hpsb_get_hostinfo(&eth1394_highlevel, host);
 
-	spin_lock_irq (&host_info_lock);
-	hi = find_host_info (host);
 	if (hi != NULL) {
-		unregister_netdev (hi->dev);
-		kfree (hi->dev);
-		list_del (&hi->list);
-		kfree (hi);
+		struct eth1394_priv *priv = (struct eth1394_priv *)hi->dev->priv;
+
+		eth1394_iso_shutdown(priv);
+
+		if (hi->dev) {
+			unregister_netdev (hi->dev);
+			kfree(hi->dev);
+		}
 	}
-	spin_unlock_irq (&host_info_lock);
 
 	return;
 }
@@ -412,38 +512,155 @@
 /* A reset has just arisen */
 static void ether1394_host_reset (struct hpsb_host *host)
 {
-	struct net_device *dev = ether1394_find_dev(host);
+	struct host_info *hi = hpsb_get_hostinfo(&eth1394_highlevel, host);
+	struct net_device *dev;
 
 	/* This can happen for hosts that we don't use */
-	if (dev == NULL)
+	if (hi == NULL)
 		return;
 
+	dev = hi->dev;
+
 	/* Reset our private host data, but not our mtu */
 	netif_stop_queue (dev);
 	ether1394_reset_priv (dev, 0);
 	netif_wake_queue (dev);
 }
 
+/******************************************
+ * HW Header net device functions
+ ******************************************/
+/* These functions have been adapted from net/ethernet/eth.c */
+
+
+/* Create a fake MAC header for an arbitrary protocol layer.
+ * saddr=NULL means use device source address
+ * daddr=NULL means leave destination address (eg unresolved arp). */
+static int ether1394_header(struct sk_buff *skb, struct net_device *dev,
+			    unsigned short type, void *daddr, void *saddr,
+			    unsigned len)
+{
+	struct eth1394hdr *eth = (struct eth1394hdr *)skb_push(skb, ETH1394_HLEN);
+
+	eth->h_proto = htons(type);
+
+	if (dev->flags & (IFF_LOOPBACK|IFF_NOARP)) 
+	{
+		memset(eth->h_dest, 0, dev->addr_len);
+		return(dev->hard_header_len);
+	}
+
+	if (daddr)
+	{
+		memcpy(eth->h_dest,daddr,dev->addr_len);
+		return dev->hard_header_len;
+	}
+	
+	return -dev->hard_header_len;
+
+}
+
+
+/* Rebuild the faked MAC header. This is called after an ARP
+ * (or in future other address resolution) has completed on this
+ * sk_buff. We now let ARP fill in the other fields.
+ *
+ * This routine CANNOT use cached dst->neigh!
+ * Really, it is used only when dst->neigh is wrong.
+ */
+static int ether1394_rebuild_header(struct sk_buff *skb)
+{
+	struct eth1394hdr *eth = (struct eth1394hdr *)skb->data;
+	struct net_device *dev = skb->dev;
+
+	switch (eth->h_proto)
+	{
+#ifdef CONFIG_INET
+	case __constant_htons(ETH_P_IP):
+ 		return arp_find((unsigned char*)&eth->h_dest, skb);
+#endif	
+	default:
+		printk(KERN_DEBUG
+		       "%s: unable to resolve type %X addresses.\n", 
+		       dev->name, (int)eth->h_proto);
+		break;
+	}
+
+	return 0;
+}
+
+static int ether1394_header_parse(struct sk_buff *skb, unsigned char *haddr)
+{
+	struct net_device *dev = skb->dev;
+	memcpy(haddr, dev->dev_addr, ETH1394_ALEN);
+	return ETH1394_ALEN;
+}
+
+
+static int ether1394_header_cache(struct neighbour *neigh, struct hh_cache *hh)
+{
+	unsigned short type = hh->hh_type;
+	struct eth1394hdr *eth = (struct eth1394hdr*)(((u8*)hh->hh_data) + 6);
+	struct net_device *dev = neigh->dev;
+
+	if (type == __constant_htons(ETH_P_802_3)) {
+		return -1;
+	}
+
+	eth->h_proto = type;
+	memcpy(eth->h_dest, neigh->ha, dev->addr_len);
+	
+	hh->hh_len = ETH1394_HLEN;
+	return 0;
+}
+
+/* Called by Address Resolution module to notify changes in address. */
+static void ether1394_header_cache_update(struct hh_cache *hh,
+					  struct net_device *dev,
+					  unsigned char * haddr)
+{
+	memcpy(((u8*)hh->hh_data) + 6, haddr, dev->addr_len);
+}
+
+static int ether1394_mac_addr(struct net_device *dev, void *p)
+{
+	if (netif_running(dev))
+		return -EBUSY;
+
+	/* Not going to allow setting the MAC address, we really need to use
+	 * the real one suppliled by the hardware */
+	 return -EINVAL;
+ }
+
+
+
+/******************************************
+ * Datagram reception code
+ ******************************************/
+
 /* Copied from net/ethernet/eth.c */
-static inline unsigned short ether1394_type_trans(struct sk_buff *skb, struct net_device *dev)
+static inline u16 ether1394_type_trans(struct sk_buff *skb,
+				       struct net_device *dev)
 {
-	struct ethhdr *eth;
+	struct eth1394hdr *eth;
 	unsigned char *rawp;
 
 	skb->mac.raw = skb->data;
-	skb_pull (skb, ETH_HLEN);
-	eth = skb->mac.ethernet;
-#if 0
-	if(*eth->h_dest & 1) {
-		if(memcmp(eth->h_dest, dev->broadcast, dev->addr_len)==0)
+	skb_pull (skb, ETH1394_HLEN);
+	eth = (struct eth1394hdr*)skb->mac.raw;
+
+	if (*eth->h_dest & 1) {
+		if (memcmp(eth->h_dest, dev->broadcast, dev->addr_len)==0)
 			skb->pkt_type = PACKET_BROADCAST;
+#if 0
 		else
 			skb->pkt_type = PACKET_MULTICAST;
+#endif
 	} else {
-		if(memcmp(eth->h_dest, dev->dev_addr, dev->addr_len))
+		if (memcmp(eth->h_dest, dev->dev_addr, dev->addr_len))
 			skb->pkt_type = PACKET_OTHERHOST;
         }
-#endif
+
 	if (ntohs (eth->h_proto) >= 1536)
 		return eth->h_proto;
 
@@ -457,99 +674,376 @@
 
 /* Parse an encapsulated IP1394 header into an ethernet frame packet.
  * We also perform ARP translation here, if need be.  */
-static inline unsigned short ether1394_parse_encap (struct sk_buff *skb, struct net_device *dev,
-					     nodeid_t srcid, nodeid_t destid)
+static inline u16 ether1394_parse_encap(struct sk_buff *skb,
+					struct net_device *dev,
+					nodeid_t srcid, nodeid_t destid,
+					u16 ether_type)
 {
-	union eth1394_hdr *hdr = (union eth1394_hdr *)skb->data;
-	unsigned char src_hw[ETH_ALEN], dest_hw[ETH_ALEN];
+	struct eth1394_priv *priv = (struct eth1394_priv *)dev->priv;
+	u64 dest_hw;
 	unsigned short ret = 0;
 
 	/* Setup our hw addresses. We use these to build the
 	 * ethernet header.  */
-	*(u16 *)dest_hw = htons(destid);
-	*(u16 *)src_hw = htons(srcid);
-
-	/* Remove the encapsulation header */
-	hdr->words.word1 = ntohs(hdr->words.word1);
-	skb_pull (skb, hdr_type_len[hdr->common.lf]);
+	if (destid == (LOCAL_BUS | ALL_NODES))
+		dest_hw = ~0ULL;  /* broadcast */
+	else
+		dest_hw = priv->eui[NODEID_TO_NODE(destid)];
 
 	/* If this is an ARP packet, convert it. First, we want to make
 	 * use of some of the fields, since they tell us a little bit
 	 * about the sending machine.  */
-	if (hdr->uf.ether_type == __constant_htons (ETH_P_ARP)) {
+	if (ether_type == __constant_htons (ETH_P_ARP)) {
 		unsigned long flags;
-		u16 phy_id = srcid & NODE_MASK;
-		struct eth1394_priv *priv =
-			(struct eth1394_priv *)dev->priv;
-		struct eth1394_arp arp1394;
+		struct eth1394_arp *arp1394 = (struct eth1394_arp*)skb->data;
 		struct arphdr *arp = (struct arphdr *)skb->data;
 		unsigned char *arp_ptr = (unsigned char *)(arp + 1);
+		u64 fifo_addr = (u64)ntohs(arp1394->fifo_hi) << 32 |
+			ntohl(arp1394->fifo_lo);
+		u8 host_max_rec = (be32_to_cpu(priv->host->csr.rom[2]) >>
+				   12) & 0xf;
+		u8 max_rec = min(host_max_rec, (u8)(arp1394->max_rec));
+		u16 maxpayload = min(eth1394_speedto_maxpayload[arp1394->sspd],
+				     (u16)(1 << (max_rec + 1)));
 
-		memcpy (&arp1394, arp, sizeof (struct eth1394_arp));
 
 		/* Update our speed/payload/fifo_offset table */
 		spin_lock_irqsave (&priv->lock, flags);
-		ether1394_register_limits (phy_id, arp1394.max_rec, arp1394.sspd,
-					   le64_to_cpu (arp1394.s_uniq_id),
-					   ntohs (arp1394.fifo_hi),
-					   ntohl (arp1394.fifo_lo), priv);
+		ether1394_register_limits(NODEID_TO_NODE(srcid), maxpayload,
+					  arp1394->sspd, arp1394->s_uniq_id,
+					  fifo_addr, priv);
 		spin_unlock_irqrestore (&priv->lock, flags);
 
-#define PROCESS_MEMBER(ptr,val,len) \
-  memcpy (ptr, val, len); ptr += len
-                PROCESS_MEMBER (arp_ptr, src_hw, dev->addr_len);
-                PROCESS_MEMBER (arp_ptr, &arp1394.sip, 4);
-                PROCESS_MEMBER (arp_ptr, dest_hw, dev->addr_len);
-                PROCESS_MEMBER (arp_ptr, &arp1394.tip, 4);
-#undef PROCESS_MEMBER
-
-		arp->ar_hln = dev->addr_len;
-		arp->ar_hrd = __constant_htons (ARPHRD_ETHER);
-
-		skb_trim (skb, sizeof (struct arphdr) + 2*(dev->addr_len+4));
+		/* Now that we're done with the 1394 specific stuff, we'll
+		 * need to alter some of the data.  Believe it or not, all
+		 * that needs to be done is sender_IP_address needs to be
+		 * moved, the destination hardware address get stuffed
+		 * in and the hardware address length set to 8.
+		 *
+		 * IMPORTANT: The code below overwrites 1394 specific data
+		 * needed above data so keep the call to
+		 * ether1394_register_limits() before munging the data for the
+		 * higher level IP stack. */
+
+		arp->ar_hln = 8;
+		arp_ptr += arp->ar_hln;		/* skip over sender unique id */
+		*(u32*)arp_ptr = arp1394->sip;	/* move sender IP addr */
+		arp_ptr += arp->ar_pln;		/* skip over sender IP addr */
+
+		if (arp->ar_op == 1)
+			/* just set ARP req target unique ID to 0 */
+			memset(arp_ptr, 0, ETH1394_ALEN);
+		else
+			memcpy(arp_ptr, dev->dev_addr, ETH1394_ALEN);
 	}
 
 	/* Now add the ethernet header. */
-	if (dev->hard_header (skb, dev, __constant_ntohs (hdr->uf.ether_type),
-			      dest_hw, src_hw, skb->len) >= 0)
+	if (dev->hard_header (skb, dev, __constant_ntohs (ether_type),
+			      &dest_hw, NULL, skb->len) >= 0)
 		ret = ether1394_type_trans(skb, dev);
 
 	return ret;
 }
 
+static inline int fragment_overlap(struct list_head *frag_list, int offset, int len)
+{
+	struct list_head *lh;
+	struct fragment_info *fi;
+
+	list_for_each(lh, frag_list) {
+		fi = list_entry(lh, struct fragment_info, list);
+
+		if ( ! ((offset > (fi->offset + fi->len - 1)) ||
+		       ((offset + len - 1) < fi->offset)))
+			return 1;
+	}
+	return 0;
+}
+
+static inline struct list_head *find_partial_datagram(struct list_head *pdgl, int dgl)
+{
+	struct list_head *lh;
+	struct partial_datagram *pd;
+
+	list_for_each(lh, pdgl) {
+		pd = list_entry(lh, struct partial_datagram, list);
+		if (pd->dgl == dgl)
+			return lh;
+	}
+	return NULL;
+}
+
+/* Assumes that new fragment does not overlap any existing fragments */
+static inline int new_fragment(struct list_head *frag_info, int offset, int len)
+{
+	struct list_head *lh;
+	struct fragment_info *fi, *fi2, *new;
+
+	list_for_each(lh, frag_info) {
+		fi = list_entry(lh, struct fragment_info, list);
+		if ((fi->offset + fi->len) == offset) {
+			/* The new fragment can be tacked on to the end */
+			fi->len += len;
+			/* Did the new fragment plug a hole? */
+			fi2 = list_entry(lh->next, struct fragment_info, list);
+			if ((fi->offset + fi->len) == fi2->offset) {
+				/* glue fragments together */
+				fi->len += fi2->len;
+				list_del(lh->next);
+				kfree(fi2);
+			}
+			return 0;
+		} else if ((offset + len) == fi->offset) {
+			/* The new fragment can be tacked on to the beginning */
+			fi->offset = offset;
+			fi->len += len;
+			/* Did the new fragment plug a hole? */
+			fi2 = list_entry(lh->prev, struct fragment_info, list);
+			if ((fi2->offset + fi2->len) == fi->offset) {
+				/* glue fragments together */
+				fi2->len += fi->len;
+				list_del(lh);
+				kfree(fi);
+			}
+			return 0;
+		} else if (offset > (fi->offset + fi->len)) {
+			break;
+		} else if ((offset + len) < fi->offset) {
+			lh = lh->prev;
+			break;
+		}
+	}
+
+	new = kmalloc(sizeof(struct fragment_info), GFP_ATOMIC);
+	if (!new) 
+		return -ENOMEM;
+
+	new->offset = offset;
+	new->len = len;
+
+	list_add(&new->list, lh);
+
+	return 0;
+}
+
+static inline int new_partial_datagram(struct net_device *dev,
+				       struct list_head *pdgl, int dgl,
+				       int dg_size, char *frag_buf,
+				       int frag_off, int frag_len)
+{
+	struct partial_datagram *new;
+
+	new = kmalloc(sizeof(struct partial_datagram), GFP_ATOMIC);
+	if (!new)
+		return -ENOMEM;
+
+	INIT_LIST_HEAD(&new->frag_info);
+
+	if (new_fragment(&new->frag_info, frag_off, frag_len) < 0) {
+		kfree(new);
+		return -ENOMEM;
+	}
+
+	new->dgl = dgl;
+	new->dg_size = dg_size;
+
+	new->skb = dev_alloc_skb(dg_size + dev->hard_header_len + 15);
+	if (!new->skb) {
+		struct fragment_info *fi = list_entry(new->frag_info.next,
+						      struct fragment_info,
+						      list);
+		kfree(fi);
+		kfree(new);
+		return -ENOMEM;
+	}
+
+	skb_reserve(new->skb, (dev->hard_header_len + 15) & ~15);
+	new->pbuf = skb_put(new->skb, dg_size);
+	memcpy(new->pbuf + frag_off, frag_buf, frag_len);
+
+	list_add(&new->list, pdgl);
+
+	return 0;
+}
+
+static inline int update_partial_datagram(struct list_head *pdgl, struct list_head *lh,
+					  char *frag_buf, int frag_off, int frag_len)
+{
+	struct partial_datagram *pd = list_entry(lh, struct partial_datagram, list);
+
+	if (new_fragment(&pd->frag_info, frag_off, frag_len) < 0) {
+		return -ENOMEM;
+	}
+
+	memcpy(pd->pbuf + frag_off, frag_buf, frag_len);
+
+	/* Move list entry to beginnig of list so that oldest partial
+	 * datagrams percolate to the end of the list */
+	list_del(lh);
+	list_add(lh, pdgl);
+
+	return 0;
+}
+
+static inline void purge_partial_datagram(struct list_head *old)
+{
+	struct partial_datagram *pd = list_entry(old, struct partial_datagram, list);
+	struct list_head *lh, *n;
+
+	list_for_each_safe(lh, n, &pd->frag_info) {
+		struct fragment_info *fi = list_entry(lh, struct fragment_info, list);
+		list_del(lh);
+		kfree(fi);
+	}
+	list_del(old);
+	kfree_skb(pd->skb);
+	kfree(pd);
+}
+
+static inline int is_datagram_complete(struct list_head *lh, int dg_size)
+{
+	struct partial_datagram *pd = list_entry(lh, struct partial_datagram, list);
+	struct fragment_info *fi = list_entry(pd->frag_info.next,
+					      struct fragment_info, list);
+
+	return (fi->len == dg_size);
+}
+
 /* Packet reception. We convert the IP1394 encapsulation header to an
  * ethernet header, and fill it with some of our other fields. This is
  * an incoming packet from the 1394 bus.  */
-static int ether1394_write (struct hpsb_host *host, int srcid, int destid,
-			    quadlet_t *data, u64 addr, unsigned int len, u16 flags)
+static int ether1394_data_handler(struct net_device *dev, int srcid, int destid,
+				  char *buf, int len)
 {
 	struct sk_buff *skb;
-	char *buf = (char *)data;
-	unsigned long fl;
-	struct net_device *dev = ether1394_find_dev (host);
+	unsigned long flags;
 	struct eth1394_priv *priv;
-
-	if (dev == NULL) {
-		ETH1394_PRINT_G (KERN_ERR, "Could not find net device for host %p\n",
-				 host);
-		return RCODE_ADDRESS_ERROR;
-	}
+	union eth1394_hdr *hdr = (union eth1394_hdr *)buf;
+	u16 ether_type = 0;  /* initialized to clear warning */
+	int hdr_len;
 
 	priv = (struct eth1394_priv *)dev->priv;
 
-	/* A packet has been received by the ieee1394 bus. Build an skbuff
-	 * around it so we can pass it to the high level network layer. */
+	/* First, did we receive a fragmented or unfragmented datagram? */
+	hdr->words.word1 = ntohs(hdr->words.word1);
 
-	skb = dev_alloc_skb (len + dev->hard_header_len + 15);
-	if (!skb) {
-		HPSB_PRINT (KERN_ERR, "ether1394 rx: low on mem\n");
-		priv->stats.rx_dropped++;
-		return RCODE_ADDRESS_ERROR;
-	}
+	hdr_len = hdr_type_len[hdr->common.lf];
 
-	skb_reserve(skb, (dev->hard_header_len + 15) & ~15);
+	if (hdr->common.lf == ETH1394_HDR_LF_UF) {
+		/* An unfragmented datagram has been received by the ieee1394
+		 * bus. Build an skbuff around it so we can pass it to the
+		 * high level network layer. */
+
+		skb = dev_alloc_skb(len + dev->hard_header_len + 15);
+		if (!skb) {
+			HPSB_PRINT (KERN_ERR, "ether1394 rx: low on mem\n");
+			priv->stats.rx_dropped++;
+			return -1;
+		}
+		skb_reserve(skb, (dev->hard_header_len + 15) & ~15);
+		memcpy(skb_put(skb, len - hdr_len), buf + hdr_len, len - hdr_len);
+		ether_type = hdr->uf.ether_type;
+	} else {
+		/* A datagram fragment has been received, now the fun begins. */
 
-	memcpy (skb_put (skb, len), buf, len);
+		struct list_head *pdgl, *lh;
+		struct partial_datagram *pd;
+		int fg_off;
+		int fg_len = len - hdr_len;
+		int dg_size;
+		int dgl;
+		int retval;
+		int sid = NODEID_TO_NODE(srcid);
+                struct pdg_list *pdg = &(priv->pdg[sid]);
+
+		hdr->words.word3 = ntohs(hdr->words.word3);
+		/* The 4th header word is reserved so no need to do ntohs() */
+
+		if (hdr->common.lf == ETH1394_HDR_LF_FF) {
+			ether_type = hdr->ff.ether_type;
+			dgl = hdr->ff.dgl;
+			dg_size = hdr->ff.dg_size + 1;
+			fg_off = 0;
+		} else {
+			hdr->words.word2 = ntohs(hdr->words.word2);
+			dgl = hdr->sf.dgl;
+			dg_size = hdr->sf.dg_size + 1;
+			fg_off = hdr->sf.fg_off;
+		}
+		spin_lock_irqsave(&pdg->lock, flags);
+
+		pdgl = &(pdg->list);
+		lh = find_partial_datagram(pdgl, dgl);
+
+		if (lh == NULL) {
+			if (pdg->sz == max_partial_datagrams) {
+				/* remove the oldest */
+				purge_partial_datagram(pdgl->prev);
+				pdg->sz--;
+			}
+            
+			retval = new_partial_datagram(dev, pdgl, dgl, dg_size,
+						      buf + hdr_len, fg_off,
+						      fg_len);
+			if (retval < 0) {
+				spin_unlock_irqrestore(&pdg->lock, flags);
+				goto bad_proto;
+			}
+			pdg->sz++;
+			lh = find_partial_datagram(pdgl, dgl);
+		} else {
+			struct partial_datagram *pd;
+
+			pd = list_entry(lh, struct partial_datagram, list);
+
+			if (fragment_overlap(&pd->frag_info, fg_off, fg_len)) {
+				/* Overlapping fragments, obliterate old
+				 * datagram and start new one. */
+				purge_partial_datagram(lh);
+				retval = new_partial_datagram(dev, pdgl, dgl,
+							      dg_size,
+							      buf + hdr_len,
+							      fg_off, fg_len);
+				if (retval < 0) {
+					pdg->sz--;
+					spin_unlock_irqrestore(&pdg->lock, flags);
+					goto bad_proto;
+				}
+			} else {
+				retval = update_partial_datagram(pdgl, lh,
+								 buf + hdr_len,
+								 fg_off, fg_len);
+				if (retval < 0) {
+					/* Couldn't save off fragment anyway
+					 * so might as well obliterate the
+					 * datagram now. */
+					purge_partial_datagram(lh);
+					pdg->sz--;
+					spin_unlock_irqrestore(&pdg->lock, flags);
+					goto bad_proto;
+				}
+			} /* fragment overlap */
+		} /* new datagram or add to existing one */
+
+		pd = list_entry(lh, struct partial_datagram, list);
+
+		if (hdr->common.lf == ETH1394_HDR_LF_FF) {
+			pd->ether_type = ether_type;
+		}
+
+		if (is_datagram_complete(lh, dg_size)) {
+			ether_type = pd->ether_type;
+			pdg->sz--;
+			skb = skb_get(pd->skb);
+			purge_partial_datagram(lh);
+			spin_unlock_irqrestore(&pdg->lock, flags);
+		} else {
+			/* Datagram is not complete, we're done for the
+			 * moment. */
+			spin_unlock_irqrestore(&pdg->lock, flags);
+			return 0;
+		}
+	} /* unframgented datagram or fragmented one */
 
 	/* Write metadata, and then pass to the receive level */
 	skb->dev = dev;
@@ -559,9 +1053,11 @@
 	 * converting to an ethernet frame header, aswell as arp
 	 * conversion if needed. ARP conversion is easier in this
 	 * direction, since we are using ethernet as our backend.  */
-	skb->protocol = ether1394_parse_encap (skb, dev, srcid, destid);
+	skb->protocol = ether1394_parse_encap(skb, dev, srcid, destid,
+					      ether_type);
 
-	spin_lock_irqsave (&priv->lock, fl);
+
+	spin_lock_irqsave(&priv->lock, flags);
 	if (!skb->protocol) {
 		priv->stats.rx_errors++;
 		priv->stats.rx_dropped++;
@@ -569,8 +1065,7 @@
 		goto bad_proto;
 	}
 
-	netif_stop_queue(dev);
-	if (netif_rx (skb) == NET_RX_DROP) {
+	if (netif_rx(skb) == NET_RX_DROP) {
 		priv->stats.rx_errors++;
 		priv->stats.rx_dropped++;
 		goto bad_proto;
@@ -581,124 +1076,547 @@
 	priv->stats.rx_bytes += skb->len;
 
 bad_proto:
-	netif_start_queue(dev);
-	spin_unlock_irqrestore (&priv->lock, fl);
+	if (netif_queue_stopped(dev))
+		netif_wake_queue(dev);
+	spin_unlock_irqrestore(&priv->lock, flags);
 
 	dev->last_rx = jiffies;
 
-	return RCODE_COMPLETE;
+	return 0;
 }
 
-/* This function is our scheduled write */
-static void hpsb_write_sched (void *__ptask)
+static int ether1394_write(struct hpsb_host *host, int srcid, int destid,
+			   quadlet_t *data, u64 addr, size_t len, u16 flags)
+{
+	struct host_info *hi = hpsb_get_hostinfo(&eth1394_highlevel, host);
+
+	if (hi == NULL) {
+		ETH1394_PRINT_G(KERN_ERR, "Could not find net device for host %s\n",
+				host->driver->name);
+		return RCODE_ADDRESS_ERROR;
+	}
+
+	if (ether1394_data_handler(hi->dev, srcid, destid, (char*)data, len))
+		return RCODE_ADDRESS_ERROR;
+	else
+		return RCODE_COMPLETE;
+}
+
+static void ether1394_iso(struct hpsb_iso *iso)
+{
+	quadlet_t *data;
+	char *buf;
+	struct host_info *hi = hpsb_get_hostinfo(&eth1394_highlevel, iso->host);
+	struct net_device *dev;
+	struct eth1394_priv *priv;
+	unsigned int len;
+	u32 specifier_id;
+	u16 source_id;
+	int i;
+	int nready;
+
+	if (hi == NULL) {
+		ETH1394_PRINT_G(KERN_ERR, "Could not find net device for host %s\n",
+				iso->host->driver->name);
+		return;
+	}
+
+	dev = hi->dev;
+
+	nready = hpsb_iso_n_ready(iso);
+	for (i = 0; i < nready; i++) {
+		struct hpsb_iso_packet_info *info = &iso->infos[iso->first_packet + i];
+		data = (quadlet_t*) (iso->data_buf.kvirt + info->offset);
+
+		/* skip over GASP header */
+		buf = (char *)data + 8;
+		len = info->len - 8;
+
+		specifier_id = (((be32_to_cpu(data[0]) & 0xffff) << 8) |
+				((be32_to_cpu(data[1]) & 0xff000000) >> 24));
+		source_id = be32_to_cpu(data[0]) >> 16;
+
+		priv = (struct eth1394_priv *)dev->priv;
+
+		if (info->channel != (iso->host->csr.broadcast_channel & 0x3f) ||
+		   specifier_id != ETHER1394_GASP_SPECIFIER_ID) {
+			/* This packet is not for us */
+			continue;
+		}
+		ether1394_data_handler(dev, source_id, LOCAL_BUS | ALL_NODES,
+				       buf, len);
+	}
+
+	hpsb_iso_recv_release_packets(iso, i);
+
+	dev->last_rx = jiffies;
+}
+
+/******************************************
+ * Datagram transmission code
+ ******************************************/
+
+/* Convert a standard ARP packet to 1394 ARP. The first 8 bytes (the entire
+ * arphdr) is the same format as the ip1394 header, so they overlap.  The rest
+ * needs to be munged a bit.  The remainder of the arphdr is formatted based
+ * on hwaddr len and ipaddr len.  We know what they'll be, so it's easy to
+ * judge.  
+ *
+ * Now that the EUI is used for the hardware address all we need to do to make
+ * this work for 1394 is to insert 2 quadlets that contain max_rec size,
+ * speed, and unicast FIFO address information between the sender_unique_id
+ * and the IP addresses.
+ */
+static inline void ether1394_arp_to_1394arp(struct sk_buff *skb,
+					    struct net_device *dev)
+{
+	struct eth1394_priv *priv = (struct eth1394_priv *)(dev->priv);
+	u16 phy_id = NODEID_TO_NODE(priv->host->node_id);
+
+	struct arphdr *arp = (struct arphdr *)skb->data;
+	unsigned char *arp_ptr = (unsigned char *)(arp + 1);
+	struct eth1394_arp *arp1394 = (struct eth1394_arp *)skb->data;
+
+	/* Believe it or not, all that need to happen is sender IP get moved
+	 * and set hw_addr_len, max_rec, sspd, fifo_hi and fifo_lo.  */
+	arp1394->hw_addr_len	= 16;
+	arp1394->sip		= *(u32*)(arp_ptr + ETH1394_ALEN);
+	arp1394->max_rec	= (be32_to_cpu(priv->host->csr.rom[2]) >> 12) & 0xf;
+	arp1394->sspd		= priv->sspd[phy_id];
+	arp1394->fifo_hi	= htons (priv->fifo[phy_id] >> 32);
+	arp1394->fifo_lo	= htonl (priv->fifo[phy_id] & ~0x0);
+
+	return;
+}
+
+/* We need to encapsulate the standard header with our own. We use the
+ * ethernet header's proto for our own. */
+static inline unsigned int ether1394_encapsulate_prep(unsigned int max_payload,
+						      int proto,
+						      union eth1394_hdr *hdr,
+						      u16 dg_size, u16 dgl)
+{
+	unsigned int adj_max_payload = max_payload - hdr_type_len[ETH1394_HDR_LF_UF];
+
+	/* Does it all fit in one packet? */
+	if (dg_size <= adj_max_payload) {
+		hdr->uf.lf = ETH1394_HDR_LF_UF;
+		hdr->uf.ether_type = proto;
+	} else {
+		hdr->ff.lf = ETH1394_HDR_LF_FF;
+		hdr->ff.ether_type = proto;
+		hdr->ff.dg_size = dg_size - 1;
+		hdr->ff.dgl = dgl;
+		adj_max_payload = max_payload - hdr_type_len[ETH1394_HDR_LF_FF];
+	}
+	return((dg_size + (adj_max_payload - 1)) / adj_max_payload);
+}
+
+static inline unsigned int ether1394_encapsulate(struct sk_buff *skb,
+						 unsigned int max_payload,
+						 union eth1394_hdr *hdr)
+{
+	union eth1394_hdr *bufhdr;
+	int ftype = hdr->common.lf;
+	int hdrsz = hdr_type_len[ftype];
+	unsigned int adj_max_payload = max_payload - hdrsz;
+
+	switch(ftype) {
+	case ETH1394_HDR_LF_UF:
+		bufhdr = (union eth1394_hdr *)skb_push(skb, hdrsz);
+		bufhdr->words.word1 = htons(hdr->words.word1);
+		bufhdr->words.word2 = hdr->words.word2;
+		break;
+
+	case ETH1394_HDR_LF_FF:
+		bufhdr = (union eth1394_hdr *)skb_push(skb, hdrsz);
+		bufhdr->words.word1 = htons(hdr->words.word1);
+		bufhdr->words.word2 = hdr->words.word2;
+		bufhdr->words.word3 = htons(hdr->words.word3);
+		bufhdr->words.word4 = 0;
+
+		/* Set frag type here for future interior fragments */
+		hdr->common.lf = ETH1394_HDR_LF_IF;
+		hdr->sf.fg_off = 0;
+		break;
+		
+	default:
+		hdr->sf.fg_off += adj_max_payload;
+		bufhdr = (union eth1394_hdr *)skb_pull(skb, adj_max_payload);
+		if (max_payload >= skb->len)
+			hdr->common.lf = ETH1394_HDR_LF_LF;
+		bufhdr->words.word1 = htons(hdr->words.word1);
+		bufhdr->words.word2 = htons(hdr->words.word2);
+		bufhdr->words.word3 = htons(hdr->words.word3);
+		bufhdr->words.word4 = 0;
+	}
+
+	return min(max_payload, skb->len);
+}
+
+static inline struct hpsb_packet *ether1394_alloc_common_packet(struct hpsb_host *host)
+{
+	struct hpsb_packet *p;
+
+	p = alloc_hpsb_packet(0);
+	if (p) {
+		p->host = host;
+		p->data = NULL;
+		p->generation = get_hpsb_generation(host);
+		p->type = hpsb_async;
+	}
+	return p;
+}
+
+static inline int ether1394_prep_write_packet(struct hpsb_packet *p,
+					      struct hpsb_host *host,
+					      nodeid_t node, u64 addr,
+					      void * data, int tx_len)
+{
+	p->node_id = node;
+	p->data = NULL;
+
+	p->tcode = TCODE_WRITEB;
+	p->header[1] = (host->node_id << 16) | (addr >> 32);
+	p->header[2] = addr & 0xffffffff;
+
+	p->header_size = 16;
+	p->expect_response = 1;
+
+	if (hpsb_get_tlabel(p)) {
+		ETH1394_PRINT_G(KERN_ERR, "No more tlabels left while sending "
+				"to node " NODE_BUS_FMT "\n", NODE_BUS_ARGS(host, node));
+		return -1;
+	}		
+	p->header[0] = (p->node_id << 16) | (p->tlabel << 10)
+		| (1 << 8) | (TCODE_WRITEB << 4);
+
+	p->header[3] = tx_len << 16;
+	p->data_size = tx_len + (tx_len % 4 ? 4 - (tx_len % 4) : 0);
+	p->data = (quadlet_t*)data;
+
+	return 0;
+}
+
+static inline void ether1394_prep_gasp_packet(struct hpsb_packet *p,
+					      struct eth1394_priv *priv,
+					      struct sk_buff *skb, int length)
+{
+	p->header_size = 4;
+	p->tcode = TCODE_STREAM_DATA;
+
+	p->header[0] = (length << 16) | (3 << 14)
+		| ((priv->broadcast_channel) << 8)
+		| (TCODE_STREAM_DATA << 4);
+	p->data_size = length;
+	p->data = ((quadlet_t*)skb->data) - 2;
+	p->data[0] = cpu_to_be32((priv->host->node_id << 16) |
+				      ETHER1394_GASP_SPECIFIER_ID_HI);
+	p->data[1] = cpu_to_be32((ETHER1394_GASP_SPECIFIER_ID_LO << 24) |
+				      ETHER1394_GASP_VERSION);
+
+	/* Setting the node id to ALL_NODES (not LOCAL_BUS | ALL_NODES)
+	 * prevents hpsb_send_packet() from setting the speed to an arbitrary
+	 * value based on packet->node_id if packet->node_id is not set. */
+	p->node_id = ALL_NODES;
+	p->speed_code = priv->sspd[ALL_NODES];
+}
+
+static inline void ether1394_free_packet(struct hpsb_packet *packet)
+{
+	if (packet->tcode != TCODE_STREAM_DATA)
+		hpsb_free_tlabel(packet);
+	packet->data = NULL;
+	free_hpsb_packet(packet);
+}
+
+static void ether1394_complete_cb(void *__ptask);
+
+static int ether1394_send_packet(struct packet_task *ptask, unsigned int tx_len)
+{
+	struct eth1394_priv *priv = ptask->priv;
+	struct hpsb_packet *packet = NULL;
+
+	packet = ether1394_alloc_common_packet(priv->host);
+	if (!packet)
+		return -1;
+
+	if (ptask->tx_type == ETH1394_GASP) {
+		int length = tx_len + (2 * sizeof(quadlet_t));
+
+		ether1394_prep_gasp_packet(packet, priv, ptask->skb, length);
+	} else if (ether1394_prep_write_packet(packet, priv->host,
+					       ptask->dest_node,
+					       ptask->addr, ptask->skb->data,
+					       tx_len)) {
+		free_hpsb_packet(packet);
+		return -1;
+	}
+
+	ptask->packet = packet;
+	hpsb_set_packet_complete_task(ptask->packet, ether1394_complete_cb,
+				      ptask);
+
+	if (!hpsb_send_packet(packet)) {
+		ether1394_free_packet(packet);
+		return -1;
+	}
+
+	return 0;
+}
+
+
+/* Task function to be run when a datagram transmission is completed */
+static inline void ether1394_dg_complete(struct packet_task *ptask, int fail)
 {
-	struct packet_task *ptask = (struct packet_task *)__ptask;
 	struct sk_buff *skb = ptask->skb;
-	struct net_device *dev = ptask->skb->dev;
+	struct net_device *dev = skb->dev;
 	struct eth1394_priv *priv = (struct eth1394_priv *)dev->priv;
         unsigned long flags;
-
+		
 	/* Statistics */
-	spin_lock_irqsave (&priv->lock, flags);
-	if (!hpsb_write(priv->host, ptask->dest_node,
-			get_hpsb_generation(priv->host),
-			ptask->addr, (quadlet_t *)skb->data, skb->len)) {
-		priv->stats.tx_bytes += skb->len;
-		priv->stats.tx_packets++;
-	} else {
-		//printk("Failed in hpsb_write_sched\n");
+	spin_lock_irqsave(&priv->lock, flags);
+	if (fail) {
 		priv->stats.tx_dropped++;
 		priv->stats.tx_errors++;
-		if (netif_queue_stopped (dev))
-			netif_wake_queue (dev);
+	} else {
+		priv->stats.tx_bytes += skb->len;
+		priv->stats.tx_packets++;
 	}
-	spin_unlock_irqrestore (&priv->lock, flags);
+	spin_unlock_irqrestore(&priv->lock, flags);
 
-	dev->trans_start = jiffies;
-	dev_kfree_skb(skb);
+	dev_kfree_skb_any(skb);
 	kmem_cache_free(packet_task_cache, ptask);
+}
 
-	return;
+
+/* Callback for when a packet has been sent and the status of that packet is
+ * known */
+static void ether1394_complete_cb(void *__ptask)
+{
+	struct packet_task *ptask = (struct packet_task *)__ptask;
+	struct hpsb_packet *packet = ptask->packet;
+	int fail = 0;
+
+	if (packet->tcode != TCODE_STREAM_DATA)
+		fail = hpsb_packet_success(packet);
+
+	ether1394_free_packet(packet);
+
+	ptask->outstanding_pkts--;
+	if (ptask->outstanding_pkts > 0 && !fail)
+	{
+		int tx_len;
+
+		/* Add the encapsulation header to the fragment */
+		tx_len = ether1394_encapsulate(ptask->skb, ptask->max_payload,
+					       &ptask->hdr);
+		if (ether1394_send_packet(ptask, tx_len))
+			ether1394_dg_complete(ptask, 1);
+	} else {
+		ether1394_dg_complete(ptask, fail);
+	}
 }
 
+
+
 /* Transmit a packet (called by kernel) */
 static int ether1394_tx (struct sk_buff *skb, struct net_device *dev)
 {
-	int kmflags = in_interrupt () ? GFP_ATOMIC : GFP_KERNEL;
-	struct ethhdr *eth;
+	int kmflags = in_interrupt() ? GFP_ATOMIC : GFP_KERNEL;
+	struct eth1394hdr *eth;
 	struct eth1394_priv *priv = (struct eth1394_priv *)dev->priv;
 	int proto;
 	unsigned long flags;
 	nodeid_t dest_node;
-	u64 addr;
-	struct packet_task *ptask = NULL;
+	eth1394_tx_type tx_type;
 	int ret = 0;
+	unsigned int tx_len;
+	unsigned int max_payload;
+	u16 dg_size;
+	u16 dgl;
+	struct packet_task *ptask;
+	struct node_entry *ne;
+
+	ptask = kmem_cache_alloc(packet_task_cache, kmflags);
+	if (ptask == NULL) {
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	spin_lock_irqsave (&priv->lock, flags);
+	if (priv->bc_state == ETHER1394_BC_CLOSED) {
+		ETH1394_PRINT(KERN_ERR, dev->name,
+			      "Cannot send packet, no broadcast channel available.\n");
+		ret = -EAGAIN;
+		spin_unlock_irqrestore (&priv->lock, flags);
+		goto fail;
+	}
+
+	if ((ret = ether1394_init_bc(dev))) {
+		spin_unlock_irqrestore (&priv->lock, flags);
+		goto fail;
+	}
+
+	spin_unlock_irqrestore (&priv->lock, flags);
 
 	if ((skb = skb_share_check (skb, kmflags)) == NULL) {
 		ret = -ENOMEM;
 		goto fail;
 	}
 
-	/* Get rid of the ethernet header, but save a pointer */
-	eth = (struct ethhdr *)skb->data;
-	skb_pull (skb, ETH_HLEN);
-
-	/* Save the destination id, and proto for our encapsulation, then
-	 * toss the ethernet header aside like the cheap whore it is.  */
-	dest_node = ntohs (*(nodeid_t *)(eth->h_dest));
+	/* Get rid of the fake eth1394 header, but save a pointer */
+	eth = (struct eth1394hdr*)skb->data;
+	skb_pull(skb, ETH1394_HLEN);
+
+	ne = hpsb_guid_get_entry(be64_to_cpu(*(u64*)eth->h_dest));
+	if (!ne)
+		dest_node = LOCAL_BUS | ALL_NODES;
+	else
+		dest_node = ne->nodeid;
+
 	proto = eth->h_proto;
 
 	/* If this is an ARP packet, convert it */
 	if (proto == __constant_htons (ETH_P_ARP))
 		ether1394_arp_to_1394arp (skb, dev);
 
-	/* Now add our encapsulation header */
-	ether1394_encapsulate (skb, dev, proto);
+	max_payload = priv->maxpayload[NODEID_TO_NODE(dest_node)];
+
+	/* This check should be unnecessary, but we'll keep it for safety for
+	 * a while longer. */
+	if (max_payload < 512) {
+		ETH1394_PRINT(KERN_WARNING, dev->name,
+			      "max_payload too small: %d   (setting to 512)\n",
+			      max_payload);
+		max_payload = 512;
+	}
+
+	/* Set the transmission type for the packet.  ARP packets and IP
+	 * broadcast packets are sent via GASP. */
+	if (memcmp(eth->h_dest, dev->broadcast, ETH1394_ALEN) == 0 ||
+	    proto == __constant_htons(ETH_P_ARP) ||
+	    (proto == __constant_htons(ETH_P_IP) &&
+	     IN_MULTICAST(__constant_ntohl(skb->nh.iph->daddr)))) {
+		tx_type = ETH1394_GASP;
+                max_payload -= ETHER1394_GASP_OVERHEAD;
+	} else {
+		tx_type = ETH1394_WRREQ;
+	}
 
-	/* TODO: The above encapsulate function needs to recognize when a
-	 * packet needs to be split for a specified node. It should create
-	 * a list of skb's that we could then iterate over for the below
-	 * call to schedule our writes.  */
-
-	/* XXX: Right now we accept that we don't exactly follow RFC. When
-	 * we do, we will send ARP requests via GASP format, and so we wont
-	 * need this hack.  */
+	dg_size = skb->len;
 
 	spin_lock_irqsave (&priv->lock, flags);
-	addr = (u64)priv->fifo_hi[dest_node & NODE_MASK] << 32 |
-		priv->fifo_lo[dest_node & NODE_MASK];
+	dgl = priv->dgl[NODEID_TO_NODE(dest_node)];
+	if (max_payload < dg_size + hdr_type_len[ETH1394_HDR_LF_UF])
+		priv->dgl[NODEID_TO_NODE(dest_node)]++;
 	spin_unlock_irqrestore (&priv->lock, flags);
 
-	if (!addr)
-		addr = ETHER1394_REGION_ADDR;
+	ptask->hdr.words.word1 = 0;
+	ptask->hdr.words.word2 = 0;
+	ptask->hdr.words.word3 = 0;
+	ptask->hdr.words.word4 = 0;
+	ptask->skb = skb;
+	ptask->priv = priv;
+	ptask->tx_type = tx_type;
 
-	ptask = kmem_cache_alloc(packet_task_cache, kmflags);
-	if (ptask == NULL) {
-		ret = -ENOMEM;
-		goto fail;
+	if (tx_type != ETH1394_GASP) {
+		u64 addr;
+
+		/* This test is just temporary until ConfigROM support has
+		 * been added to eth1394.  Until then, we need an ARP packet
+		 * after a bus reset from the current destination node so that
+		 * we can get FIFO information. */
+		if (priv->fifo[NODEID_TO_NODE(dest_node)] == 0ULL) {
+			ret = -EAGAIN;
+			goto fail;
+		}
+
+		spin_lock_irqsave(&priv->lock, flags);
+		addr = priv->fifo[NODEID_TO_NODE(dest_node)];
+		spin_unlock_irqrestore(&priv->lock, flags);
+
+		ptask->addr = addr;
+		ptask->dest_node = dest_node;
 	}
 
-	ptask->skb = skb;
-	ptask->addr = addr;
-	ptask->dest_node = dest_node;
-	INIT_TQUEUE(&ptask->tq, hpsb_write_sched, ptask);
-	schedule_task(&ptask->tq);
+	ptask->tx_type = tx_type;
+	ptask->max_payload = max_payload;
+        ptask->outstanding_pkts = ether1394_encapsulate_prep(max_payload, proto,
+							     &ptask->hdr, dg_size,
+							     dgl);
 
+	/* Add the encapsulation header to the fragment */
+	tx_len = ether1394_encapsulate(skb, max_payload, &ptask->hdr);
+	dev->trans_start = jiffies;
+	if (ether1394_send_packet(ptask, tx_len))
+		goto fail;
+
+	netif_wake_queue(dev);
 	return 0;
 fail:
-	printk("Failed in ether1394_tx\n");
+	if (ptask)
+		kmem_cache_free(packet_task_cache, ptask);
 
 	if (skb != NULL)
-		dev_kfree_skb (skb);
+		dev_kfree_skb(skb);
 
 	spin_lock_irqsave (&priv->lock, flags);
 	priv->stats.tx_dropped++;
 	priv->stats.tx_errors++;
-	if (netif_queue_stopped (dev))
-		netif_wake_queue (dev);
 	spin_unlock_irqrestore (&priv->lock, flags);
 
-	return ret;
+	if (netif_queue_stopped(dev))
+		netif_wake_queue(dev);
+
+	return 0;  /* returning non-zero causes serious problems */
+}
+
+static int ether1394_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	switch(cmd) {
+		case SIOCETHTOOL:
+			return ether1394_ethtool_ioctl(dev, (void *) ifr->ifr_data);
+
+		case SIOCGMIIPHY:		/* Get address of MII PHY in use. */
+		case SIOCGMIIREG:		/* Read MII PHY register. */
+		case SIOCSMIIREG:		/* Write MII PHY register. */
+		default:
+			return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static int ether1394_ethtool_ioctl(struct net_device *dev, void *useraddr)
+{
+	u32 ethcmd;
+
+	if (get_user(ethcmd, (u32 *)useraddr))
+		return -EFAULT;
+
+	switch (ethcmd) {
+		case ETHTOOL_GDRVINFO: {
+			struct ethtool_drvinfo info = { ETHTOOL_GDRVINFO };
+			strcpy (info.driver, driver_name);
+			strcpy (info.version, "$Rev: 1043 $");
+			/* FIXME XXX provide sane businfo */
+			strcpy (info.bus_info, "ieee1394");
+			if (copy_to_user (useraddr, &info, sizeof (info)))
+				return -EFAULT;
+			break;
+		}
+		case ETHTOOL_GSET:
+		case ETHTOOL_SSET:
+		case ETHTOOL_NWAY_RST:
+		case ETHTOOL_GLINK:
+		case ETHTOOL_GMSGLVL:
+		case ETHTOOL_SMSGLVL:
+		default:
+			return -EOPNOTSUPP;
+	}
+
+	return 0;
 }
 
 /* Function for incoming 1394 packets */
@@ -708,7 +1626,7 @@
 
 /* Ieee1394 highlevel driver functions */
 static struct hpsb_highlevel eth1394_highlevel = {
-	.name =         driver_name,
+	.name =		driver_name,
 	.add_host =	ether1394_add_host,
 	.remove_host =	ether1394_remove_host,
 	.host_reset =	ether1394_host_reset,
@@ -720,9 +1638,9 @@
 					      0, 0, NULL, NULL);
 
 	/* Register ourselves as a highlevel driver */
-	hpsb_register_highlevel (&eth1394_highlevel);
+	hpsb_register_highlevel(&eth1394_highlevel);
 
-	hpsb_register_addrspace (&eth1394_highlevel, &addr_ops, ETHER1394_REGION_ADDR,
+	hpsb_register_addrspace(&eth1394_highlevel, &addr_ops, ETHER1394_REGION_ADDR,
 				 ETHER1394_REGION_ADDR_END);
 
 	return 0;
@@ -730,7 +1648,7 @@
 
 static void __exit ether1394_exit_module (void)
 {
-	hpsb_unregister_highlevel (&eth1394_highlevel);
+	hpsb_unregister_highlevel(&eth1394_highlevel);
 	kmem_cache_destroy(packet_task_cache);
 }
 
diff -urN drivers/ieee1394/eth1394.h drivers/ieee1394/eth1394.h
--- drivers/ieee1394/eth1394.h	2008-10-10 03:49:22.000000000 -0400
+++ drivers/ieee1394/eth1394.h	2003-11-28 13:26:20.000000000 -0500
@@ -24,40 +24,71 @@
 #ifndef __ETH1394_H
 #define __ETH1394_H
 
-/* Register for incoming packets. This is 8192 bytes, which supports up to
- * 1600mbs. We'll need to change this if that ever becomes "small" :)  */
-#define ETHER1394_REGION_ADDR_LEN	8192
+#include "ieee1394.h"
+
+/* Register for incoming packets. This is 4096 bytes, which supports up to
+ * S3200 (per Table 16-3 of IEEE 1394b-2002). */
+#define ETHER1394_REGION_ADDR_LEN	4096
 #define ETHER1394_REGION_ADDR		0xfffff0200000ULL
 #define ETHER1394_REGION_ADDR_END	(ETHER1394_REGION_ADDR + ETHER1394_REGION_ADDR_LEN)
 
+/* GASP identifier numbers for IPv4 over IEEE 1394 */
+#define ETHER1394_GASP_SPECIFIER_ID	0x00005E
+#define ETHER1394_GASP_SPECIFIER_ID_HI	((ETHER1394_GASP_SPECIFIER_ID >> 8) & 0xffff)
+#define ETHER1394_GASP_SPECIFIER_ID_LO	(ETHER1394_GASP_SPECIFIER_ID & 0xff)
+#define ETHER1394_GASP_VERSION		1
+
+#define ETHER1394_GASP_OVERHEAD (2 * sizeof(quadlet_t))  /* GASP header overhead */
+
 /* Node set == 64 */
 #define NODE_SET			(ALL_NODES + 1)
 
+enum eth1394_bc_states { ETHER1394_BC_CLOSED, ETHER1394_BC_OPENED,
+			 ETHER1394_BC_CHECK };
+
+struct pdg_list {
+	struct list_head list;		/* partial datagram list per node */
+	unsigned int sz;		/* partial datagram list size per node	*/
+	spinlock_t lock;		/* partial datagram lock		*/
+};
+
 /* Private structure for our ethernet driver */
 struct eth1394_priv {
 	struct net_device_stats stats;	/* Device stats			 */
 	struct hpsb_host *host;		/* The card for this dev	 */
-	unsigned char max_rec[NODE_SET];/* Max payload per node		 */
+	u16 maxpayload[NODE_SET];	/* Max payload per node		 */
 	unsigned char sspd[NODE_SET];	/* Max speed per node		 */
-	u16 fifo_hi[ALL_NODES];		/* 16bit hi fifo offset per node */
-	u32 fifo_lo[ALL_NODES];		/* 32bit lo fifo offset per node */
+	u64 fifo[ALL_NODES];		/* FIFO offset per node		 */
 	u64 eui[ALL_NODES];		/* EUI-64 per node		 */
 	spinlock_t lock;		/* Private lock			 */
+	int broadcast_channel;		/* Async stream Broadcast Channel */
+	enum eth1394_bc_states bc_state; /* broadcast channel state	 */
+	struct hpsb_iso *iso;		/* Async stream recv handle	 */
+	struct pdg_list pdg[ALL_NODES]; /* partial RX datagram lists     */
+	int dgl[NODE_SET];              /* Outgoing datagram label per node */
 };
 
 struct host_info {
-	struct list_head list;
 	struct hpsb_host *host;
 	struct net_device *dev;
 };
 
-/* This is our task struct. It's used for the packet complete callback.  */
-struct packet_task {
-	struct sk_buff *skb;	/* Socket buffer we are sending */
-	nodeid_t dest_node;	/* Destination of the packet */
-	u64 addr;		/* Address */
-	struct tq_struct tq;	/* The task */
-};
+
+/* Define a fake hardware header format for the networking core.  Note that
+ * header size cannot exceed 16 bytes as that is the size of the header cache.
+ * Also, we do not need the source address in the header so we omit it and
+ * keep the header to under 16 bytes */
+#define ETH1394_ALEN (8)
+#define ETH1394_HLEN (10)
+
+struct eth1394hdr {
+	unsigned char	h_dest[ETH1394_ALEN];	/* destination eth1394 addr	*/
+	unsigned short	h_proto;		/* packet type ID field	*/
+}  __attribute__((packed));
+
+
+
+typedef enum {ETH1394_GASP, ETH1394_WRREQ} eth1394_tx_type;
 
 /* IP1394 headers */
 #include <asm/byteorder.h>
@@ -65,14 +96,14 @@
 /* Unfragmented */
 #if defined __BIG_ENDIAN_BITFIELD
 struct eth1394_uf_hdr {
-	u8 lf:2;
+	u16 lf:2;
 	u16 res:14;
 	u16 ether_type;		/* Ethernet packet type */
 } __attribute__((packed));
 #elif defined __LITTLE_ENDIAN_BITFIELD
 struct eth1394_uf_hdr {
 	u16 res:14;
-	u8 lf:2;
+	u16 lf:2;
 	u16 ether_type;
 } __attribute__((packed));
 #else
@@ -82,8 +113,8 @@
 /* First fragment */
 #if defined __BIG_ENDIAN_BITFIELD
 struct eth1394_ff_hdr {
-	u8 lf:2;
-	u8 res1:2;
+	u16 lf:2;
+	u16 res1:2;
 	u16 dg_size:12;		/* Datagram size */
 	u16 ether_type;		/* Ethernet packet type */
 	u16 dgl;		/* Datagram label */
@@ -92,8 +123,8 @@
 #elif defined __LITTLE_ENDIAN_BITFIELD
 struct eth1394_ff_hdr {
 	u16 dg_size:12;
-	u8 res1:2;
-	u8 lf:2;
+	u16 res1:2;
+	u16 lf:2;
 	u16 ether_type;
 	u16 dgl;
 	u16 res2;
@@ -105,21 +136,21 @@
 /* XXX: Subsequent fragments, including last */
 #if defined __BIG_ENDIAN_BITFIELD
 struct eth1394_sf_hdr {
-	u8 lf:2;
-	u8 res1:2;
+	u16 lf:2;
+	u16 res1:2;
 	u16 dg_size:12;		/* Datagram size */
-	u8 res2:6;
-	u16 fg_off:10;		/* Fragment offset */
+	u16 res2:4;
+	u16 fg_off:12;		/* Fragment offset */
 	u16 dgl;		/* Datagram label */
 	u16 res3;
 } __attribute__((packed));
 #elif defined __LITTLE_ENDIAN_BITFIELD
 struct eth1394_sf_hdr {
 	u16 dg_size:12;
-	u8 res1:2;
-	u8 lf:2;
-	u16 fg_off:10;
-	u8 res2:6;
+	u16 res1:2;
+	u16 lf:2;
+	u16 fg_off:12;
+	u16 res2:4;
 	u16 dgl;
 	u16 res3;
 } __attribute__((packed));
@@ -129,13 +160,13 @@
 
 #if defined __BIG_ENDIAN_BITFIELD
 struct eth1394_common_hdr {
-	u8 lf:2;
+	u16 lf:2;
 	u16 pad1:14;
 } __attribute__((packed));
 #elif defined __LITTLE_ENDIAN_BITFIELD
 struct eth1394_common_hdr {
 	u16 pad1:14;
-	u8 lf:2;
+	u16 lf:2;
 } __attribute__((packed));
 #else
 #error Unknown bit field type
@@ -187,4 +218,17 @@
 /* Network timeout */
 #define ETHER1394_TIMEOUT	100000
 
+/* This is our task struct. It's used for the packet complete callback.  */
+struct packet_task {
+	struct sk_buff *skb;
+	int outstanding_pkts;
+	eth1394_tx_type tx_type;
+	int max_payload;
+	struct hpsb_packet *packet;
+	struct eth1394_priv *priv;
+	union eth1394_hdr hdr;
+	u64 addr;
+	u16 dest_node;
+};
+
 #endif /* __ETH1394_H */
diff -urN drivers/ieee1394/ieee1394_core.c drivers/ieee1394/ieee1394_core.c
--- drivers/ieee1394/ieee1394_core.c	2008-10-10 03:49:22.000000000 -0400
+++ drivers/ieee1394/ieee1394_core.c	2003-11-28 13:26:20.000000000 -0500
@@ -1235,9 +1235,7 @@
 	/* it's ok to pass a NULL devfs_handle to devfs_unregister */
 	devfs_unregister(ieee1394_devfs_handle);
 	
-#ifdef CONFIG_PROC_FS
 	remove_proc_entry("ieee1394", proc_bus);
-#endif
 }
 
 module_init(ieee1394_init);
@@ -1333,9 +1331,7 @@
 EXPORT_SYMBOL(dma_region_alloc);
 EXPORT_SYMBOL(dma_region_free);
 EXPORT_SYMBOL(dma_region_sync);
-#ifndef CONFIG_ARCH_IPOD
 EXPORT_SYMBOL(dma_region_mmap);
-#endif
 EXPORT_SYMBOL(dma_region_offset_to_bus);
 
 /** iso.c **/
diff -urN drivers/ieee1394/ieee1394_transactions.c drivers/ieee1394/ieee1394_transactions.c
--- drivers/ieee1394/ieee1394_transactions.c	2008-10-10 03:49:22.000000000 -0400
+++ drivers/ieee1394/ieee1394_transactions.c	2003-11-28 13:26:20.000000000 -0500
@@ -143,18 +143,11 @@
 	}
 
 	spin_lock_irqsave(&tp->lock, flags);
-
-#ifndef CONFIG_ARCH_IPOD
+	
 	packet->tlabel = find_next_zero_bit(tp->pool, 64, tp->next);
 	if (packet->tlabel > 63)
 		packet->tlabel = find_first_zero_bit(tp->pool, 64);
 	tp->next = (packet->tlabel + 1) % 64;
-#else
-	packet->tlabel = find_next_zero_bit(tp->pool, 0xe, tp->next);
-	if (packet->tlabel > 0xe)
-		packet->tlabel = find_first_zero_bit(tp->pool, 0xe);
-	tp->next = (packet->tlabel + 1) % 0xe;
-#endif
 	/* Should _never_ happen */
 	BUG_ON(test_and_set_bit(packet->tlabel, tp->pool));
 	tp->allocations++;
diff -urN drivers/ieee1394/nodemgr.c drivers/ieee1394/nodemgr.c
--- drivers/ieee1394/nodemgr.c	2008-10-10 03:49:22.000000000 -0400
+++ drivers/ieee1394/nodemgr.c	2003-11-28 13:26:20.000000000 -0500
@@ -1261,8 +1261,7 @@
 	quadlet_t bc;
 	int status;
 
-	/* if irm_id == -1 then there is no IRM on this bus */
-	if (host->is_irm  || host->irm_id == (nodeid_t)-1)
+	if (host->is_irm)
 		return 1;
 
 	status = hpsb_read(host, LOCAL_BUS | (host->irm_id),
diff -urN drivers/ieee1394/sbp2.c drivers/ieee1394/sbp2.c
--- drivers/ieee1394/sbp2.c	2008-10-10 03:49:22.000000000 -0400
+++ drivers/ieee1394/sbp2.c	2003-11-28 13:26:20.000000000 -0500
@@ -231,7 +231,7 @@
  * enable this define to make use of it. This provides better hotplug
  * support. The mentioned patch is not part of the kernel proper though,
  * because it is considered somewhat of a hack. */
-#define SBP2_USE_SCSI_ADDREM_HACK
+//#define SBP2_USE_SCSI_ADDREM_HACK
 
 
 /*
diff -urN drivers/scsi/hosts.h drivers/scsi/hosts.h
--- drivers/scsi/hosts.h	2008-10-10 03:49:22.000000000 -0400
+++ drivers/scsi/hosts.h	2003-06-13 10:51:36.000000000 -0400
@@ -535,13 +535,6 @@
 int scsi_register_device(struct Scsi_Device_Template * sdpnt);
 void scsi_deregister_device(struct Scsi_Device_Template * tpnt);
 
-/* Support for hot plugging and unplugging devices -- safe for 
- * ieee1394 or USB devices, but probably not for normal SCSI... */
-extern int scsi_add_single_device(struct Scsi_Host *shpnt, 
-	int channel, int id, int lun);
-extern int scsi_remove_single_device(struct Scsi_Host *shpnt, 
-	int channel, int id, int lun);
-
 /* These are used by loadable modules */
 extern int scsi_register_module(int, void *);
 extern int scsi_unregister_module(int, void *);
diff -urN drivers/scsi/scsi.c drivers/scsi/scsi.c
--- drivers/scsi/scsi.c	2008-10-10 03:49:22.000000000 -0400
+++ drivers/scsi/scsi.c	2003-08-25 07:44:42.000000000 -0400
@@ -1554,96 +1554,6 @@
     }
 }
 
-/* Support for plugging/unplugging SCSI devices.  This feature is
- * probably unsafe for standard SCSI devices, but is perfectly
- * normal for things like ieee1394 or USB drives since these
- * busses are designed for hotplugging.  Use at your own risk.... */
-int scsi_add_single_device(struct Scsi_Host *shpnt, 
-	int channel, int id, int lun)
-{
-	Scsi_Device *scd;
-
-	/* Do a bit of sanity checking */
-	if (shpnt==NULL) {
-		return  -ENXIO;
-	}
-
-	/* Check if they asked us to add an already existing device.
-	 * If so, ignore their misguided efforts. */
-	for (scd = shpnt->host_queue; scd; scd = scd->next) {
-		if ((scd->channel == channel && scd->id == id && scd->lun == lun)) {
-			break;
-		}
-	}
-	if (scd) {
-		return -ENOSYS;
-	}
-
-	scan_scsis(shpnt, 1, channel, id, lun);
-	return 0;
-}
-
-/* Support for plugging/unplugging SCSI devices.  This feature is
- * probably unsafe for standard SCSI devices, but is perfectly
- * normal for things like ieee1394 or USB drives since these
- * busses are designed for hotplugging.  Use at your own risk.... */
-int scsi_remove_single_device(struct Scsi_Host *shpnt, 
-	int channel, int id, int lun)
-{
-	Scsi_Device *scd;
-	struct Scsi_Device_Template *SDTpnt;
-
-	/* Do a bit of sanity checking */
-	if (shpnt==NULL) {
-		return  -ENODEV;
-	}
-
-	/* Make sure the specified device is in fact present */
-	for (scd = shpnt->host_queue; scd; scd = scd->next) {
-		if ((scd->channel == channel && scd->id == id && scd->lun == lun)) {
-			break;
-		}
-	}
-	if (scd==NULL) {
-		return -ENODEV;
-	}
-
-	/* See if the specified device is busy */
-	if (scd->access_count)
-		return -EBUSY;
-
-	SDTpnt = scsi_devicelist;
-	while (SDTpnt != NULL) {
-		if (SDTpnt->detach)
-			(*SDTpnt->detach) (scd);
-		SDTpnt = SDTpnt->next;
-	}
-
-	if (scd->attached == 0) {
-		/* Nobody is using this device, so we
-		 * can now free all command structures.  */
-		if (shpnt->hostt->revoke)
-			shpnt->hostt->revoke(scd);
-		devfs_unregister (scd->de);
-		scsi_release_commandblocks(scd);
-
-		/* Now we can remove the device structure */
-		if (scd->next != NULL)
-			scd->next->prev = scd->prev;
-
-		if (scd->prev != NULL)
-			scd->prev->next = scd->next;
-
-		if (shpnt->host_queue == scd) {
-			shpnt->host_queue = scd->next;
-		}
-		blk_cleanup_queue(&scd->request_queue);
-		kfree((char *) scd);
-	}
-
-	return 0;
-}
-
 #ifdef CONFIG_PROC_FS
 static int scsi_proc_info(char *buffer, char **start, off_t offset, int length)
 {
@@ -1696,6 +1606,8 @@
 static int proc_scsi_gen_write(struct file * file, const char * buf,
                               unsigned long length, void *data)
 {
+	struct Scsi_Device_Template *SDTpnt;
+	Scsi_Device *scd;
 	struct Scsi_Host *HBA_ptr;
 	char *p;
 	int host, channel, id, lun;
@@ -1834,11 +1746,33 @@
 				break;
 			}
 		}
-		if ((err=scsi_add_single_device(HBA_ptr, channel, id, lun))==0)
-		    err = length;
+		err = -ENXIO;
+		if (!HBA_ptr)
+			goto out;
+
+		for (scd = HBA_ptr->host_queue; scd; scd = scd->next) {
+			if ((scd->channel == channel
+			     && scd->id == id
+			     && scd->lun == lun)) {
+				break;
+			}
+		}
+
+		err = -ENOSYS;
+		if (scd)
+			goto out;	/* We do not yet support unplugging */
+
+		scan_scsis(HBA_ptr, 1, channel, id, lun);
+
+		/* FIXME (DB) This assumes that the queue_depth routines can be used
+		   in this context as well, while they were all designed to be
+		   called only once after the detect routine. (DB) */
+		/* queue_depth routine moved to inside scan_scsis(,1,,,) so
+		   it is called before build_commandblocks() */
+
+		err = length;
 		goto out;
 	}
-
 	/*
 	 * Usage: echo "scsi remove-single-device 0 1 2 3" >/proc/scsi/scsi
 	 * with  "0 1 2 3" replaced by your "Host Channel Id Lun".
@@ -1864,8 +1798,58 @@
 				break;
 			}
 		}
-		err=scsi_remove_single_device(HBA_ptr, channel, id, lun);
-		goto out;
+		err = -ENODEV;
+		if (!HBA_ptr)
+			goto out;
+
+		for (scd = HBA_ptr->host_queue; scd; scd = scd->next) {
+			if ((scd->channel == channel
+			     && scd->id == id
+			     && scd->lun == lun)) {
+				break;
+			}
+		}
+
+		if (scd == NULL)
+			goto out;	/* there is no such device attached */
+
+		err = -EBUSY;
+		if (scd->access_count)
+			goto out;
+
+		SDTpnt = scsi_devicelist;
+		while (SDTpnt != NULL) {
+			if (SDTpnt->detach)
+				(*SDTpnt->detach) (scd);
+			SDTpnt = SDTpnt->next;
+		}
+
+		if (scd->attached == 0) {
+			/*
+			 * Nobody is using this device any more.
+			 * Free all of the command structures.
+			 */
+                        if (HBA_ptr->hostt->revoke)
+                                HBA_ptr->hostt->revoke(scd);
+			devfs_unregister (scd->de);
+			scsi_release_commandblocks(scd);
+
+			/* Now we can remove the device structure */
+			if (scd->next != NULL)
+				scd->next->prev = scd->prev;
+
+			if (scd->prev != NULL)
+				scd->prev->next = scd->next;
+
+			if (HBA_ptr->host_queue == scd) {
+				HBA_ptr->host_queue = scd->next;
+			}
+			blk_cleanup_queue(&scd->request_queue);
+			kfree((char *) scd);
+		} else {
+			goto out;
+		}
+		err = 0;
 	}
 out:
 	
diff -urN drivers/scsi/scsi_syms.c drivers/scsi/scsi_syms.c
--- drivers/scsi/scsi_syms.c	2008-10-10 03:49:22.000000000 -0400
+++ drivers/scsi/scsi_syms.c	2002-08-02 20:39:44.000000000 -0400
@@ -103,9 +103,3 @@
 extern int scsi_delete_timer(Scsi_Cmnd *);
 EXPORT_SYMBOL(scsi_add_timer);
 EXPORT_SYMBOL(scsi_delete_timer);
-
-/* Support for hot plugging and unplugging devices -- safe for 
- * ieee1394 or USB devices, but probably not for normal SCSI... */
-EXPORT_SYMBOL(scsi_add_single_device);
-EXPORT_SYMBOL(scsi_remove_single_device);
-
diff -urN fs/hfsplus/super.c fs/hfsplus/super.c
--- fs/hfsplus/super.c	2008-10-10 03:49:22.000000000 -0400
+++ fs/hfsplus/super.c	2003-08-25 07:44:43.000000000 -0400
@@ -238,10 +238,10 @@
 	if ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY))
 		return 0;
 	if (!(*flags & MS_RDONLY)) {
-#if 0
 		struct hfsplus_vh *vhdr = HFSPLUS_SB(sb).s_vhdr;
 
-                if (!(vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_UNMNT))) {
+		if ((vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_INCNSTNT)) ||
+		    !(vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_UNMNT))) {
 			printk("HFS+-fs warning: Filesystem was not cleanly unmounted, "
 			       "running fsck.hfsplus is recommended.  leaving read-only.\n");
 			sb->s_flags |= MS_RDONLY;
@@ -251,7 +251,6 @@
 			sb->s_flags |= MS_RDONLY;
 			*flags |= MS_RDONLY;
 		}
-#endif
 	}
 	return 0;
 }
@@ -344,8 +343,8 @@
 	/* Set up operations so we can load metadata */
 	sb->s_op = &hfsplus_sops;
 
-#if 0
-	if (!(vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_UNMNT))) {
+	if ((vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_INCNSTNT)) ||
+	    !(vhdr->attributes & cpu_to_be32(HFSPLUS_VOL_UNMNT))) {
 		if (!silent)
 			printk("HFS+-fs warning: Filesystem was not cleanly unmounted, "
 			       "running fsck.hfsplus is recommended.  mounting read-only.\n");
@@ -355,7 +354,6 @@
 			printk("HFS+-fs: Filesystem is marked locked, mounting read-only.\n");
 		sb->s_flags |= MS_RDONLY;
 	}
-#endif
 
 	/* Load metadata objects (B*Trees) */
 	HFSPLUS_SB(sb).ext_tree = hfsplus_open_btree(sb, HFSPLUS_EXT_CNID);
diff -urN fs/hfsplus/wrapper.c fs/hfsplus/wrapper.c
--- fs/hfsplus/wrapper.c	2008-10-10 03:49:22.000000000 -0400
+++ fs/hfsplus/wrapper.c	2003-08-25 07:44:43.000000000 -0400
@@ -14,7 +14,6 @@
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
 #include <linux/buffer_head.h>
 #endif
-#include <asm/unaligned.h>
 
 #include "hfsplus_fs.h"
 #include "hfsplus_raw.h"
@@ -46,7 +45,7 @@
 		return 0;
 	wd->ablk_start = be16_to_cpu(*(u16 *)(bufptr + HFSP_WRAPOFF_ABLKSTART));
 
-	extent = be32_to_cpu(get_unaligned((u32 *)(bufptr + HFSP_WRAPOFF_EMBEDEXT)));
+	extent = be32_to_cpu(*(u32 *)(bufptr + HFSP_WRAPOFF_EMBEDEXT));
 	wd->embed_start = (extent >> 16) & 0xFFFF;
 	wd->embed_count = extent & 0xFFFF;
 
diff -urN fs/partitions/check.c fs/partitions/check.c
--- fs/partitions/check.c	2008-10-10 03:30:30.000000000 -0400
+++ fs/partitions/check.c	2008-10-10 03:43:43.000000000 -0400
@@ -124,8 +124,6 @@
 	 * IDE devices use multiple major numbers, but the drives
 	 * are named as:  {hda,hdb}, {hdc,hdd}, {hde,hdf}, {hdg,hdh}..
 	 * This requires special handling here.
-	 *
-	 * MD devices are named md0, md1, ... md15, fix it up here.
 	 */
 	switch (hd->major) {
 		case IDE9_MAJOR:
@@ -209,7 +207,7 @@
 void add_gd_partition(struct gendisk *hd, int minor, int start, int size)
 {
 #ifndef CONFIG_DEVFS_FS
-	char buf[MAX_DISKNAME_LEN];
+	char buf[40];
 #endif
 
 	hd->part[minor].start_sect = start;
@@ -231,7 +229,7 @@
 	static int first_time = 1;
 	unsigned long first_sector;
 	struct block_device *bdev;
-	char buf[MAX_DISKNAME_LEN];
+	char buf[64];
 	int i;
 
 	if (first_time)
diff -urN include/asm-armnommu/arch-ipod/hardware.h include/asm-armnommu/arch-ipod/hardware.h
--- include/asm-armnommu/arch-ipod/hardware.h	2008-10-10 03:49:22.000000000 -0400
+++ include/asm-armnommu/arch-ipod/hardware.h	2008-10-10 03:43:43.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003,2004 Bernard Leach (leachbj@bouncycastle.org)
+ * Copyright (c) 2003-2005 Bernard Leach (leachbj@bouncycastle.org)
  */
 
 #ifndef __ASM_ARCH_HARDWARE_H
@@ -8,6 +8,41 @@
 /* this is called from drivers/block/blkmem.c */
 #define HARD_RESET_NOW() ipod_hard_reset()
 
+/* PP5020,PP5002 register definitions */
+#define PP5002_PROC_ID	0xc4000000
+#define PP5002_COP_CTRL	0xcf004058
+
+#define PP5020_PROC_ID	0x60000000
+#define PP5020_COP_CTRL	0x60007004
+
+#define PP5002_IDE_PRIMARY_BASE		0xc00031e0
+#define PP5002_IDE_PRIMARY_CONTROL	0xc00033f8
+
+#define PP5020_IDE_PRIMARY_BASE		0xc30001e0
+#define PP5020_IDE_PRIMARY_CONTROL	0xc30003f8
+
+
+/* special locations in fast ram */
+#define PP_CPU_TYPE	0x40000000
+
+#define DMA_READ_OFF	0x40000004
+#define DMA_WRITE_OFF	0x40000008
+#define DMA_ACTIVE	0x4000000c
+#define DMA_STEREO	0x40000010
+#define DMA_HANDLER	(ipod_dma_handler_t *)0x40000014
+
+#define DMA_BASE	0x40000018
+
+#define COP_HANDLER	(ipod_dma_handler_t *)0x4001501C
+#define COP_STATE	0x40015020
+
+
+#define SYSINFO_TAG	(unsigned char *)0x40017f18
+#define SYSINFO_PTR	(struct sysinfo_t **)0x40017f1c
+
+#define SYSINFO_TAG_PP5022	(unsigned char *)0x4001ff18
+#define SYSINFO_PTR_PP5022	(struct sysinfo_t **)0x4001ff1c
+
 #ifndef __ASSEMBLY__
 struct sysinfo_t {
 	unsigned IsyS;  /* == "IsyS" */
@@ -65,16 +100,25 @@
 
 extern unsigned ipod_get_hw_version(void);
 extern struct sysinfo_t *ipod_get_sysinfo(void);
+extern int ipod_is_pp5022();
 
 extern void ipod_i2c_init(void);
 extern int ipod_i2c_send_bytes(unsigned int addr, unsigned int len, unsigned char *data);
 extern int ipod_i2c_send(unsigned int addr, int data0, int data1);
+extern int ipod_i2c_send_byte(unsigned int addr, int data0);
+extern int ipod_i2c_read_byte(unsigned int addr, unsigned int *data);
+
+extern void ipod_i2c_lock();
+extern void ipod_i2c_unlock();
 
 extern void ipod_serial_init(void);
 
 typedef void (*ipod_dma_handler_t)(void);
+typedef void (*ipod_cop_handler_t)(void);
+
 
 extern void ipod_set_process_dma(ipod_dma_handler_t new_handler);
+extern void ipod_set_handle_cop(ipod_cop_handler_t new_handler);
 
 #endif
 
diff -urN include/asm-armnommu/arch-ipod/irqs.h include/asm-armnommu/arch-ipod/irqs.h
--- include/asm-armnommu/arch-ipod/irqs.h	2008-10-10 03:49:22.000000000 -0400
+++ include/asm-armnommu/arch-ipod/irqs.h	2008-10-10 03:43:43.000000000 -0400
@@ -1,22 +1,53 @@
 /*
- * Copyright (c) 2003, Bernard Leach <leachbj@bouncycastle.org>
+ * Copyright (c) 2003-2005, Bernard Leach <leachbj@bouncycastle.org>
  */
 
 #ifndef __ASM_ARCH_IRQS_H__
 #define __ASM_ARCH_IRQS_H__
 
-#define IDE_INT0_IRQ	1
-#define SER0_IRQ	4
-#define I2S_IRQ		5
-#define SER1_IRQ	7
-#define TIMER1_IRQ	11
-#define GPIO_IRQ	14
-#define DMA_OUT_IRQ	30
-#define DMA_IN_IRQ	31
+#define NR_IRQS	64
 
-#define NR_IRQS	32
-
-#define VALID_IRQ(x)	(x==IDE_INT0_IRQ||x==SER0_IRQ||x==I2S_IRQ||x==SER1_IRQ||x==TIMER1_IRQ||x==GPIO_IRQ||x==DMA_OUT_IRQ||x==DMA_IN_IRQ)
+/* PP5002 */
+#define PP5002_IDE_IRQ		1
+#define PP5002_SER0_IRQ		4
+#define PP5002_I2S_IRQ		5
+#define PP5002_SER1_IRQ		7
+#define PP5002_TIMER1_IRQ	11
+#define PP5002_GPIO_IRQ		14
+#define PP5002_DMA_OUT_IRQ	30
+#define PP5002_DMA_IN_IRQ	31
+
+#define PP5002_VALID_IRQ(x)	(x==PP5002_IDE_IRQ||x==PP5002_SER0_IRQ||x==PP5002_I2S_IRQ||x==PP5002_SER1_IRQ||x==PP5002_TIMER1_IRQ||x==PP5002_GPIO_IRQ||x==PP5002_DMA_OUT_IRQ||x==PP5002_DMA_IN_IRQ)
+
+#define PP5002_IDE_MASK		(1 << PP5002_IDE_IRQ)
+#define PP5002_SER0_MASK	(1 << PP5002_SER0_IRQ)
+#define PP5002_I2S_MASK		(1 << PP5002_I2S_IRQ)
+#define PP5002_SER1_MASK	(1 << PP5002_SER1_IRQ)
+#define PP5002_TIMER1_MASK	(1 << PP5002_TIMER1_IRQ)
+#define PP5002_GPIO_MASK	(1 << PP5002_GPIO_IRQ)
+#define PP5002_DMA_OUT_MASK	(1 << PP5002_DMA_OUT_IRQ)
+
+/* PP5020 */
+#define PP5020_TIMER1_IRQ	0
+#define PP5020_TIMER2_IRQ	1
+#define PP5020_I2S_IRQ		10
+#define PP5020_IDE_IRQ		23
+#define PP5020_GPIO0_IRQ	(32+0)
+#define PP5020_GPIO1_IRQ	(32+1)
+#define PP5020_SER0_IRQ		(32+4)
+#define PP5020_SER1_IRQ		(32+5)
+#define PP5020_I2C_IRQ		(32+8)
+
+#define PP5020_VALID_IRQ(x)	(x==PP5020_TIMER1_IRQ||x==PP5020_I2S_IRQ||x==PP5020_GPIO0_IRQ||x==PP5020_GPIO1_IRQ||x==PP5020_SER0_IRQ||x==PP5020_SER1_IRQ||x==PP5020_I2C_IRQ||x==PP5020_IDE_IRQ)
+
+#define PP5020_TIMER1_MASK	(1 << PP5020_TIMER1_IRQ)
+#define PP5020_I2S_MASK		(1 << PP5020_I2S_IRQ)
+#define PP5020_IDE_MASK		(1 << PP5020_IDE_IRQ)
+#define PP5020_GPIO0_MASK	(1 << (PP5020_GPIO0_IRQ-32))
+#define PP5020_GPIO1_MASK	(1 << (PP5020_GPIO1_IRQ-32))
+#define PP5020_SER0_MASK	(1 << (PP5020_SER0_IRQ-32))
+#define PP5020_SER1_MASK	(1 << (PP5020_SER1_IRQ-32))
+#define PP5020_I2C_MASK		(1 << (PP5020_I2C_IRQ-32))
 
 #endif
 
diff -urN include/asm-armnommu/arch-ipod/keyboard.h include/asm-armnommu/arch-ipod/keyboard.h
--- include/asm-armnommu/arch-ipod/keyboard.h	2008-10-10 03:49:22.000000000 -0400
+++ include/asm-armnommu/arch-ipod/keyboard.h	2008-10-10 04:02:31.000000000 -0400
@@ -13,7 +13,11 @@
 #define kbd_translate(sc,kcp,rm)	({ *(kcp) = (sc); 1; })
 #define kbd_unexpected_up(kc)		(0200)
 #define kbd_leds(leds)
+#ifdef CONFIG_KB_IPOD
 #define kbd_init_hw()			ipodkb_init_hw()
+#else
+#define kbd_init_hw()
+#endif
 #define kbd_enable_irq()
 #define kbd_disable_irq()
 
diff -urN include/asm-armnommu/arch-ipod/serial.h include/asm-armnommu/arch-ipod/serial.h
--- include/asm-armnommu/arch-ipod/serial.h	2008-10-10 03:49:22.000000000 -0400
+++ include/asm-armnommu/arch-ipod/serial.h	2008-10-10 04:02:31.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, Bernard Leach (leachbj@bouncycastle.org)
+ * Copyright (c) 2003-2005, Bernard Leach (leachbj@bouncycastle.org)
  */
 
 #ifndef __ASM_ARCH_SERIAL_H
@@ -17,8 +17,13 @@
 #undef SERIAL_DEBUG_AUTOCONF
 
 
-#define IPOD_SER0_BASE	0xc0006000
-#define IPOD_SER1_BASE	0xc0006040
+/* PP5002 */
+#define PP5002_IPOD_SER0_BASE	0xc0006000
+#define PP5002_IPOD_SER1_BASE	0xc0006040
+
+/* PP5020 */
+#define PP5020_IPOD_SER0_BASE	0x70006000
+#define PP5020_IPOD_SER1_BASE	0x70006040
 
 /* The UART is clocked at 24MHz */
 #define BASE_BAUD	(24576000 / 16)
@@ -32,20 +37,20 @@
 	{  \
 	magic: 0, \
 	baud_base: BASE_BAUD, \
-	irq: SER0_IRQ, \
+	irq: PP5002_SER0_IRQ, \
 	flags: STD_COM_FLAGS, \
 	type: PORT_UNKNOWN, \
-	iomem_base: (u8*)IPOD_SER0_BASE, \
+	iomem_base: (u8*)PP5002_IPOD_SER0_BASE, \
 	iomem_reg_shift: 2, \
 	io_type: SERIAL_IO_MEM \
 	},      /* ttyS0 */ \
         {  \
         magic: 0, \
         baud_base: BASE_BAUD, \
-        irq: SER1_IRQ, \
+        irq: PP5002_SER1_IRQ, \
         flags: STD_COM_FLAGS, \
         type: PORT_UNKNOWN, \
-        iomem_base: (u8*)IPOD_SER1_BASE, \
+        iomem_base: (u8*)PP5002_IPOD_SER1_BASE, \
         iomem_reg_shift: 2, \
         io_type: SERIAL_IO_MEM \
 	}       /* ttyS1 */
diff -urN include/asm-armnommu/arch-ipod/time.h include/asm-armnommu/arch-ipod/time.h
--- include/asm-armnommu/arch-ipod/time.h	2008-10-10 03:49:22.000000000 -0400
+++ include/asm-armnommu/arch-ipod/time.h	2008-10-10 03:43:43.000000000 -0400
@@ -13,10 +13,13 @@
  * supply the kernel with out time(r) functions.
  */
 
-extern unsigned long ipod_gettimeoffset(void);
 extern int ipod_set_rtc(void);
 extern void ipod_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs);
 
+extern unsigned long pp5002_gettimeoffset(void);
+
+extern unsigned long pp5020_gettimeoffset(void);
+
 /* */
 extern struct irqaction timer_irq;
 
@@ -29,22 +32,37 @@
  */
 extern __inline__ void setup_timer(void)
 {
-	/* store in kernel's function pointer */
-	gettimeoffset = ipod_gettimeoffset;
 	set_rtc = ipod_set_rtc;
-
-	/* set up the timer interrupt */
 	timer_irq.handler = ipod_timer_interrupt;
 
-	/* clear timer1 */
-	outl(0x0, IPOD_TIMER0);
-	inl(IPOD_TIMER0_ACK);
-
-	/* enable timer, period, trigger value 0x2710 -> 100Hz */
-	outl(0xc0000000 | USECS_PER_INT, IPOD_TIMER0);
-
-	setup_arm_irq(TIMER1_IRQ, &timer_irq);
-	enable_irq(TIMER1_IRQ);
+	if ((ipod_get_hw_version() >> 16) > 0x3) {
+		/* store in kernel's function pointer */
+		gettimeoffset = pp5020_gettimeoffset;
+
+		/* clear timer1 */
+		outl(0x0, PP5020_TIMER1);
+		inl(PP5020_TIMER1_ACK);
+
+		/* enable timer, period, trigger value 0x2710 -> 100Hz */
+		outl(0xc0000000 | USECS_PER_INT, PP5020_TIMER1);
+
+		setup_arm_irq(PP5020_TIMER1_IRQ, &timer_irq);
+		enable_irq(PP5020_TIMER1_IRQ);
+	}
+	else {
+		/* store in kernel's function pointer */
+		gettimeoffset = pp5002_gettimeoffset;
+
+		/* clear timer1 */
+		outl(0x0, PP5002_TIMER1);
+		inl(PP5002_TIMER1_ACK);
+
+		/* enable timer, period, trigger value 0x2710 -> 100Hz */
+		outl(0xc0000000 | USECS_PER_INT, PP5002_TIMER1);
+
+		setup_arm_irq(PP5002_TIMER1_IRQ, &timer_irq);
+		enable_irq(PP5002_TIMER1_IRQ);
+	}
 }
 
 #endif
diff -urN include/asm-armnommu/arch-ipod/timex.h include/asm-armnommu/arch-ipod/timex.h
--- include/asm-armnommu/arch-ipod/timex.h	2008-10-10 03:49:22.000000000 -0400
+++ include/asm-armnommu/arch-ipod/timex.h	2008-10-10 03:43:43.000000000 -0400
@@ -1,15 +1,26 @@
 /*
- * Copyright (c) 2003, Bernard Leach (leachbj@bouncycastle.org)
+ * Copyright (c) 2003-2005, Bernard Leach (leachbj@bouncycastle.org)
  */
 
 #ifndef __ASM_ARCH_TIMEX_H__
 #define __ASM_ARCH_TIMEX_H__
 
-#define IPOD_TIMER0       0xcf001100
-#define IPOD_TIMER0_ACK   0xcf001104
-#define IPOD_TIMER_STATUS 0xcf001110
-
 #define USECS_PER_INT 0x2710
 
+/* PP5002 registers */
+#define PP5002_TIMER1       0xcf001100
+#define PP5002_TIMER1_ACK   0xcf001104
+
+#define PP5002_TIMER_STATUS 0xcf001110
+
+/* PP5020 registers */
+#define PP5020_TIMER1       0x60005000
+#define PP5020_TIMER1_ACK   0x60005004
+
+#define PP5020_TIMER2       0x60005008
+#define PP5020_TIMER2_ACK   0x6000500c
+
+#define PP5020_TIMER_STATUS 0x60005010
+
 #endif
 
